
<!DOCTYPE html>


<html lang="en" data-content_root="../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>1. Introduction &#8212; Geomstats latest documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=3ee479438cf8b5e0d341" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=3ee479438cf8b5e0d341" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=3ee479438cf8b5e0d341" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=3ee479438cf8b5e0d341" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=a746c00c" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery.css?v=61a4c737" />
    <link rel="stylesheet" type="text/css" href="../_static/nbsphinx-code-cells.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=3ee479438cf8b5e0d341" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=3ee479438cf8b5e0d341" />
  <script src="../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=3ee479438cf8b5e0d341"></script>

    <script src="../_static/documentation_options.js?v=c6e86fd7"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'notebooks/01_foundations__manifolds';</script>
    <link rel="canonical" href="geomstats.github.io/notebooks/01_foundations__manifolds.html" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="1. What is a Connection?" href="02_foundations__connection_riemannian_metric.html" />
    <link rel="prev" title="What is the motivation for analyzing data on manifolds?" href="00_foundations__introduction_to_geomstats.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
    <meta name="docbuild:last-update" content="Jun 10, 2024, 4:39:49 PM"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
<div class="bd-header__inner bd-page-width">
  <button class="sidebar-toggle primary-toggle" aria-label="Site navigation">
    <span class="fa-solid fa-bars"></span>
  </button>
  
  
  <div class="col-lg-3 navbar-header-items__start">
    
      <div class="navbar-item">

  

<a class="navbar-brand logo" href="../index.html">
  
  
  
  
  
  
    <p class="title logo__title">Geomstats latest documentation</p>
  
</a></div>
    
  </div>
  
  <div class="col-lg-9 navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item">
<nav class="navbar-nav">
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item pst-header-nav-item">
  <a class="nav-link nav-internal" href="../getting_started/index.html">
    Getting Started
  </a>
</li>


<li class="nav-item pst-header-nav-item current active">
  <a class="nav-link nav-internal" href="../explanation/index.html">
    Explanation
  </a>
</li>


<li class="nav-item pst-header-nav-item">
  <a class="nav-link nav-internal" href="../tutorials/index.html">
    Tutorials
  </a>
</li>


<li class="nav-item pst-header-nav-item">
  <a class="nav-link nav-internal" href="../contributing/index.html">
    Contributing Guide
  </a>
</li>


<li class="nav-item pst-header-nav-item">
  <a class="nav-link nav-internal" href="../api/index.html">
    API Reference
  </a>
</li>

            <li class="nav-item dropdown pst-header-nav-item">
                <button class="btn dropdown-toggle nav-item" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-controls="pst-nav-more-links">
                    More
                </button>
                <ul id="pst-nav-more-links" class="dropdown-menu">
                    
<li class="nav-item ">
  <a class="nav-link dropdown-item nav-internal" href="../roadmap.html">
    Roadmap
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link dropdown-item nav-internal" href="../governance.html">
    Governance
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link dropdown-item nav-internal" href="../gsod.html">
    Google Season of Docs
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link dropdown-item nav-internal" href="../hackathons.html">
    Hackathons
  </a>
</li>

                </ul>
            </li>
            
  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          

 <script>
 document.write(`
   <button class="btn navbar-btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script>
        </div>
      
      
        <div class="navbar-item">

<script>
document.write(`
  <button class="btn btn-sm navbar-btn theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch nav-link" data-mode="light"><i class="fa-solid fa-sun fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="dark"><i class="fa-solid fa-moon fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="auto"><i class="fa-solid fa-circle-half-stroke fa-lg"></i></span>
  </button>
`);
</script></div>
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">

 <script>
 document.write(`
   <button class="btn navbar-btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script>
    </div>
  

  
    <button class="sidebar-toggle secondary-toggle" aria-label="On this page">
      <span class="fa-solid fa-outdent"></span>
    </button>
  
</div>

    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          
          
            <div class="navbar-item">
<nav class="navbar-nav">
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item pst-header-nav-item">
  <a class="nav-link nav-internal" href="../getting_started/index.html">
    Getting Started
  </a>
</li>


<li class="nav-item pst-header-nav-item current active">
  <a class="nav-link nav-internal" href="../explanation/index.html">
    Explanation
  </a>
</li>


<li class="nav-item pst-header-nav-item">
  <a class="nav-link nav-internal" href="../tutorials/index.html">
    Tutorials
  </a>
</li>


<li class="nav-item pst-header-nav-item">
  <a class="nav-link nav-internal" href="../contributing/index.html">
    Contributing Guide
  </a>
</li>


<li class="nav-item pst-header-nav-item">
  <a class="nav-link nav-internal" href="../api/index.html">
    API Reference
  </a>
</li>


<li class="nav-item pst-header-nav-item">
  <a class="nav-link nav-internal" href="../roadmap.html">
    Roadmap
  </a>
</li>


<li class="nav-item pst-header-nav-item">
  <a class="nav-link nav-internal" href="../governance.html">
    Governance
  </a>
</li>


<li class="nav-item pst-header-nav-item">
  <a class="nav-link nav-internal" href="../gsod.html">
    Google Season of Docs
  </a>
</li>


<li class="nav-item pst-header-nav-item">
  <a class="nav-link nav-internal" href="../hackathons.html">
    Hackathons
  </a>
</li>

  </ul>
</nav></div>
          
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">

<script>
document.write(`
  <button class="btn btn-sm navbar-btn theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch nav-link" data-mode="light"><i class="fa-solid fa-sun fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="dark"><i class="fa-solid fa-moon fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="auto"><i class="fa-solid fa-circle-half-stroke fa-lg"></i></span>
  </button>
`);
</script></div>
        
      </div>
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
<nav class="bd-docs-nav bd-links"
     aria-label="Section Navigation">
  <p class="bd-links__title" role="heading" aria-level="1">Section Navigation</p>
  <div class="bd-toc-item navbar-nav"><ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="00_foundations__introduction_to_geomstats.html">What is the motivation for analyzing data on manifolds?</a></li>

<li class="toctree-l1 current active"><a class="current reference internal" href="#">1. Introduction</a></li>





<li class="toctree-l1"><a class="reference internal" href="02_foundations__connection_riemannian_metric.html">1. What is a Connection?</a></li>







<li class="toctree-l1"><a class="reference internal" href="17_foundations__stratified_spaces.html">Stratified spaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="21_foundations__sub_riemannian_geometry_and_the_heisenberg_group.html">Tutorial: Sub-Riemannian geometry on the Heisenberg group</a></li>
</ul>
</div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">



<nav aria-label="Breadcrumb" class="d-print-none">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    
    <li class="breadcrumb-item"><a href="../explanation/index.html" class="nav-link">Explanation</a></li>
    
    <li class="breadcrumb-item active" aria-current="page">1. Introduction</li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <div class="admonition note">
  <p>Notebook source code:
    <a class="reference external" href="https://github.com/geomstats/geomstats/blob/main/notebooks/01_foundations__manifolds.ipynb">notebooks/01_foundations__manifolds.ipynb</a>
    <br>Run it yourself on binder
    <a href="https://mybinder.org/v2/gh/geomstats/geomstats/main?filepath=notebooks/01_foundations__manifolds.ipynb"><img alt="Binder badge"
    src="https://mybinder.org/badge_logo.svg"
    style="vertical-align:text-bottom"></a>
  </p>
</div><p><span class="math notranslate nohighlight">\(\textbf{Lead Author: Adele Myers}\)</span></p>
<p>Inspired by: Guigui, Miolane, Pennec, 2022. Introduction to Riemannian Geometry and Geometric Statistics: from basic theory to implementation with Geomstats.</p>
<p>Note: Before you start to read this notebook, run the following code. This will import packages that will allow later code to run.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span> In [1]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">geomstats.backend</span> <span class="k">as</span> <span class="nn">gs</span>

<span class="n">gs</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">2020</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area stderr docutils container">
<div class="highlight"><pre>
INFO: Using numpy backend
</pre></div></div>
</div>
<section id="1.-Introduction">
<h1>1. Introduction<a class="headerlink" href="#1.-Introduction" title="Link to this heading">#</a></h1>
<p>Welcome to the <code class="docutils literal notranslate"><span class="pre">Manifold</span></code> class notebook! In this notebook, we will discuss manifolds and the <code class="docutils literal notranslate"><span class="pre">Manifold</span></code> class in Geomstats. Geomstats is a software which analyzes data on manifolds, so naturally the <code class="docutils literal notranslate"><span class="pre">Manifold</span></code> class is quite important.</p>
<p>You will learn:</p>
<ol class="arabic simple">
<li><p>What is a manifold?</p></li>
<li><p>Why do we care about manifolds?</p></li>
<li><p>What does the <code class="docutils literal notranslate"><span class="pre">Manifold</span></code> class do?</p></li>
<li><p>How is the <code class="docutils literal notranslate"><span class="pre">Manifold</span></code> class structured?</p>
<ol class="arabic simple">
<li><p>What is an open set?</p></li>
<li><p>What is a closed set?</p></li>
<li><p>What is a tangent space?</p></li>
</ol>
</li>
</ol>
<p><img alt="45b625975b174f0ca11fe602018a15eb" src="../_images/manifold_intro.png" /></p>
</section>
<section id="2.-What-is-a-Manifold?">
<h1>2. What is a Manifold?<a class="headerlink" href="#2.-What-is-a-Manifold?" title="Link to this heading">#</a></h1>
<p><span class="math notranslate nohighlight">\(\textbf{Intuition:}\)</span> When you are first learning, it can be a helpful starting point to think of a manifold as a surface. This surface can have any dimension and any shape as long as it is smooth (in the sense of being continuous and differentiable). (This is not a particularly precise definition, but it can be helpful starting point for building intuition.) For example, a hypersphere is a two dimensional manifold, and we will often use this manifold in examples.</p>
<section id="2.1-Precise-Mathematical-Definition">
<h2>2.1 Precise Mathematical Definition<a class="headerlink" href="#2.1-Precise-Mathematical-Definition" title="Link to this heading">#</a></h2>
<p>A manifold is a set of points that satisfy a specific set of constraints. More specifically, a nonempty subset M <span class="math notranslate nohighlight">\(\subseteq \mathbb{R}^{N}\)</span> is a d-dimensional manifold if and only if ANY of the following conditions hold:</p>
<ol class="arabic simple">
<li><p>(Local parametrization) For every <span class="math notranslate nohighlight">\(p \in M\)</span>, there are two open subsets <span class="math notranslate nohighlight">\(V \subseteq \mathbb{R}^{d}\)</span> and <span class="math notranslate nohighlight">\(U \subseteq \mathbb{R}^{N}\)</span> with <span class="math notranslate nohighlight">\(p \in U\)</span> and <span class="math notranslate nohighlight">\(0 \in V\)</span>. There is also a smooth function <span class="math notranslate nohighlight">\(f: V \to \mathbb{R}^{N}\)</span> such that <span class="math notranslate nohighlight">\(f(0) = p\)</span>, where <span class="math notranslate nohighlight">\(f\)</span> is a homeomorphism between V and <span class="math notranslate nohighlight">\(U \cap M\)</span>, and <span class="math notranslate nohighlight">\(f\)</span> is an immersion at 0.</p></li>
<li><p>(Local implicit function) For every <span class="math notranslate nohighlight">\(p \in M\)</span>, there exists an open set <span class="math notranslate nohighlight">\(U \in \mathbb{R}^{N}\)</span> and a smooth map <span class="math notranslate nohighlight">\(f: U \to \mathbb{R}^{N-d}\)</span> that is a submersion at p, such that <span class="math notranslate nohighlight">\(U \cap M = f^{-1}\)</span>({0}).</p></li>
<li><p>(Local Graph) For every <span class="math notranslate nohighlight">\(x \in M\)</span>, there exists an open neighborhood <span class="math notranslate nohighlight">\(U \subseteq \mathbb{R}^{N}\)</span> of <span class="math notranslate nohighlight">\(x\)</span>, a neighborhood <span class="math notranslate nohighlight">\(V \subseteq \mathbb{R}^{d}\)</span> of 0 and a smooth map <span class="math notranslate nohighlight">\(f: V \to \mathbb{R}^{N-d}\)</span> such that <span class="math notranslate nohighlight">\(U \cap M = graph(f)^{2}\)</span></p></li>
</ol>
</section>
<section id="2.2-Imprecise-%22Layman's-Terms%22-Definition:">
<h2>2.2 Imprecise “Layman’s Terms” Definition:<a class="headerlink" href="#2.2-Imprecise-%22Layman's-Terms%22-Definition:" title="Link to this heading">#</a></h2>
<p>A <span class="math notranslate nohighlight">\(\textbf{manifold}\)</span> is a set of points that satisfy a specific set of constraints, and these constraints are given by the mathematical definition above. That means that if a set of points satisfies any one of the conditions, then it is a manifold. However, these conditions can be hard to digest. We can translate the above mathematical conditions into three different ways of describing manifolds:</p>
<ol class="arabic simple">
<li><p>(Local Parametrization) a manifold is a topological space that locally resembles Euclidean space near each point. For example, consider a two dimensional grid. We would not be able to deform this grid to have the shape of a sphere under any circumstance, but at each <span class="math notranslate nohighlight">\(\textbf{local}\)</span> point on the manifold, we can approximate the space around the point with a Euclidean grid.</p></li>
<li><p>(Local Implicit Function) a manifold can be understood as the set of points that verify a constraint defined by an implicit equation, given by the function <span class="math notranslate nohighlight">\(f\)</span>. (see hypersphere example)</p></li>
<li><p>(Local Graph) a manifold can be understood as a d-dimensional surface described by d variables, i.e. by the “graph” of a smooth function <span class="math notranslate nohighlight">\(f: (x_1,...,x_d) \to f(x_1,...,x_d)\)</span>. This local graph cannot be applied globally (to the whole manifold) because a function <span class="math notranslate nohighlight">\(f\)</span> must have only one output per set of inputs, and if we were to try to describe the whole manifold with such a graph, then many manifolds would have more than one output for one set of inputs.</p></li>
</ol>
<p>The figure below provides a visualization of each of these definitions. The first figure is a visualization of “local parametrization”, the second is a visualization of “local implicit function” and the third is a visualization of “local graph”:</p>
<p><img alt="4bcfa401d89b4f57969eb09ce7b8388d" src="../_images/manifold_definitions1.png" /></p>
<p><img alt="0a182b4462fd49bbaf7dcefba456735e" src="../_images/manifold_definitions2.png" /></p>
<p>Each one of these definitions of a manifold is important because each one gives us an additional way to describe a manifold. This is useful because some manifolds are much easier described (or computationally implemented) by one of these definitions than the others. For example, any three of these definitions can be used to describe a hypersphere, but a hypersphere is most easily implemented using definition (2).</p>
</section>
<section id="2.3-Hypersphere-example:">
<h2>2.3 Hypersphere example:<a class="headerlink" href="#2.3-Hypersphere-example:" title="Link to this heading">#</a></h2>
<p>Here, we will consider how to prove that a hypersphere is a manifold using the second condition in the definition of a manifold above (2).</p>
<p>A <span class="math notranslate nohighlight">\(\textbf{hypersphere}\)</span> is any of a set of objects (n-dimensional spheres) resulting from the generalization of a one-dimensional circle and a two-dimensional sphere. The dimension of the manifold is n and is equal to the number of degrees of freedom of a point moving on In n-dimensional space, a hypersphere is the set of all points that are a given distance (called the radius) from a given point (called the center). For example, a 2-dimensional hypersphere in 3-dimensions describes all
the points in 3D space that lie on the surface of a sphere. In other words, a hypersphere describes all of the points that lie in three dimensions that have two degrees of freedom <span class="math notranslate nohighlight">\((\phi, \theta)\)</span>.</p>
<p><span class="math notranslate nohighlight">\(\textbf{How do we know that a hypersphere is a manifold?}\)</span> Well, we know from the definition of a hypersphere that a hypersphere is the set of all points that are a given distance from the center of your coordinate system. For example in 3-dimensions, the surface <span class="math notranslate nohighlight">\(S\)</span> of a sphere with radius 1 can be described by the relation:</p>
<p><span class="math notranslate nohighlight">\(|x|^{2} = 1\)</span></p>
<p>This simply says that all the points must be a distance of 1 away from the center. (see above figure (b) and take a = 1).</p>
<p>We can now define a function</p>
<p><span class="math notranslate nohighlight">\(f(x) = |x|^{2} - 1\)</span></p>
<p>We know that this function <span class="math notranslate nohighlight">\(f\)</span> will always equal zero for all points that lie on the surface <span class="math notranslate nohighlight">\(S\)</span> because in order for a point to fall on the surface <span class="math notranslate nohighlight">\(S\)</span> the condition <span class="math notranslate nohighlight">\(|x|^{2} = 1\)</span> must be true. In other words,</p>
<p><span class="math notranslate nohighlight">\(x \in S \iff f(x) = 0\)</span></p>
<p>which tells us that</p>
<p><span class="math notranslate nohighlight">\(x \in S \iff x \in f^{-1}\)</span>({0})</p>
<p>This last line matches the definition of a manifold: <span class="math notranslate nohighlight">\(M = f^{-1}\)</span>({0}) where <span class="math notranslate nohighlight">\(M\)</span> is the set of points <span class="math notranslate nohighlight">\(x\)</span> that satisfy the condition <span class="math notranslate nohighlight">\(|x|^{2} = 1\)</span>. Therefore, the set of points that satisfy the condition <span class="math notranslate nohighlight">\(|x|^{2} = 1\)</span> form a manifold.</p>
</section>
<section id="2.4-More-examples-of-manifolds:">
<h2>2.4 More examples of manifolds:<a class="headerlink" href="#2.4-More-examples-of-manifolds:" title="Link to this heading">#</a></h2>
<p>A hypersphere is one type of manifold, but there are many other types of manifolds that are commonly used and seen in nature. We will show a few examples here to help you build intuition about what a manifold is and what a manifold can look like.</p>
<p>For example, a torus (the surface of a donut) is a manifold.</p>
<p><img alt="649e57c1f24444a28f1545c222a843d8" src="../_images/manifold_torus.png" /></p>
<p>A klein bottle (the surface of the shape shown below) is also a manifold.</p>
<p><img alt="86f44a1d982543209fcdc2ae581e332c" src="../_images/manifold_klein_bottle.png" /></p>
<p>Perhaps a more familiar example for those in physics: Minkowski space (or Minkowski spacetime) is a combination of three-dimensional Euclidean space and time into a four-dimensional manifold (where x, y, z, and time are the dimensions of the space). This manifold is theorized to take one of three forms. A 4-dimensional manifold of: (a) flat curvature, (b) positive curvature, or (c) negative curvature.</p>
<p><img alt="05542bee084242668cbda3771dd0be56" src="../_images/manifold_spacetime.jpeg" /></p>
</section>
</section>
<section id="3.-Why-do-we-care-about-manifolds?">
<h1>3. Why do we care about manifolds?<a class="headerlink" href="#3.-Why-do-we-care-about-manifolds?" title="Link to this heading">#</a></h1>
<p><span class="math notranslate nohighlight">\(\textbf{Manifolds are important because data in nature &quot;naturally falls on manifolds&quot;}\)</span>, and as we discussed in the introduction section, knowing the manifold that a data set belongs to may give you more predictive power and a better understanding of the data’s evolution.</p>
<p><span class="math notranslate nohighlight">\(\textbf{What does it mean for data to &quot;naturally fall on a manifold&quot;?}\)</span> In nature, data are often subject to constraints, and these constraints force the data to lie on manifolds. For example, consider the position of cities on the earth.</p>
<p><img alt="73635cc5a44a4ffa9a8ac7a9f4c2aeac" src="../_images/manifold_cities_on_earth.png" /></p>
<p>The cities are subject to the following constraints: 1) they cannot fly above the surface of the earth because gravity holds them down and 2) they cannot sink down into the earth because the surface of the earth holds them up. Therefore, they are constrained to move (or not move) on the surface of a 3-dimensional sphere. This space that they are confined to exist in should sound familiar– it is the space of a 2-dimensional hypersphere!</p>
<p>Other data falls on manifolds in similar ways: the data is subject to certain constraints, which forces it to fall on a manifold.</p>
</section>
<section id="4.-What-does-the-Manifold-class-do?">
<h1>4. What does the <code class="docutils literal notranslate"><span class="pre">Manifold</span></code> class do?<a class="headerlink" href="#4.-What-does-the-Manifold-class-do?" title="Link to this heading">#</a></h1>
<p>The <code class="docutils literal notranslate"><span class="pre">Manifold</span></code> class describes different types of manifolds. The <code class="docutils literal notranslate"><span class="pre">Manifold</span></code> class and its subclasses implement methods that establish the properties of different types of manifolds, and the manifolds that exist under these subclasses inherit the properties implemented in their respective subclasses.</p>
<p>Note: The words “class”, “subclass”, “methods” refer to <a class="reference external" href="https://www.educative.io/blog/object-oriented-programming">object oriented programming</a>.</p>
<p>The manifold class also provides ways of checking whether a vector is <span class="math notranslate nohighlight">\(\textit{tangent}\)</span> to a manifold and ways of projecting a vector to the <span class="math notranslate nohighlight">\(\textit{tangent space}\)</span> of a manifold. In order to better describe what this means, we will now define <span class="math notranslate nohighlight">\(\textit{tangent vectors}\)</span> and <span class="math notranslate nohighlight">\(\textit{tangent spaces}\)</span>.</p>
<section id="4.1-Tangent-Vectors">
<h2>4.1 Tangent Vectors<a class="headerlink" href="#4.1-Tangent-Vectors" title="Link to this heading">#</a></h2>
<p>Here we will provide a brief reminder of tangent vectors as a way to lay the groundwork for discussing tangent spaces.</p>
<p>A <span class="math notranslate nohighlight">\(\textbf{tangent vector}\)</span> is a vector that is “tangent” to a curve or surface at a given point. When a vector is “tangent” to a curve, this means that the vector has the same slope as the curve does at that point.</p>
<p><img alt="82d581a9e5d84ac39471a30742b70d31" src="../_images/manifold_tangent_vector.png" /></p>
</section>
<section id="4.2-Tangent-Spaces">
<h2>4.2 Tangent Spaces<a class="headerlink" href="#4.2-Tangent-Spaces" title="Link to this heading">#</a></h2>
<p>Now we will introduce the concept of a “tangent space”. The tangent space at a certain point on a manifold is comprised of all of the possible tangent vectors that exist at that point. For example, if you are considering the tangent space on a curve, then the only possible tangent vectors are tangent vectors that point forward and backward along the line (a). However, if you are considering the tangent space at a point on a surface, then the tangent vectors can point forward, backward, left,
right, and everywhere in between, and the set of all tangent vectors forms a plane (b).</p>
<p><img alt="943c48b6142240469fbe2cc3866aa8fd" src="../_images/manifold_tangent_space.jpeg" /></p>
<p>Thus, the tangent space of a 1-dimensional manifold (curve) is also one dimensional, and the tangent space of a 2-dimensional manifold (a 2-dimensional surface) is also 2-dimensional.</p>
<p>Similarly, for every n-dimensional manifold, there exists an n-dimensional tangent space at each point on the manifold, and the tangent space is comprised of all possible tangent vectors on that manifold.</p>
</section>
</section>
<section id="5.-How-is-the-Manifold-class-structured?">
<h1>5. How is the <code class="docutils literal notranslate"><span class="pre">Manifold</span></code> class structured?<a class="headerlink" href="#5.-How-is-the-Manifold-class-structured?" title="Link to this heading">#</a></h1>
<p>The hierarchical structure of the classes inheriting from the <code class="docutils literal notranslate"><span class="pre">Manifold</span></code> parent class is as follows (this Figure is a courtesy of Nicolas Guigui):</p>
<p><img alt="d62b554b8d6c41c2a1daa5b9aa78ea4e" src="../_images/manifold_hierarchy.jpeg" /></p>
<p>As discussed in the previous section, one of the primary purposes of the <code class="docutils literal notranslate"><span class="pre">Manifold</span></code> class is to hold information about various types of manifolds. Rules that are universally true for all manifolds are implemented in methods in the parent class <code class="docutils literal notranslate"><span class="pre">Manifold</span></code>. Rules that are true for some types of manifolds are implemented in the subclasses of <code class="docutils literal notranslate"><span class="pre">Manifold</span></code>: <code class="docutils literal notranslate"><span class="pre">LevelSet</span></code>, <code class="docutils literal notranslate"><span class="pre">VectorSpaceOpenSet</span></code>, <code class="docutils literal notranslate"><span class="pre">FiberBundle</span></code>, <code class="docutils literal notranslate"><span class="pre">ProductManifold</span></code>, <code class="docutils literal notranslate"><span class="pre">VectorSpace</span></code>, <code class="docutils literal notranslate"><span class="pre">MatrixLieAlgebra</span></code>, and <code class="docutils literal notranslate"><span class="pre">MatrixLieGroup</span></code>.
Specific types of manifolds are described in methods within these subclasses.</p>
<p>In this notebook, we will focus on describing the subclasses pertinent to the geometry module of geomstats: <code class="docutils literal notranslate"><span class="pre">LevelSet</span></code>, <code class="docutils literal notranslate"><span class="pre">VectorSpaceOpenSet</span></code>, <code class="docutils literal notranslate"><span class="pre">ProductManifold</span></code> and <code class="docutils literal notranslate"><span class="pre">VectorSpace</span></code>.</p>
<p>In the following subsections, we will discuss the methods and ideas implemented in the parent class and its subclasses.</p>
<section id="5.1-The-Parent-Class:-Manifold">
<h2>5.1 The Parent Class: <code class="docutils literal notranslate"><span class="pre">Manifold</span></code><a class="headerlink" href="#5.1-The-Parent-Class:-Manifold" title="Link to this heading">#</a></h2>
<p>The Manifold parent class is an abstract base class which provides the minimal skeleton of attributes and methods expected in its subclasses. Note that the methods of the abstract parent class are declared, but they contain no implementation, and they are overridden by the subclasses. The properties that are declared in the <code class="docutils literal notranslate"><span class="pre">Manifold</span></code> class are properties that all types of manifold must possess. For example, the following methods and attributes are implemented in <code class="docutils literal notranslate"><span class="pre">Manifold</span></code>:</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">dim</span></code>: <span class="math notranslate nohighlight">\(\textit{attribute}\)</span>. the dimension of the manifold. “How many coordinates are necessary to fully describe the manifold?”</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">belongs()</span></code>: <span class="math notranslate nohighlight">\(\textit{method}\)</span>. evaluates whether a given element belongs to that manifold</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">is_tangent()</span></code>: <span class="math notranslate nohighlight">\(\textit{method}\)</span>. evaluates whether a given vector is a tangent vector at a given point</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">random_point()</span></code>: <span class="math notranslate nohighlight">\(\textit{method}\)</span>. generates a random point that lies on the manifold</p></li>
</ol>
<p>While the abstract methods in Manifold do not contain any implementation, the methods of the subclasses of <code class="docutils literal notranslate"><span class="pre">Manifold</span></code>, such as the <code class="docutils literal notranslate"><span class="pre">Hypersphere</span></code> subclass, <span class="math notranslate nohighlight">\(\textit{are}\)</span> implemented and can be run. We will now exemplify this in the following section</p>
<section id="5.1.1-Examples-of-Using-Manifold's-Attributes-and-Methods-in-the-Subclass:-Hypersphere">
<h3>5.1.1 Examples of Using <code class="docutils literal notranslate"><span class="pre">Manifold</span></code>’s Attributes and Methods in the Subclass: <code class="docutils literal notranslate"><span class="pre">Hypersphere</span></code><a class="headerlink" href="#5.1.1-Examples-of-Using-Manifold's-Attributes-and-Methods-in-the-Subclass:-Hypersphere" title="Link to this heading">#</a></h3>
<p><span class="math notranslate nohighlight">\(\textbf{Attributes:}\)</span></p>
<p><code class="docutils literal notranslate"><span class="pre">dim</span></code> : If we build a hypersphere of dimension 2 with the following code, we can check that <code class="docutils literal notranslate"><span class="pre">sphere.dim</span></code> gives back 2. Run the following code to verify this:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span> In [2]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">geomstats.geometry.hypersphere</span> <span class="kn">import</span> <span class="n">Hypersphere</span>

<span class="n">sphere</span> <span class="o">=</span> <span class="n">Hypersphere</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The dimension of the sphere is </span><span class="si">{</span><span class="n">sphere</span><span class="o">.</span><span class="n">dim</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
The dimension of the sphere is 2
</pre></div></div>
</div>
<p><span class="math notranslate nohighlight">\(\textbf{Methods:}\)</span></p>
<p><code class="docutils literal notranslate"><span class="pre">belongs</span></code> : We can re-use the sphere we just built (called “sphere”) and verify that the point (0, 0, 1) belongs to that sphere (it is the north pole). Run the following code to verify this using Geomstats.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span> In [3]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">geomstats.backend</span> <span class="k">as</span> <span class="nn">gs</span>

<span class="n">sphere</span><span class="o">.</span><span class="n">belongs</span><span class="p">(</span><span class="n">gs</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span> Out [3]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
True
</pre></div></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">is_tangent</span></code> : The vector (1, 1, 0 ) is tangent to the sphere at the north pole, since it does not have a vertical component (last component is equal to 0). Run the following code to verify this using Geomstats.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span> In [4]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sphere</span><span class="o">.</span><span class="n">is_tangent</span><span class="p">(</span><span class="n">vector</span><span class="o">=</span><span class="n">gs</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span> <span class="n">base_point</span><span class="o">=</span><span class="n">gs</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span> Out [4]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
True
</pre></div></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">random_point</span></code> : Now, we will use <code class="docutils literal notranslate"><span class="pre">random_point</span></code> to generate a random point, and then we will use <code class="docutils literal notranslate"><span class="pre">belongs</span></code> to prove that this random point belongs to the sphere.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span> In [5]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">geomstats.geometry.hypersphere</span> <span class="kn">import</span> <span class="n">Hypersphere</span>

<span class="n">rp</span> <span class="o">=</span> <span class="n">Hypersphere</span><span class="o">.</span><span class="n">random_point</span><span class="p">(</span><span class="n">sphere</span><span class="p">)</span>

<span class="n">sphere</span><span class="o">.</span><span class="n">belongs</span><span class="p">(</span><span class="n">rp</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span> Out [5]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
True
</pre></div></div>
</div>
</section>
<section id="5.1.2-The-Full-Manifold-Class-Code">
<h3>5.1.2 The Full <code class="docutils literal notranslate"><span class="pre">Manifold</span></code> Class Code<a class="headerlink" href="#5.1.2-The-Full-Manifold-Class-Code" title="Link to this heading">#</a></h3>
<p>You can see all of the methods in the <code class="docutils literal notranslate"><span class="pre">Manifold</span></code> parent class by running the following code. Observe the abstract methods denoted with “&#64;abc.abstractmethod” that do not contain any implementation, but serve as template for the subclasses to overwrite. The code of <code class="docutils literal notranslate"><span class="pre">Manifold</span></code> can also be found <a class="reference external" href="https://github.com/geomstats/geomstats/blob/main/geomstats/geometry/manifold.py">here</a>.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span> In [6]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">inspect</span>

<span class="kn">from</span> <span class="nn">geomstats.geometry.manifold</span> <span class="kn">import</span> <span class="n">Manifold</span>

<span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getsourcelines</span><span class="p">(</span><span class="n">Manifold</span><span class="p">)[</span><span class="mi">0</span><span class="p">]:</span>
    <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
class Manifold(abc.ABC):
    r&#34;&#34;&#34;Class for manifolds.

    Parameters
    ----------
    dim : int
        Dimension of the manifold.
    shape : tuple of int
        Shape of one element of the manifold.
        Optional, default : None.
    intrinsic : bool
        Coordinate type.
    equip : bool
        If True, equip space with default metric.

    Attributes
    ----------
    point_ndim : int
        Dimension of point array.
    &#34;&#34;&#34;

    def __init__(
        self,
        dim,
        shape,
        intrinsic=True,
        equip=True,
    ):
        geomstats.errors.check_integer(dim, &#34;dim&#34;)

        if not isinstance(shape, tuple):
            raise ValueError(&#34;Expected a tuple for the shape argument.&#34;)

        self.dim = dim
        self.shape = shape
        self.intrinsic = intrinsic

        self.point_ndim = len(self.shape)

        if equip:
            self.equip_with_metric()

    def equip_with_metric(self, Metric=None, **metric_kwargs):
        &#34;&#34;&#34;Equip manifold with a Riemannian metric.

        Parameters
        ----------
        Metric : RiemannianMetric object
            If None, default metric will be used.
        &#34;&#34;&#34;
        if Metric is None:
            out = self.default_metric()
            if isinstance(out, tuple):
                Metric, kwargs = out
                kwargs.update(metric_kwargs)
                metric_kwargs = kwargs
            else:
                Metric = out

        self.metric = Metric(self, **metric_kwargs)

        return self

    def equip_with_group_action(self, group_action):
        &#34;&#34;&#34;Equip manifold with group action.

        Parameters
        ----------
        group_action : str
            Group action.
        &#34;&#34;&#34;
        self.group_action = group_action

    def _check_equip_with_quotient_structure(self):
        if not hasattr(self, &#34;_quotient_map&#34;):
            raise ValueError(&#34;No quotient structure defined for this manifold.&#34;)

        for structure_name in (&#34;metric&#34;, &#34;group_action&#34;):
            if not hasattr(self, structure_name):
                raise ValueError(f&#34;Need to equip with `{structure_name}` first&#34;)

    def equip_with_quotient_structure(self):
        &#34;&#34;&#34;Equip manifold with quotient structure.

        Creates attributes `quotient` and `fiber_bundle`.
        &#34;&#34;&#34;
        self._check_equip_with_quotient_structure()

        key = type(self.metric), self.group_action

        out = self._quotient_map.get(key, None)
        if out is None:
            raise ValueError(f&#34;No mapping for key: {key}&#34;)
        FiberBundle_, QuotientMetric_ = out

        self.fiber_bundle = FiberBundle_(total_space=self)

        self.quotient = self.new(equip=False)
        self.quotient.equip_with_metric(QuotientMetric_, total_space=self)

    @abc.abstractmethod
    def belongs(self, point, atol=gs.atol):
        &#34;&#34;&#34;Evaluate if a point belongs to the manifold.

        Parameters
        ----------
        point : array-like, shape=[..., *point_shape]
            Point to evaluate.
        atol : float
            Absolute tolerance.
            Optional, default: backend atol.

        Returns
        -------
        belongs : array-like, shape=[...,]
            Boolean evaluating if point belongs to the manifold.
        &#34;&#34;&#34;

    @abc.abstractmethod
    def is_tangent(self, vector, base_point, atol=gs.atol):
        &#34;&#34;&#34;Check whether the vector is tangent at base_point.

        Parameters
        ----------
        vector : array-like, shape=[..., *point_shape]
            Vector.
        base_point : array-like, shape=[..., *point_shape]
            Point on the manifold.
        atol : float
            Absolute tolerance.
            Optional, default: backend atol.

        Returns
        -------
        is_tangent : bool
            Boolean denoting if vector is a tangent vector at the base point.
        &#34;&#34;&#34;

    @abc.abstractmethod
    def to_tangent(self, vector, base_point):
        &#34;&#34;&#34;Project a vector to a tangent space of the manifold.

        Parameters
        ----------
        vector : array-like, shape=[..., *point_shape]
            Vector.
        base_point : array-like, shape=[..., *point_shape]
            Point on the manifold.

        Returns
        -------
        tangent_vec : array-like, shape=[..., *point_shape]
            Tangent vector at base point.
        &#34;&#34;&#34;

    @abc.abstractmethod
    def random_point(self, n_samples=1, bound=1.0):
        &#34;&#34;&#34;Sample random points on the manifold according to some distribution.

        If the manifold is compact, preferably a uniform distribution will be used.

        Parameters
        ----------
        n_samples : int
            Number of samples.
            Optional, default: 1.
        bound : float
            Bound of the interval in which to sample for non compact manifolds.
            Optional, default: 1.

        Returns
        -------
        samples : array-like, shape=[..., *point_shape]
            Points sampled on the manifold.
        &#34;&#34;&#34;

    def regularize(self, point):
        &#34;&#34;&#34;Regularize a point to the canonical representation for the manifold.

        Parameters
        ----------
        point : array-like, shape=[..., dim]
            Point.

        Returns
        -------
        regularized_point : array-like, shape=[..., *point_shape]
            Regularized point.
        &#34;&#34;&#34;
        return gs.copy(point)

    def random_tangent_vec(self, base_point, n_samples=1):
        &#34;&#34;&#34;Generate random tangent vec.

        Parameters
        ----------
        n_samples : int
            Number of samples.
            Optional, default: 1.
        base_point :  array-like, shape={[n_samples, *point_shape], [*point_shape,]}
            Point.

        Returns
        -------
        tangent_vec : array-like, shape=[..., *point_shape]
            Tangent vec at base point.
        &#34;&#34;&#34;
        if (
            n_samples &gt; 1
            and base_point.ndim &gt; len(self.shape)
            and n_samples != len(base_point)
        ):
            raise ValueError(
                &#34;The number of base points must be the same as the &#34;
                &#34;number of samples, when the number of base points is different from 1.&#34;
            )
        batch_size = () if n_samples == 1 else (n_samples,)
        return self.to_tangent(
            gs.random.normal(size=batch_size + self.shape), base_point
        )
</pre></div></div>
</div>
</section>
</section>
<section id="5.2-VectorSpaceOpenSet">
<h2>5.2 <code class="docutils literal notranslate"><span class="pre">VectorSpaceOpenSet</span></code><a class="headerlink" href="#5.2-VectorSpaceOpenSet" title="Link to this heading">#</a></h2>
<p>Earlier in the notebook, we were able to say that a set of points is a manifold if it satisfied one of three constraints. We also said that every manifold can be described by any three of these definitions, and the choice of definition is merely a question of which definition is most convenient. <code class="docutils literal notranslate"><span class="pre">VectorSpaceOpenSet</span></code> provides a way of describing manifolds with local parametrization, which was labeled (1) on our definition list.</p>
<p>One such way to describe a manifold is with the concept of an <span class="math notranslate nohighlight">\(\textbf{Open Set}\)</span>: a manifold is the open sets of a d-dimensional vector space, called <span class="math notranslate nohighlight">\(\textbf{ambient space}\)</span>.</p>
<section id="5.2.1-What-is-an-Open-Set?">
<h3>5.2.1 What is an Open Set?<a class="headerlink" href="#5.2.1-What-is-an-Open-Set?" title="Link to this heading">#</a></h3>
<p>Intuitively, an open set is a group of numbers that does not include points on the boundary of whatever they are describing. For example, if you were to take the set of all points between a and b but <span class="math notranslate nohighlight">\(\textbf{not}\)</span> include the values a and b, this would be an open set (shown in figure a). If you were to take the set of all points between a and b and include the values a and b, this would be a closed set (shown in figure b)</p>
<p><img alt="2d388bd911214168b616829940419fcb" src="../_images/manifold_openSet_lines.png" /></p>
<p>The above examples showed open and closed sets in one dimension. Similarly, in two dimensions, open sets can be defined as sets which do not contain their boundaries. For example, the inside of the sphere, i.e. the ball without its boundary, is a manifold that is an open set. The image below shows an example of an open set (a) and a closed set (b) in two dimensions.</p>
<p><img alt="9866e1fe355640c8a125e06b138dab73" src="../_images/manifold_openSurfaces.png" /></p>
</section>
<section id="5.2.2-What-Methods-are-Implemented-in-VectorSpaceOpenSet?">
<h3>5.2.2 What Methods are Implemented in <code class="docutils literal notranslate"><span class="pre">VectorSpaceOpenSet</span></code>?<a class="headerlink" href="#5.2.2-What-Methods-are-Implemented-in-VectorSpaceOpenSet?" title="Link to this heading">#</a></h3>
<p>If we know that a manifold is conveniently described as an open set, then some of the manifold’s abstract methods can be rewritten in a specific form. For example, <code class="docutils literal notranslate"><span class="pre">VectorSpaceOpenSet</span></code> implements the methods:</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">projection()</span></code>: a method to project any d-dimensional vector to the manifold.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">is_tangent()</span></code>: checks whether the input vector is tangent at the input point.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">to_tangent()</span></code>: projects a vector to a tangent space of the manifold.</p></li>
</ol>
<p>Note that we do not (yet) specify which manifold we are talking about (whether it is a sphere or another surface), we are just saying that we are looking at some manifold that can be described as an open set</p>
<p>Run the code below to see the contents of the <code class="docutils literal notranslate"><span class="pre">VectorSpaceOpenSet</span></code> class.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span> In [7]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">inspect</span>

<span class="kn">from</span> <span class="nn">geomstats.geometry.base</span> <span class="kn">import</span> <span class="n">VectorSpaceOpenSet</span>

<span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getsourcelines</span><span class="p">(</span><span class="n">VectorSpaceOpenSet</span><span class="p">)[</span><span class="mi">0</span><span class="p">]:</span>
    <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
class VectorSpaceOpenSet(OpenSet, abc.ABC):
    &#34;&#34;&#34;Class for manifolds that are open sets of a vector space.

    In this case, tangent vectors are identified with vectors of the embedding
    space.

    Parameters
    ----------
    embedding_space: VectorSpace
        Embedding space that contains the manifold.
    &#34;&#34;&#34;

    def is_tangent(self, vector, base_point=None, atol=gs.atol):
        &#34;&#34;&#34;Check whether the vector is tangent at base_point.

        Parameters
        ----------
        vector : array-like, shape=[..., *point_shape]
            Vector.
        base_point : array-like, shape=[..., *point_shape]
            Point on the manifold.
        atol : float
            Absolute tolerance.
            Optional, default: backend atol.

        Returns
        -------
        is_tangent : bool
            Boolean denoting if vector is a tangent vector at the base point.
        &#34;&#34;&#34;
        is_tangent = self.embedding_space.belongs(vector, atol)
        if base_point is not None and base_point.ndim &gt; vector.ndim:
            return gs.broadcast_to(is_tangent, base_point.shape[: -self.point_ndim])
        return is_tangent

    def to_tangent(self, vector, base_point=None):
        &#34;&#34;&#34;Project a vector to a tangent space of the manifold.

        Parameters
        ----------
        vector : array-like, shape=[..., *point_shape]
            Vector.
        base_point : array-like, shape=[..., *point_shape]
            Point on the manifold.

        Returns
        -------
        tangent_vec : array-like, shape=[..., *point_shape]
            Tangent vector at base point.
        &#34;&#34;&#34;
        tangent_vec = self.embedding_space.projection(vector)
        if base_point is not None and base_point.ndim &gt; vector.ndim:
            return gs.broadcast_to(tangent_vec, base_point.shape)
        return tangent_vec

    @abc.abstractmethod
    def projection(self, point):
        &#34;&#34;&#34;Project a point in embedding manifold on manifold.

        Parameters
        ----------
        point : array-like, shape=[..., *point_shape]
            Point in embedding manifold.

        Returns
        -------
        projected : array-like, shape=[..., *point_shape]
            Projected point.
        &#34;&#34;&#34;
</pre></div></div>
</div>
</section>
</section>
<section id="5.3-LevelSet">
<h2>5.3 <code class="docutils literal notranslate"><span class="pre">LevelSet</span></code><a class="headerlink" href="#5.3-LevelSet" title="Link to this heading">#</a></h2>
<section id="5.3.1-What-is-a-Level-Set?">
<h3>5.3.1 What is a Level Set?<a class="headerlink" href="#5.3.1-What-is-a-Level-Set?" title="Link to this heading">#</a></h3>
<p>Another elementary class of manifolds are <span class="math notranslate nohighlight">\(\textbf{Level Sets}\)</span>. A level set is the set of values <span class="math notranslate nohighlight">\(x\)</span> for which a function f(x) is equal to a given constant. In other words, a level set is a set of curves for which the function describing a manifold is constant along that curve.</p>
<p>In the same way that <code class="docutils literal notranslate"><span class="pre">VectorSpaceOpenSet</span></code> is an implementation of the first definition of a manifold (Local Parametrization), <code class="docutils literal notranslate"><span class="pre">LevelSet</span></code> is an implementation of the second definition of a manifold (Local Implicit Function). a level set is a set of points for which the function <span class="math notranslate nohighlight">\(f\)</span> takes the exact same value. This value is called the “level”, and does not need to be a scalar, it could also be a vector.</p>
<p>For example, consider a hypersphere in three dimensional space. Each of the concentric spheres is a 2-dimensional manifold, each corresponding to a different level <span class="math notranslate nohighlight">\((r1, r2,r3)\)</span>.</p>
<p><img alt="9feb85be0fa34984a939b40ac3004c91" src="../_images/manifold_LevelSet.png" /></p>
<p>You can see <a class="reference external" href="https://github.com/geomstats/geomstats/blob/20cccf598e94823ef8d7c0821b2968e6d29660c0/geomstats/geometry/hypersphere.py#L22">here</a> that the subclass <code class="docutils literal notranslate"><span class="pre">Hypersphere</span></code> is indeed implemented as a <code class="docutils literal notranslate"><span class="pre">LevelSet</span></code>.</p>
</section>
<section id="5.3.2-LevelSet-in-Geomstats">
<h3>5.3.2 <code class="docutils literal notranslate"><span class="pre">LevelSet</span></code> in Geomstats<a class="headerlink" href="#5.3.2-LevelSet-in-Geomstats" title="Link to this heading">#</a></h3>
<p>You can run the code below to see the contents of the <code class="docutils literal notranslate"><span class="pre">LevelSet</span></code> class. The methods of LevelSet are similar to the methods of VectorSpaceOpenSet , but their implementation is different. Recall from the (Local Implicit Function) definition, which <code class="docutils literal notranslate"><span class="pre">LevelSet</span></code> is an implementation of, that a manifold of this type must satisfy:</p>
<p>“For every <span class="math notranslate nohighlight">\(p \in M\)</span>, there exists an open set <span class="math notranslate nohighlight">\(U \in \mathbb{R}^{N}\)</span> and a smooth map <span class="math notranslate nohighlight">\(f: U \to \mathbb{R}^{N-d}\)</span> that is a submersion at p, such that <span class="math notranslate nohighlight">\(U \cap M = f^{-1}\)</span>({0}).”</p>
<p><code class="docutils literal notranslate"><span class="pre">VectorSpaceOpenSet</span></code> is an implementation of the first manifold definition (Local Parametrization), and therefore need not follow the (Local Implicit Function) rule above. This is the reason that, <code class="docutils literal notranslate"><span class="pre">VectorSpaceOpenSet</span></code> methods and <code class="docutils literal notranslate"><span class="pre">LevelSet</span></code> methods are implemented differently. As an example of these different implementations: observe the implementation of the belongs methods in <code class="docutils literal notranslate"><span class="pre">LevelSet</span></code>. For a general level set, in order to verify if a point belongs to the level set, we should verify
that the (Local Implicit Function) definition constraint is met, which is done with the line</p>
<p><code class="docutils literal notranslate"><span class="pre">constraint</span> <span class="pre">=</span> <span class="pre">gs.isclose(self.submersion(point),</span> <span class="pre">value,</span> <span class="pre">atol=atol)</span></code></p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span> In [8]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">inspect</span>

<span class="kn">from</span> <span class="nn">geomstats.geometry.base</span> <span class="kn">import</span> <span class="n">LevelSet</span>

<span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getsourcelines</span><span class="p">(</span><span class="n">LevelSet</span><span class="p">)[</span><span class="mi">0</span><span class="p">]:</span>
    <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
class LevelSet(Manifold, abc.ABC):
    &#34;&#34;&#34;Class for manifolds embedded in a vector space by a submersion.

    Parameters
    ----------
    intrinsic : bool
        Coordinates type.
    &#34;&#34;&#34;

    def __init__(self, intrinsic=False, shape=None, **kwargs):
        self.embedding_space = self._define_embedding_space()

        if shape is None:
            shape = self.embedding_space.shape

        super().__init__(intrinsic=intrinsic, shape=shape, **kwargs)

    @abc.abstractmethod
    def _define_embedding_space(self):
        &#34;&#34;&#34;Define embedding space of the manifold.

        Returns
        -------
        embedding_space : Manifold
            Instance of Manifold.
        &#34;&#34;&#34;

    @abc.abstractmethod
    def submersion(self, point):
        r&#34;&#34;&#34;Submersion that defines the manifold.

        :math:`\mathrm{submersion}(x)=0` defines the manifold.

        Parameters
        ----------
        point : array-like, shape=[..., *point_shape]

        Returns
        -------
        submersed_point : array-like
        &#34;&#34;&#34;

    @abc.abstractmethod
    def tangent_submersion(self, vector, point):
        &#34;&#34;&#34;Tangent submersion.

        Parameters
        ----------
        vector : array-like, shape=[..., *point_shape]
        point : array-like, shape=[..., *point_shape]

        Returns
        -------
        submersed_vector : array-like
        &#34;&#34;&#34;

    def belongs(self, point, atol=gs.atol):
        &#34;&#34;&#34;Evaluate if a point belongs to the manifold.

        Parameters
        ----------
        point : array-like, shape=[..., *point_shape]
            Point to evaluate.
        atol : float
            Absolute tolerance.
            Optional, default: backend atol.

        Returns
        -------
        belongs : array-like, shape=[...,]
            Boolean evaluating if point belongs to the manifold.
        &#34;&#34;&#34;
        belongs = self.embedding_space.belongs(point, atol)
        if not gs.any(belongs):
            return belongs

        submersed_point = self.submersion(point)

        n_batch = gs.ndim(point) - len(self.shape)
        axis = tuple(range(-len(submersed_point.shape) + n_batch, 0))

        if gs.is_complex(submersed_point):
            constraint = gs.isclose(submersed_point, 0.0 + 0.0j, atol=atol)
        else:
            constraint = gs.isclose(submersed_point, 0.0, atol=atol)

        if axis:
            constraint = gs.all(constraint, axis=axis)

        return gs.logical_and(belongs, constraint)

    def is_tangent(self, vector, base_point, atol=gs.atol):
        &#34;&#34;&#34;Check whether the vector is tangent at base_point.

        Parameters
        ----------
        vector : array-like, shape=[..., *point_shape]
            Vector.
        base_point : array-like, shape=[..., *point_shape]
            Point on the manifold.
        atol : float
            Absolute tolerance.
            Optional, default: backend atol.

        Returns
        -------
        is_tangent : bool
            Boolean denoting if vector is a tangent vector at the base point.
        &#34;&#34;&#34;
        belongs = self.embedding_space.is_tangent(vector, base_point, atol)
        if not gs.any(belongs):
            return belongs

        submersed_vector = self.tangent_submersion(vector, base_point)

        n_batch = max(gs.ndim(base_point), gs.ndim(vector)) - len(self.shape)
        axis = tuple(range(-len(submersed_vector.shape) + n_batch, 0))

        constraint = gs.isclose(submersed_vector, 0.0, atol=atol)
        if axis:
            constraint = gs.all(constraint, axis=axis)

        return gs.logical_and(belongs, constraint)

    def intrinsic_to_extrinsic_coords(self, point_intrinsic):
        &#34;&#34;&#34;Convert from intrinsic to extrinsic coordinates.

        Parameters
        ----------
        point_intrinsic : array-like, shape=[..., *point_shape]
            Point in the embedded manifold in intrinsic coordinates.

        Returns
        -------
        point_extrinsic : array-like, shape=[..., *embedding_space.point_shape]
            Point in the embedded manifold in extrinsic coordinates.
        &#34;&#34;&#34;
        raise NotImplementedError(&#34;intrinsic_to_extrinsic_coords is not implemented.&#34;)

    def extrinsic_to_intrinsic_coords(self, point_extrinsic):
        &#34;&#34;&#34;Convert from extrinsic to intrinsic coordinates.

        Parameters
        ----------
        point_extrinsic : array-like, shape=[..., *embedding_space.point_shape]
            Point in the embedded manifold in extrinsic coordinates,
            i. e. in the coordinates of the embedding manifold.

        Returns
        -------
        point_intrinsic : array-lie, shape=[..., *point_shape]
            Point in the embedded manifold in intrinsic coordinates.
        &#34;&#34;&#34;
        raise NotImplementedError(&#34;extrinsic_to_intrinsic_coords is not implemented.&#34;)

    @abc.abstractmethod
    def projection(self, point):
        &#34;&#34;&#34;Project a point in embedding manifold on embedded manifold.

        Parameters
        ----------
        point : array-like, shape=[..., *embedding_space.point_shape]
            Point in embedding manifold.

        Returns
        -------
        projected : array-like, shape=[..., *point_shape]
            Projected point.
        &#34;&#34;&#34;

    @abc.abstractmethod
    def to_tangent(self, vector, base_point):
        &#34;&#34;&#34;Project a vector to a tangent space of the manifold.

        Parameters
        ----------
        vector : array-like, shape=[..., *point_shape]
            Vector.
        base_point : array-like, shape=[..., *point_shape]
            Point on the manifold.

        Returns
        -------
        tangent_vec : array-like, shape=[..., *point_shape]
            Tangent vector at base point.
        &#34;&#34;&#34;
</pre></div></div>
</div>
</section>
</section>
<section id="5.4-VectorSpace">
<h2>5.4 <code class="docutils literal notranslate"><span class="pre">VectorSpace</span></code><a class="headerlink" href="#5.4-VectorSpace" title="Link to this heading">#</a></h2>
<p>A <span class="math notranslate nohighlight">\(\textit{vector space}\)</span> is a special case of manifold where a vector exists at each point.</p>
<p>Many operations defined on manifolds become simpler when the manifold is actually a vector space. Additionally, the ambient spaces used to define manifolds as open or closed sets are often vector spaces. Thus, we provide an implementation <code class="docutils literal notranslate"><span class="pre">VectorSpace</span></code>.</p>
<p>This class does not provide another way of describing a manifold. This class is an abstract class that makes sure that the ambient/embedding vector space is compatible with the methods that are called in <code class="docutils literal notranslate"><span class="pre">VectorSpaceOpenSet</span></code> and <code class="docutils literal notranslate"><span class="pre">LevelSet</span></code>.</p>
<p>Actual manifolds are implemented as subclasses of this abstract method and must implement all the abstract methods defined in this class.</p>
<p>You can run the code below to see the contents of the <code class="docutils literal notranslate"><span class="pre">VectorSpace</span></code> class. Observe that, in a <code class="docutils literal notranslate"><span class="pre">VectorSpace</span></code> manifold, the manifold is comprised of vectors – and more specifically, tangent vectors. Thus, in the implementation, we can see that in the <code class="docutils literal notranslate"><span class="pre">is_tangent()</span></code> method: in order to check that a vector is a tangent to the manifold, we only need to check that the vector belongs to the vector space.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span> In [9]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">inspect</span>

<span class="kn">from</span> <span class="nn">geomstats.geometry.base</span> <span class="kn">import</span> <span class="n">VectorSpace</span>

<span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getsourcelines</span><span class="p">(</span><span class="n">VectorSpace</span><span class="p">)[</span><span class="mi">0</span><span class="p">]:</span>
    <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
class VectorSpace(Manifold, abc.ABC):
    &#34;&#34;&#34;Abstract class for vector spaces.

    Parameters
    ----------
    shape : tuple
        Shape of the elements of the vector space. The dimension is the
        product of these values by default.
    &#34;&#34;&#34;

    def __init__(self, shape, dim=None, **kwargs):
        if dim is None:
            dim = math.prod(shape)
        super().__init__(dim=dim, shape=shape, **kwargs)
        self._basis = None

    def belongs(self, point, atol=gs.atol):
        &#34;&#34;&#34;Evaluate if the point belongs to the vector space.

        This method checks the shape of the input point.

        Parameters
        ----------
        point : array-like, shape=[.., *point_shape]
            Point to test.
        atol : float
            Unused here.

        Returns
        -------
        belongs : array-like, shape=[...,]
            Boolean evaluating if point belongs to the space.
        &#34;&#34;&#34;
        belongs = self.shape == point.shape[-self.point_ndim :]
        shape = point.shape[: -self.point_ndim]
        if belongs:
            return gs.ones(shape, dtype=bool)
        return gs.zeros(shape, dtype=bool)

    @staticmethod
    def projection(point):
        &#34;&#34;&#34;Project a point to the vector space.

        This method is for compatibility and returns `point`. `point` should
        have the right shape,

        Parameters
        ----------
        point: array-like, shape[..., *point_shape]
            Point.

        Returns
        -------
        point: array-like, shape[..., *point_shape]
            Point.
        &#34;&#34;&#34;
        return gs.copy(point)

    def is_tangent(self, vector, base_point=None, atol=gs.atol):
        &#34;&#34;&#34;Check whether the vector is tangent at base_point.

        Tangent vectors are identified with points of the vector space so
        this checks the shape of the input vector.

        Parameters
        ----------
        vector : array-like, shape=[..., *point_shape]
            Vector.
        base_point : array-like, shape=[..., *point_shape]
            Point in the vector space.
        atol : float
            Absolute tolerance.
            Optional, default: backend atol.

        Returns
        -------
        is_tangent : array-like, shape=[...,]
            Boolean denoting if vector is a tangent vector at the base point.
        &#34;&#34;&#34;
        belongs = self.belongs(vector, atol)
        if base_point is not None and base_point.ndim &gt; vector.ndim:
            return gs.broadcast_to(belongs, base_point.shape[: -self.point_ndim])
        return belongs

    def to_tangent(self, vector, base_point=None):
        &#34;&#34;&#34;Project a vector to a tangent space of the vector space.

        This method is for compatibility and returns vector.

        Parameters
        ----------
        vector : array-like, shape=[..., *point_shape]
            Vector.
        base_point : array-like, shape=[..., *point_shape]
            Point in the vector space

        Returns
        -------
        tangent_vec : array-like, shape=[..., *point_shape]
            Tangent vector at base point.
        &#34;&#34;&#34;
        tangent_vec = self.projection(vector)
        if base_point is not None and base_point.ndim &gt; vector.ndim:
            return gs.broadcast_to(tangent_vec, base_point.shape)
        return tangent_vec

    def random_point(self, n_samples=1, bound=1.0):
        &#34;&#34;&#34;Sample in the vector space with a uniform distribution in a box.

        Parameters
        ----------
        n_samples : int
            Number of samples.
            Optional, default: 1.
        bound : float
            Side of hypercube support of the uniform distribution.
            Optional, default: 1.0

        Returns
        -------
        point : array-like, shape=[..., dim]
           Sample.
        &#34;&#34;&#34;
        size = (self.dim,)
        if n_samples != 1:
            size = (n_samples,) + size
        return bound * (gs.random.rand(*size) - 0.5) * 2

    @property
    def basis(self):
        &#34;&#34;&#34;Basis of the vector space.&#34;&#34;&#34;
        if self._basis is None:
            self._basis = self._create_basis()
        return self._basis

    @abc.abstractmethod
    def _create_basis(self):
        &#34;&#34;&#34;Create a canonical basis.&#34;&#34;&#34;
</pre></div></div>
</div>
</section>
<section id="5.5-ProductManifold">
<h2>5.5 <code class="docutils literal notranslate"><span class="pre">ProductManifold</span></code><a class="headerlink" href="#5.5-ProductManifold" title="Link to this heading">#</a></h2>
<p>New manifolds can also be created by composing existing manifolds. A product manifold combines two manifolds <span class="math notranslate nohighlight">\(M_1\)</span> and <span class="math notranslate nohighlight">\(M_2\)</span> to create a new manifold <span class="math notranslate nohighlight">\(M_3\)</span>, and more generally <span class="math notranslate nohighlight">\(N\)</span> manifolds <span class="math notranslate nohighlight">\(M1, ..., M_N\)</span> can be combined to create a new manifold <span class="math notranslate nohighlight">\(M\)</span>.</p>
<section id="5.5.1-Example">
<h3>5.5.1 Example<a class="headerlink" href="#5.5.1-Example" title="Link to this heading">#</a></h3>
<p>For example, we can create a product of two spheres as:</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span> In [10]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">geomstats.geometry.product_manifold</span> <span class="kn">import</span> <span class="n">ProductManifold</span>

<span class="n">sphere1</span> <span class="o">=</span> <span class="n">Hypersphere</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="n">sphere2</span> <span class="o">=</span> <span class="n">Hypersphere</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>


<span class="n">product_of_two_spheres</span> <span class="o">=</span> <span class="n">ProductManifold</span><span class="p">([</span><span class="n">sphere1</span><span class="p">,</span> <span class="n">sphere2</span><span class="p">])</span>
</pre></div>
</div>
</div>
<p>If we generate a random point on this product manifold, we will get 6 coordinates: the first 3 represent a point on the first sphere, and the last 3 represent a point on the second sphere:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span> In [11]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">product_of_two_spheres</span><span class="o">.</span><span class="n">random_point</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span> Out [11]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
array([[-0.3861891 , -0.52946814, -0.75532871],
       [-0.14573203,  0.15373756,  0.97730596]])
</pre></div></div>
</div>
<p>You can run the code below to see the contents of the <code class="docutils literal notranslate"><span class="pre">ProductManifold</span></code> class.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span> In [12]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">inspect</span>

<span class="kn">from</span> <span class="nn">geomstats.geometry.product_manifold</span> <span class="kn">import</span> <span class="n">ProductManifold</span>

<span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getsourcelines</span><span class="p">(</span><span class="n">ProductManifold</span><span class="p">)[</span><span class="mi">0</span><span class="p">]:</span>
    <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
class ProductManifold(_IterateOverFactorsMixins, Manifold):
    &#34;&#34;&#34;Class for a product of manifolds M_1 x ... x M_n.

    In contrast to the classes NFoldManifold, Landmarks, or DiscretizedCurves,
    the manifolds M_1, ..., M_n need not be the same, nor of
    same dimension, but the list of manifolds needs to be provided.

    Parameters
    ----------
    factors : tuple
        Collection of manifolds in the product.
    point_ndim : int or None
        If None, defaults to 1, unless all factors have the same shape.
    &#34;&#34;&#34;

    def __init__(self, factors, point_ndim=None, equip=True):
        factors = tuple(factors)

        factor_dims = [factor.dim for factor in factors]

        dim = sum(factor_dims)

        shape = _find_product_shape(factors, point_ndim)

        intrinsic = all(factor.intrinsic for factor in factors)

        if not intrinsic:
            factor_embedding_spaces = [
                (
                    manifold.embedding_space
                    if hasattr(manifold, &#34;embedding_space&#34;)
                    else manifold
                )
                for manifold in factors
            ]
            # TODO: need to revisit due to removal of scales
            self.embedding_space = ProductManifold(
                factor_embedding_spaces, point_ndim, equip=False
            )

        cum_index = (
            gs.cumsum(factor_dims)[:-1]
            if intrinsic
            else self.embedding_space._cum_index
        )

        super().__init__(
            factors=factors,
            cum_index=cum_index,
            pool_outputs=True,
            has_mixed_fields=_has_mixed_fields(factors),
            dim=dim,
            shape=shape,
            intrinsic=intrinsic,
            equip=equip,
        )

    @staticmethod
    def default_metric():
        &#34;&#34;&#34;Metric to equip the space with if equip is True.&#34;&#34;&#34;
        return ProductRiemannianMetric

    def _pool_outputs_from_function(self, outputs):
        &#34;&#34;&#34;Collect outputs for each product to be returned.

        If each element of the output is a boolean array of the same shape, test along
        the list whether all elements are True and return a boolean array of the same
        shape.

        Otherwise, if each element of the output has a shape compatible with points of
        the corresponding factor, an attempt is made to map the list of points to a
        point in the product by embed_to_product.

        Parameters
        ----------
        outputs : list
            A list of outputs which must be pooled

        Returns
        -------
        pooled_output : array-like, shape {(...,), (..., self.shape)}
        &#34;&#34;&#34;
        # TODO: simplify after cleaning gs.squeeze
        all_arrays = gs.all([gs.is_array(factor_output) for factor_output in outputs])
        if (
            all_arrays
            and _all_equal([factor_output.shape for factor_output in outputs])
            and gs.all([gs.is_bool(factor_output) for factor_output in outputs])
            or (not all_arrays)
        ):
            outputs = gs.stack([gs.array(factor_output) for factor_output in outputs])
            outputs = gs.all(outputs, axis=0)
            return outputs

        try:
            return self.embed_to_product(outputs)
        except geomstats.errors.ShapeError:
            raise RuntimeError(
                &#34;Could not combine outputs - they are not points of the individual&#34;
                &#34; factors.&#34;
            )
        except ValueError:
            raise RuntimeError(
                &#34;Could not combine outputs, probably because they could&#34;
                &#34; not be concatenated or stacked.&#34;
            )

    def belongs(self, point, atol=gs.atol):
        &#34;&#34;&#34;Test if a point belongs to the manifold.

        Parameters
        ----------
        point : array-like, shape=[..., {dim, embedding_space.dim, \
            [n_manifolds, dim_each]}]
            Point.
        atol : float,
            Tolerance.

        Returns
        -------
        belongs : array-like, shape=[...,]
            Boolean evaluating if the point belongs to the manifold.
        &#34;&#34;&#34;
        belongs = self._iterate_over_factors(&#34;belongs&#34;, {&#34;point&#34;: point, &#34;atol&#34;: atol})
        return belongs

    def regularize(self, point):
        &#34;&#34;&#34;Regularize the point into the manifold&#39;s canonical representation.

        Parameters
        ----------
        point : array-like, shape=[..., {dim, embedding_space.dim, \
            [n_manifolds, dim_each]}]
            Point to be regularized.

        Returns
        -------
        regularized_point : array-like, shape=[..., {dim, embedding_space.dim, \
            [n_manifolds, dim_each]}]
            Point in the manifold&#39;s canonical representation.
        &#34;&#34;&#34;
        regularized_point = self._iterate_over_factors(&#34;regularize&#34;, {&#34;point&#34;: point})
        return regularized_point

    def random_point(self, n_samples=1, bound=1.0):
        &#34;&#34;&#34;Sample in the product space from the product distribution.

        The distribution used is the product of the distributions used by the
        random_point methods of each individual factor manifold.

        Parameters
        ----------
        n_samples : int, optional
            Number of samples.
        bound : float
            Bound of the interval in which to sample for non compact manifolds.
            Optional, default: 1.

        Returns
        -------
        samples : array-like, shape=[..., {dim, embedding_space.dim, \
            [n_manifolds, dim_each]}]
            Points sampled from the manifold.
        &#34;&#34;&#34;
        samples = self._iterate_over_factors(
            &#34;random_point&#34;, {&#34;n_samples&#34;: n_samples, &#34;bound&#34;: bound}
        )
        return samples

    def random_tangent_vec(self, base_point, n_samples=1):
        &#34;&#34;&#34;Sample on the tangent space from the product distribution.

        The distribution used is the product of the distributions used by the
        random_tangent_vec methods of each individual factor manifold.

        Parameters
        ----------
        base_point : array-like, shape=[..., n, n]
            Base point of the tangent space.
            Optional, default: None.
        n_samples : int
            Number of samples.
            Optional, default: 1.

        Returns
        -------
        samples : array-like, shape=[..., {dim, embedding_space.dim, \
            [n_manifolds, dim_each]}]
            Points sampled in the tangent space of the product manifold at base_point.
        &#34;&#34;&#34;
        samples = self._iterate_over_factors(
            &#34;random_tangent_vec&#34;, {&#34;base_point&#34;: base_point, &#34;n_samples&#34;: n_samples}
        )
        return samples

    def projection(self, point):
        &#34;&#34;&#34;Project a point onto product manifold.

        Parameters
        ----------
        point : array-like, shape=[..., {dim, embedding_space.dim, \
            [n_manifolds, dim_each]}]
            Point in product manifold.

        Returns
        -------
        projected : array-like, shape=[..., {dim, embedding_space.dim, \
            [n_manifolds, dim_each]}]
            Projected point.
        &#34;&#34;&#34;
        projected_point = self._iterate_over_factors(&#34;projection&#34;, {&#34;point&#34;: point})
        return projected_point

    def to_tangent(self, vector, base_point):
        &#34;&#34;&#34;Project a vector to a tangent space of the manifold.

        Parameters
        ----------
        vector : array-like, shape=[..., dim]
            Vector.
        base_point : array-like, shape=[..., dim]
            Point on the manifold.

        Returns
        -------
        tangent_vec : array-like, shape=[..., dim]
            Tangent vector at base point.

        Notes
        -----
        The tangent space of the product manifold is the direct sum of
        tangent spaces.
        &#34;&#34;&#34;
        tangent_vec = self._iterate_over_factors(
            &#34;to_tangent&#34;, {&#34;base_point&#34;: base_point, &#34;vector&#34;: vector}
        )
        return tangent_vec

    def is_tangent(self, vector, base_point=None, atol=gs.atol):
        &#34;&#34;&#34;Check whether the vector is tangent at base_point.

        The tangent space of the product manifold is the direct sum of
        tangent spaces.

        Parameters
        ----------
        vector : array-like, shape=[..., dim]
            Vector.
        base_point : array-like, shape=[..., dim]
            Point on the manifold.
            Optional, default: None
        atol : float
            Absolute tolerance.
            Optional, default: backend atol.

        Returns
        -------
        is_tangent : bool
            Boolean denoting if vector is a tangent vector at the base point.
        &#34;&#34;&#34;
        is_tangent = self._iterate_over_factors(
            &#34;is_tangent&#34;, {&#34;base_point&#34;: base_point, &#34;vector&#34;: vector, &#34;atol&#34;: atol}
        )
        return is_tangent
</pre></div></div>
</div>
</section>
</section>
</section>
<section id="Conclusion">
<h1>Conclusion<a class="headerlink" href="#Conclusion" title="Link to this heading">#</a></h1>
<p>Key takeaways from this notebook:</p>
<ol class="arabic simple">
<li><p>There are three ways to define a manifold, and each of these three definitions provide a different option for manifold implementation.</p></li>
<li><p>Learning to work with manifolds is useful because many datasets naturally lie on manifolds.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">Manifold</span></code> class stores information about many types of manifolds. Each of the subclasses implements a different <span class="math notranslate nohighlight">\(\textit{type}\)</span> of manifold (for example, <code class="docutils literal notranslate"><span class="pre">LevelSet</span></code>), and specific manifolds (for example, <code class="docutils literal notranslate"><span class="pre">Hypersphere</span></code>) are implemented within these subclasses.</p></li>
</ol>
</section>


                </article>
              
              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="00_foundations__introduction_to_geomstats.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">What is the motivation for analyzing data on manifolds?</p>
      </div>
    </a>
    <a class="right-next"
       href="02_foundations__connection_riemannian_metric.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">1. What is a Connection?</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
<div
    id="pst-page-navigation-heading-2"
    class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> On this page
  </div>
  <nav class="bd-toc-nav page-toc" aria-labelledby="pst-page-navigation-heading-2">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#">1. Introduction</a></li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#2.-What-is-a-Manifold?">2. What is a Manifold?</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#2.1-Precise-Mathematical-Definition">2.1 Precise Mathematical Definition</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#2.2-Imprecise-%22Layman's-Terms%22-Definition:">2.2 Imprecise “Layman’s Terms” Definition:</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#2.3-Hypersphere-example:">2.3 Hypersphere example:</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#2.4-More-examples-of-manifolds:">2.4 More examples of manifolds:</a></li>
</ul>
</li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#3.-Why-do-we-care-about-manifolds?">3. Why do we care about manifolds?</a></li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#4.-What-does-the-Manifold-class-do?">4. What does the <code class="docutils literal notranslate"><span class="pre">Manifold</span></code> class do?</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#4.1-Tangent-Vectors">4.1 Tangent Vectors</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#4.2-Tangent-Spaces">4.2 Tangent Spaces</a></li>
</ul>
</li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#5.-How-is-the-Manifold-class-structured?">5. How is the <code class="docutils literal notranslate"><span class="pre">Manifold</span></code> class structured?</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#5.1-The-Parent-Class:-Manifold">5.1 The Parent Class: <code class="docutils literal notranslate"><span class="pre">Manifold</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#5.1.1-Examples-of-Using-Manifold's-Attributes-and-Methods-in-the-Subclass:-Hypersphere">5.1.1 Examples of Using <code class="docutils literal notranslate"><span class="pre">Manifold</span></code>’s Attributes and Methods in the Subclass: <code class="docutils literal notranslate"><span class="pre">Hypersphere</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#5.1.2-The-Full-Manifold-Class-Code">5.1.2 The Full <code class="docutils literal notranslate"><span class="pre">Manifold</span></code> Class Code</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#5.2-VectorSpaceOpenSet">5.2 <code class="docutils literal notranslate"><span class="pre">VectorSpaceOpenSet</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#5.2.1-What-is-an-Open-Set?">5.2.1 What is an Open Set?</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#5.2.2-What-Methods-are-Implemented-in-VectorSpaceOpenSet?">5.2.2 What Methods are Implemented in <code class="docutils literal notranslate"><span class="pre">VectorSpaceOpenSet</span></code>?</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#5.3-LevelSet">5.3 <code class="docutils literal notranslate"><span class="pre">LevelSet</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#5.3.1-What-is-a-Level-Set?">5.3.1 What is a Level Set?</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#5.3.2-LevelSet-in-Geomstats">5.3.2 <code class="docutils literal notranslate"><span class="pre">LevelSet</span></code> in Geomstats</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#5.4-VectorSpace">5.4 <code class="docutils literal notranslate"><span class="pre">VectorSpace</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#5.5-ProductManifold">5.5 <code class="docutils literal notranslate"><span class="pre">ProductManifold</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#5.5.1-Example">5.5.1 Example</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#Conclusion">Conclusion</a></li>
</ul>

  </nav></div>

  <div class="sidebar-secondary-item">

  <div class="tocsection sourcelink">
    <a href="../_sources/notebooks/01_foundations__manifolds.ipynb.txt">
      <i class="fa-solid fa-file-lines"></i> Show Source
    </a>
  </div>
</div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=3ee479438cf8b5e0d341"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=3ee479438cf8b5e0d341"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">

  <p class="copyright">
    
      © Copyright 2022-2023, Geomstats, Inc..
      <br/>
    
  </p>
</div>
      
        <div class="footer-item">

  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.3.7.
    <br/>
  </p>
</div>
      
    </div>
  
  
  
    <div class="footer-items__end">
      
        <div class="footer-item">
<p class="theme-version">
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.15.3.
</p></div>
      
    </div>
  
</div>

  </footer>
  </body>
</html>
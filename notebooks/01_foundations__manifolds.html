<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>1. Introduction &mdash; Geomstats latest documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/sg_gallery.css" type="text/css" />
    <link rel="canonical" href="geomstats.github.io/notebooks/01_foundations__manifolds.html" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
        <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Tutorial: Data on Manifolds" href="03_practical_methods__data_on_manifolds.html" />
    <link rel="prev" title="What is the motivation for analyzing data on manifolds?" href="00_foundations__introduction_to_geomstats.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> Geomstats
          </a>
              <div class="version">
                latest
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Getting started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../first-steps.html">First steps</a></li>
<li class="toctree-l1"><a class="reference internal" href="../examples.html">Code Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api-reference.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gsod.html">Google Season of Docs: Project Page</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Tutorials</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="00_foundations__introduction_to_geomstats.html">What is the motivation for analyzing data on manifolds?</a></li>
<li class="toctree-l1"><a class="reference internal" href="00_foundations__introduction_to_geomstats.html#What-will-you-learn-in-these-tutorials?">What will you learn in these tutorials?</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="#2.-What-is-a-Manifold?">2. What is a Manifold?</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#2.1-Precise-Mathematical-Definition">2.1 Precise Mathematical Definition</a></li>
<li class="toctree-l2"><a class="reference internal" href="#2.2-Imprecise-&quot;Layman's-Terms&quot;-Definition:">2.2 Imprecise “Layman’s Terms” Definition:</a></li>
<li class="toctree-l2"><a class="reference internal" href="#2.3-Hypersphere-example:">2.3 Hypersphere example:</a></li>
<li class="toctree-l2"><a class="reference internal" href="#2.4-More-examples-of-manifolds:">2.4 More examples of manifolds:</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#3.-Why-do-we-care-about-manifolds?">3. Why do we care about manifolds?</a></li>
<li class="toctree-l1"><a class="reference internal" href="#4.-What-does-the-Manifold-class-do?">4. What does the <code class="docutils literal notranslate"><span class="pre">Manifold</span></code> class do?</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#4.1-Tangent-Vectors">4.1 Tangent Vectors</a></li>
<li class="toctree-l2"><a class="reference internal" href="#4.2-Tangent-Spaces">4.2 Tangent Spaces</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#5.-How-is-the-Manifold-class-structured?">5. How is the <code class="docutils literal notranslate"><span class="pre">Manifold</span></code> class structured?</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#5.1-The-Parent-Class:-Manifold">5.1 The Parent Class: <code class="docutils literal notranslate"><span class="pre">Manifold</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#5.1.1-Examples-of-Using-Manifold's-Attributes-and-Methods-in-the-Subclass:-Hypersphere">5.1.1 Examples of Using <code class="docutils literal notranslate"><span class="pre">Manifold</span></code>’s Attributes and Methods in the Subclass: <code class="docutils literal notranslate"><span class="pre">Hypersphere</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#5.1.2-The-Full-Manifold-Class-Code">5.1.2 The Full <code class="docutils literal notranslate"><span class="pre">Manifold</span></code> Class Code</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#5.2-OpenSet">5.2 <code class="docutils literal notranslate"><span class="pre">OpenSet</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#5.2.1-What-is-an-Open-Set?">5.2.1 What is an Open Set?</a></li>
<li class="toctree-l3"><a class="reference internal" href="#5.2.2-What-Methods-are-Implemented-in-OpenSet?">5.2.2 What Methods are Implemented in <code class="docutils literal notranslate"><span class="pre">OpenSet</span></code>?</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#5.3-LevelSet">5.3 <code class="docutils literal notranslate"><span class="pre">LevelSet</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#5.3.1-What-is-a-Level-Set?">5.3.1 What is a Level Set?</a></li>
<li class="toctree-l3"><a class="reference internal" href="#5.3.2-LevelSet-in-Geomstats">5.3.2 <code class="docutils literal notranslate"><span class="pre">LevelSet</span></code> in Geomstats</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#4.4-VectorSpace">4.4 <code class="docutils literal notranslate"><span class="pre">VectorSpace</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#4.5-ProductManifold">4.5 <code class="docutils literal notranslate"><span class="pre">ProductManifold</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#5.5.1-Example">5.5.1 Example</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#Conclusion">Conclusion</a></li>
<li class="toctree-l1"><a class="reference internal" href="03_practical_methods__data_on_manifolds.html">Tutorial: Data on Manifolds</a></li>
<li class="toctree-l1"><a class="reference internal" href="04_practical_methods__from_vector_spaces_to_manifolds.html">Tutorial: From vector spaces to manifolds</a></li>
<li class="toctree-l1"><a class="reference internal" href="05_practical_methods__simple_machine_learning_on_tangent_spaces.html">Tutorial: Learning on Tangent Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="06_practical_methods__riemannian_frechet_mean_and_tangent_pca.html">Tutorial: Fréchet Mean and Tangent PCA</a></li>
<li class="toctree-l1"><a class="reference internal" href="07_practical_methods__riemannian_kmeans.html">Tutorial: K-Means clustering on a Riemannian Manifold</a></li>
<li class="toctree-l1"><a class="reference internal" href="08_practical_methods__information_geometry.html">Tutorial: Information geometry</a></li>
<li class="toctree-l1"><a class="reference internal" href="09_practical_methods__implement_your_own_riemannian_geometry.html">Tutorial: Implement your own Riemannian Geometry</a></li>
<li class="toctree-l1"><a class="reference internal" href="10_practical_methods__shape_analysis.html">Tutorial: Shape analysis of curves with the Square Root Velocity metric</a></li>
<li class="toctree-l1"><a class="reference internal" href="11_real_world_applications__cell_shapes_analysis.html">Shape Analysis of Cancer Cells</a></li>
<li class="toctree-l1"><a class="reference internal" href="11_real_world_applications__cell_shapes_analysis.html#1.-Introduction-and-Motivation">1. Introduction and Motivation</a></li>
<li class="toctree-l1"><a class="reference internal" href="11_real_world_applications__cell_shapes_analysis.html#2.-Dataset-Description">2. Dataset Description</a></li>
<li class="toctree-l1"><a class="reference internal" href="11_real_world_applications__cell_shapes_analysis.html#3.-Preprocessing">3. Preprocessing</a></li>
<li class="toctree-l1"><a class="reference internal" href="11_real_world_applications__cell_shapes_analysis.html#4-Data-Analysis">4 Data Analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="11_real_world_applications__cell_shapes_analysis.html#Analyze-Distances-to-the-&quot;Global&quot;-Mean-Shape">Analyze Distances to the “Global” Mean Shape</a></li>
<li class="toctree-l1"><a class="reference internal" href="11_real_world_applications__cell_shapes_analysis.html#Changing-the-Metric-on-the-Space-of-Cell-Shapes">Changing the Metric on the Space of Cell Shapes</a></li>
<li class="toctree-l1"><a class="reference internal" href="11_real_world_applications__cell_shapes_analysis.html#Hypothesis-Testing-on-Equality-of-Means">Hypothesis Testing on Equality of Means</a></li>
<li class="toctree-l1"><a class="reference internal" href="11_real_world_applications__cell_shapes_analysis.html#Visualization-of-the-Mean-of-each-Treatment">Visualization of the Mean of each Treatment</a></li>
<li class="toctree-l1"><a class="reference internal" href="11_real_world_applications__cell_shapes_analysis.html#Distance-of-the-Cell-Shapes-to-their-Own-Mean-Shape">Distance of the Cell Shapes to their Own Mean Shape</a></li>
<li class="toctree-l1"><a class="reference internal" href="12_real_world_applications__emg_sign_classification_in_spd_manifold.html">Tutorial: Hand gesture classification with EMG data using Riemannian metrics</a></li>
<li class="toctree-l1"><a class="reference internal" href="13_real_world_applications__graph_embedding_and_clustering_in_hyperbolic_space.html">Tutorial: Hyperbolic Embedding of Graphs and Clustering</a></li>
<li class="toctree-l1"><a class="reference internal" href="14_real_world_applications__hand_poses_analysis_in_kendall_shape_space.html">Tutorial: Classifying hands poses with Kendall shape spaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="15_real_world_applications__optic_nerve_heads_analysis_in_kendall_shape_space.html">Tutorial: Computing with shapes of landmarks in Kendall shape spaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="16_real_world_applications__visualizations_in_kendall_shape_spaces.html">Tutorial : Computing with triangular shapes in Kendall framework</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Geomstats</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
      <li>1. Introduction</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/notebooks/01_foundations__manifolds.ipynb.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  
<style>
/* CSS for nbsphinx extension */

/* remove conflicting styling from Sphinx themes */
div.nbinput.container div.prompt *,
div.nboutput.container div.prompt *,
div.nbinput.container div.input_area pre,
div.nboutput.container div.output_area pre,
div.nbinput.container div.input_area .highlight,
div.nboutput.container div.output_area .highlight {
    border: none;
    padding: 0;
    margin: 0;
    box-shadow: none;
}

div.nbinput.container > div[class*=highlight],
div.nboutput.container > div[class*=highlight] {
    margin: 0;
}

div.nbinput.container div.prompt *,
div.nboutput.container div.prompt * {
    background: none;
}

div.nboutput.container div.output_area .highlight,
div.nboutput.container div.output_area pre {
    background: unset;
}

div.nboutput.container div.output_area div.highlight {
    color: unset;  /* override Pygments text color */
}

/* avoid gaps between output lines */
div.nboutput.container div[class*=highlight] pre {
    line-height: normal;
}

/* input/output containers */
div.nbinput.container,
div.nboutput.container {
    display: -webkit-flex;
    display: flex;
    align-items: flex-start;
    margin: 0;
    width: 100%;
}
@media (max-width: 540px) {
    div.nbinput.container,
    div.nboutput.container {
        flex-direction: column;
    }
}

/* input container */
div.nbinput.container {
    padding-top: 5px;
}

/* last container */
div.nblast.container {
    padding-bottom: 5px;
}

/* input prompt */
div.nbinput.container div.prompt pre {
    color: #307FC1;
}

/* output prompt */
div.nboutput.container div.prompt pre {
    color: #BF5B3D;
}

/* all prompts */
div.nbinput.container div.prompt,
div.nboutput.container div.prompt {
    width: 4.5ex;
    padding-top: 5px;
    position: relative;
    user-select: none;
}

div.nbinput.container div.prompt > div,
div.nboutput.container div.prompt > div {
    position: absolute;
    right: 0;
    margin-right: 0.3ex;
}

@media (max-width: 540px) {
    div.nbinput.container div.prompt,
    div.nboutput.container div.prompt {
        width: unset;
        text-align: left;
        padding: 0.4em;
    }
    div.nboutput.container div.prompt.empty {
        padding: 0;
    }

    div.nbinput.container div.prompt > div,
    div.nboutput.container div.prompt > div {
        position: unset;
    }
}

/* disable scrollbars on prompts */
div.nbinput.container div.prompt pre,
div.nboutput.container div.prompt pre {
    overflow: hidden;
}

/* input/output area */
div.nbinput.container div.input_area,
div.nboutput.container div.output_area {
    -webkit-flex: 1;
    flex: 1;
    overflow: auto;
}
@media (max-width: 540px) {
    div.nbinput.container div.input_area,
    div.nboutput.container div.output_area {
        width: 100%;
    }
}

/* input area */
div.nbinput.container div.input_area {
    border: 1px solid #e0e0e0;
    border-radius: 2px;
    /*background: #f5f5f5;*/
}

/* override MathJax center alignment in output cells */
div.nboutput.container div[class*=MathJax] {
    text-align: left !important;
}

/* override sphinx.ext.imgmath center alignment in output cells */
div.nboutput.container div.math p {
    text-align: left;
}

/* standard error */
div.nboutput.container div.output_area.stderr {
    background: #fdd;
}

/* ANSI colors */
.ansi-black-fg { color: #3E424D; }
.ansi-black-bg { background-color: #3E424D; }
.ansi-black-intense-fg { color: #282C36; }
.ansi-black-intense-bg { background-color: #282C36; }
.ansi-red-fg { color: #E75C58; }
.ansi-red-bg { background-color: #E75C58; }
.ansi-red-intense-fg { color: #B22B31; }
.ansi-red-intense-bg { background-color: #B22B31; }
.ansi-green-fg { color: #00A250; }
.ansi-green-bg { background-color: #00A250; }
.ansi-green-intense-fg { color: #007427; }
.ansi-green-intense-bg { background-color: #007427; }
.ansi-yellow-fg { color: #DDB62B; }
.ansi-yellow-bg { background-color: #DDB62B; }
.ansi-yellow-intense-fg { color: #B27D12; }
.ansi-yellow-intense-bg { background-color: #B27D12; }
.ansi-blue-fg { color: #208FFB; }
.ansi-blue-bg { background-color: #208FFB; }
.ansi-blue-intense-fg { color: #0065CA; }
.ansi-blue-intense-bg { background-color: #0065CA; }
.ansi-magenta-fg { color: #D160C4; }
.ansi-magenta-bg { background-color: #D160C4; }
.ansi-magenta-intense-fg { color: #A03196; }
.ansi-magenta-intense-bg { background-color: #A03196; }
.ansi-cyan-fg { color: #60C6C8; }
.ansi-cyan-bg { background-color: #60C6C8; }
.ansi-cyan-intense-fg { color: #258F8F; }
.ansi-cyan-intense-bg { background-color: #258F8F; }
.ansi-white-fg { color: #C5C1B4; }
.ansi-white-bg { background-color: #C5C1B4; }
.ansi-white-intense-fg { color: #A1A6B2; }
.ansi-white-intense-bg { background-color: #A1A6B2; }

.ansi-default-inverse-fg { color: #FFFFFF; }
.ansi-default-inverse-bg { background-color: #000000; }

.ansi-bold { font-weight: bold; }
.ansi-underline { text-decoration: underline; }


div.nbinput.container div.input_area div[class*=highlight] > pre,
div.nboutput.container div.output_area div[class*=highlight] > pre,
div.nboutput.container div.output_area div[class*=highlight].math,
div.nboutput.container div.output_area.rendered_html,
div.nboutput.container div.output_area > div.output_javascript,
div.nboutput.container div.output_area:not(.rendered_html) > img{
    padding: 5px;
    margin: 0;
}

/* fix copybtn overflow problem in chromium (needed for 'sphinx_copybutton') */
div.nbinput.container div.input_area > div[class^='highlight'],
div.nboutput.container div.output_area > div[class^='highlight']{
    overflow-y: hidden;
}

/* hide copybtn icon on prompts (needed for 'sphinx_copybutton') */
.prompt .copybtn {
    display: none;
}

/* Some additional styling taken form the Jupyter notebook CSS */
div.rendered_html table {
  border: none;
  border-collapse: collapse;
  border-spacing: 0;
  color: black;
  font-size: 12px;
  table-layout: fixed;
}
div.rendered_html thead {
  border-bottom: 1px solid black;
  vertical-align: bottom;
}
div.rendered_html tr,
div.rendered_html th,
div.rendered_html td {
  text-align: right;
  vertical-align: middle;
  padding: 0.5em 0.5em;
  line-height: normal;
  white-space: normal;
  max-width: none;
  border: none;
}
div.rendered_html th {
  font-weight: bold;
}
div.rendered_html tbody tr:nth-child(odd) {
  background: #f5f5f5;
}
div.rendered_html tbody tr:hover {
  background: rgba(66, 165, 245, 0.2);
}

/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<div class="admonition note">
  <p>Notebook source code:
    <a class="reference external" href="https://github.com/geomstats/geomstats/blob/master/notebooks/01_foundations__manifolds.ipynb">notebooks/01_foundations__manifolds.ipynb</a>
    <br>Run it yourself on binder
    <a href="https://mybinder.org/v2/gh/geomstats/geomstats/master?filepath=notebooks/01_foundations__manifolds.ipynb"><img alt="Binder badge"
    src="https://mybinder.org/badge_logo.svg"
    style="vertical-align:text-bottom"></a>
  </p>
</div><p><span class="math notranslate nohighlight">\(\textbf{Lead Author: Adele Myers}\)</span></p>
<p>Inspired by: Guigui, Miolane, Pennec, 2022. Introduction to Riemannian Geometry and Geometric Statistics: from basic theory to implementation with Geomstats.</p>
<p>Note: Before you start to read this notebook, run the following code. This will import packages that will allow later code to run.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span> In [20]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()))</span>
<span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>

<span class="kn">import</span> <span class="nn">geomstats.backend</span> <span class="k">as</span> <span class="nn">gs</span>

<span class="n">gs</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">2020</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="1.-Introduction">
<h1>1. Introduction<a class="headerlink" href="#1.-Introduction" title="Permalink to this headline"></a></h1>
<p>Welcome to the <code class="docutils literal notranslate"><span class="pre">Manifold</span></code> class notebook! In this notebook, we will discuss manifolds and the <code class="docutils literal notranslate"><span class="pre">Manifold</span></code> class in Geomstats. Geomstats is a software which analyzes data on manifolds, so naturally the <code class="docutils literal notranslate"><span class="pre">Manifold</span></code> class is quite important.</p>
<p>You will learn:</p>
<ol class="arabic simple">
<li><p>What is a manifold?</p></li>
<li><p>Why do we care about manifolds?</p></li>
<li><p>What does the <code class="docutils literal notranslate"><span class="pre">Manifold</span></code> class do?</p></li>
<li><p>How is the <code class="docutils literal notranslate"><span class="pre">Manifold</span></code> class structured?</p>
<ol class="arabic simple">
<li><p>What is an open set?</p></li>
<li><p>What is a closed set?</p></li>
<li><p>What is a tangent space?</p></li>
</ol>
</li>
</ol>
<p><img alt="595e234e69c04f8bbff7b5cac46e8b6a" src="../_images/manifold_intro.png" /></p>
</div>
<div class="section" id="2.-What-is-a-Manifold?">
<h1>2. What is a Manifold?<a class="headerlink" href="#2.-What-is-a-Manifold?" title="Permalink to this headline"></a></h1>
<p><span class="math notranslate nohighlight">\(\textbf{Intuition:}\)</span> When you are first learning, it can be a helpful starting point to think of a manifold as a surface. This surface can have any dimension and any shape as long as it is smooth (in the sense of being continuous and differentiable). (This is not a particularly precise definition, but it can be helpful starting point for building intuition.) For example, a hypersphere is a two dimensional manifold, and we will often use this manifold in examples.</p>
<div class="section" id="2.1-Precise-Mathematical-Definition">
<h2>2.1 Precise Mathematical Definition<a class="headerlink" href="#2.1-Precise-Mathematical-Definition" title="Permalink to this headline"></a></h2>
<p>A manifold is a set of points that satisfy a specific set of constraints. More specifically, a nonempty subset M <span class="math notranslate nohighlight">\(\subseteq \mathbb{R}^{N}\)</span> is a d-dimensional manifold if and only if ANY of the following conditions hold:</p>
<ol class="arabic simple">
<li><p>(Local parametrization) For every <span class="math notranslate nohighlight">\(p \in M\)</span>, there are two open subsets $ V <span class="math">\subseteq `:nbsphinx-math:</span>mathbb{R}`^{d}$ and $ U <span class="math">\subseteq `:nbsphinx-math:</span>mathbb{R}`^{N}$ with <span class="math notranslate nohighlight">\(p \in U\)</span> and <span class="math notranslate nohighlight">\(0 \in V\)</span>. There is also a smooth function <span class="math notranslate nohighlight">\(f: V \to \mathbb{R}^{N}\)</span> such that <span class="math notranslate nohighlight">\(f(0) = p\)</span>, where <span class="math notranslate nohighlight">\(f\)</span> is a homeomorphism between V and <span class="math notranslate nohighlight">\(U \cap M\)</span>, and <span class="math notranslate nohighlight">\(f\)</span> is an immersion at 0.</p></li>
<li><p>(Local implicit function) For every <span class="math notranslate nohighlight">\(p \in M\)</span>, there exists an open set <span class="math notranslate nohighlight">\(U \in \mathbb{R}^{N}\)</span> and a smooth map <span class="math notranslate nohighlight">\(f: U \to \mathbb{R}^{N-d}\)</span> that is a submersion at p, such that <span class="math notranslate nohighlight">\(U \cap M = f^{-1}\)</span>({0}).</p></li>
<li><p>(Local Graph) For every <span class="math notranslate nohighlight">\(x \in M\)</span>, there exists an open neighborhood <span class="math notranslate nohighlight">\(U \subseteq \mathbb{R}^{N}\)</span> of <span class="math notranslate nohighlight">\(x\)</span>, a neighborhood <span class="math notranslate nohighlight">\(V \subseteq \mathbb{R}^{d}\)</span> of 0 and a smooth map <span class="math notranslate nohighlight">\(f: V \to \mathbb{R}^{N-d}\)</span> such that <span class="math notranslate nohighlight">\(U \cap M = graph(f)^{2}\)</span></p></li>
</ol>
</div>
<div class="section" id="2.2-Imprecise-&quot;Layman's-Terms&quot;-Definition:">
<h2>2.2 Imprecise “Layman’s Terms” Definition:<a class="headerlink" href="#2.2-Imprecise-"Layman's-Terms"-Definition:" title="Permalink to this headline"></a></h2>
<p>A <span class="math notranslate nohighlight">\(\textbf{manifold}\)</span> is a set of points that satisfy a specific set of constraints, and these constraints are given by the mathematical definition above. That means that if a set of points satisfies any one of the conditions, then it is a manifold. However, these conditions can be hard to digest. We can translate the above mathematical conditions into three different ways of describing manifolds:</p>
<ol class="arabic simple">
<li><p>(Local Parametrization) a manifold is a topological space that locally resembles Euclidean space near each point. For example, consider a two dimensional grid. We would not be able to deform this grid to have the shape of a sphere under any circumstance, but at each <span class="math notranslate nohighlight">\(\textbf{local}\)</span> point on the manifold, we can approximate the space around the point with a Euclidean grid.</p></li>
<li><p>(Local Implicit Function) a manifold can be understood as the set of points that verify a constraint defined by an implicit equation, given by the function <span class="math notranslate nohighlight">\(f\)</span>. (see hypersphere example)</p></li>
<li><p>(Local Graph) a manifold can be understood as a d-dimensional surface described by d variables, i.e. by the “graph” of a smooth function <span class="math notranslate nohighlight">\(f: (x_1,...,x_d) \to f(x_1,...,x_d)\)</span>. This local graph cannot be applied globally (to the whole manifold) because a function <span class="math notranslate nohighlight">\(f\)</span> must have only one output per set of inputs, and if we were to try to describe the whole manifold with such a graph, then many manifolds would have more than one output for one set of inputs.</p></li>
</ol>
<p>The figure below provides a visualization of each of these definitions. The first figure is a visualization of “local parametrization”, the second is a visualization of “local implicit function” and the third is a visualization of “local graph”:</p>
<p><img alt="46f2962c2855462499803eab87abd870" src="../_images/manifold_definitions1.png" /></p>
<p><img alt="a14d640a837c4193afae00c755618082" src="../_images/manifold_definitions2.png" /></p>
<p>Each one of these definitions of a manifold is important because each one gives us an additional way to describe a manifold. This is useful because some manifolds are much easier described (or computationally implemented) by one of these definitions than the others. For example, any three of these definitions can be used to describe a hypersphere, but a hypersphere is most easily implemented using definition (2).</p>
</div>
<div class="section" id="2.3-Hypersphere-example:">
<h2>2.3 Hypersphere example:<a class="headerlink" href="#2.3-Hypersphere-example:" title="Permalink to this headline"></a></h2>
<p>Here, we will consider how to prove that a hypersphere is a manifold using the second condition in the definition of a manifold above (2).</p>
<p>A <span class="math notranslate nohighlight">\(\textbf{hypersphere}\)</span> is any of a set of objects (n-dimensional spheres) resulting from the generalization of a one-dimensional circle and a two-dimensional sphere. The dimension of the manifold is n and is equal to the number of degrees of freedom of a point moving on In n-dimensional space, a hypersphere is the set of all points that are a given distance (called the radius) from a given point (called the center). For example, a 2-dimensional hypersphere in 3-dimensions describes all
the points in 3D space that lie on the surface of a sphere. In other words, a hypersphere describes all of the points that lie in three dimensions that have two degrees of freedom <span class="math notranslate nohighlight">\((\phi, \theta)\)</span>.</p>
<p><span class="math notranslate nohighlight">\(\textbf{How do we know that a hypersphere is a manifold?}\)</span> Well, we know from the definition of a hypersphere that a hypersphere is the set of all points that are a given distance from the center of your coordinate system. For example in 3-dimensions, the surface <span class="math notranslate nohighlight">\(S\)</span> of a sphere with radius 1 can be described by the relation:</p>
<p><span class="math notranslate nohighlight">\(|x|^{2} = 1\)</span></p>
<p>This simply says that all the points must be a distance of 1 away from the center. (see above figure (b) and take a = 1).</p>
<p>We can now define a function</p>
<p><span class="math notranslate nohighlight">\(f(x) = |x|^{2} - 1\)</span></p>
<p>We know that this function <span class="math notranslate nohighlight">\(f\)</span> will always equal zero for all points that lie on the surface <span class="math notranslate nohighlight">\(S\)</span> because in order for a point to fall on the surface <span class="math notranslate nohighlight">\(S\)</span> the condition <span class="math notranslate nohighlight">\(|x|^{2} = 1\)</span> must be true. In other words,</p>
<p><span class="math notranslate nohighlight">\(x \in S \iff f(x) = 0\)</span></p>
<p>which tells us that</p>
<p><span class="math notranslate nohighlight">\(x \in S \iff x \in f^{-1}\)</span>({0})</p>
<p>This last line matches the definition of a manifold: <span class="math notranslate nohighlight">\(M = f^{-1}\)</span>({0}) where <span class="math notranslate nohighlight">\(M\)</span> is the set of points <span class="math notranslate nohighlight">\(x\)</span> that satisfy the condition <span class="math notranslate nohighlight">\(|x|^{2} = 1\)</span>. Therefore, the set of points that satisfy the condition <span class="math notranslate nohighlight">\(|x|^{2} = 1\)</span> form a manifold.</p>
</div>
<div class="section" id="2.4-More-examples-of-manifolds:">
<h2>2.4 More examples of manifolds:<a class="headerlink" href="#2.4-More-examples-of-manifolds:" title="Permalink to this headline"></a></h2>
<p>A hyperphere is one type of manifold, but there are many other types of manifolds that are commonly used and seen in nature. We will show a few examples here to help you build intuition about what a manifold is and what a manifold can look like.</p>
<p>For example, a torus (the surface of a donut) is a manifold.</p>
<p><img alt="a1e8c0b83c474d18b37d9f663bccbbea" src="../_images/manifold_torus.png" /></p>
<p>A klein bottle (the surface of the shape shown below) is also a manifold.</p>
<p><img alt="fd2b1c629472459fa91e2f872e1d5168" src="../_images/manifold_klein_bottle.png" /></p>
<p>Perhaps a more familiar example for those in physics: Minkowski space (or Minkowski spacetime) is a combination of three-dimensional Euclidean space and time into a four-dimensional manifold (where x, y, z, and time are the dimensions of the space). This manifold is theorized to take one of three forms. A 4-dimensional manifold of: (a) flat curvature, (b) positive curvature, or (c) negative curvature.</p>
<p><img alt="d185808832604316b390bfb9e8875311" src="../_images/manifold_spacetime.jpeg" /></p>
</div>
</div>
<div class="section" id="3.-Why-do-we-care-about-manifolds?">
<h1>3. Why do we care about manifolds?<a class="headerlink" href="#3.-Why-do-we-care-about-manifolds?" title="Permalink to this headline"></a></h1>
<p><span class="math notranslate nohighlight">\(\textbf{Manifolds are important because data in nature &quot;naturally falls on manifolds&quot;}\)</span>, and as we discussed in the introduction section, knowing the manifold that a data set belongs to may give you more predictive power and a better understanding of the data’s evolution.</p>
<p><span class="math notranslate nohighlight">\(\textbf{What does it mean for data to &quot;naturally fall on a manifold&quot;?}\)</span> In nature, data are often subject to constraints, and these constraints force the data to lie on manifolds. For example, consider the position of cities on the earth.</p>
<p><img alt="05ab712e0f7f4239b81c7462fc1f8a2e" src="../_images/manifold_cities_on_earth.png" /></p>
<p>The cities are subject to the following constraints: 1) they cannot fly above the surface of the earth because gravity holds them down and 2) they cannot sink down into the earth because the surface of the earth holds them up. Therefore, they are constrained to move (or not move) on the surface of a 3-dimensional sphere. This space that they are confined to exist in should sound familiar– it is the space of a 2-dimensional hypersphere!</p>
<p>Other data falls on manifolds in similar ways: the data is subject to certain constraints, which forces it to fall on a manifold.</p>
</div>
<div class="section" id="4.-What-does-the-Manifold-class-do?">
<h1>4. What does the <code class="docutils literal notranslate"><span class="pre">Manifold</span></code> class do?<a class="headerlink" href="#4.-What-does-the-Manifold-class-do?" title="Permalink to this headline"></a></h1>
<p>The <code class="docutils literal notranslate"><span class="pre">Manifold</span></code> class describes different types of manifolds. The <code class="docutils literal notranslate"><span class="pre">Manifold</span></code> class and its subclasses implement methods that establish the properties of different types of manifolds, and the manifolds that exist under these subclasses inherit the properties implemented in their respective sublclasses.</p>
<p>Note: The words “class”, “subclass”, “methods” refer to <a class="reference external" href="https://www.educative.io/blog/object-oriented-programming">object oriented programming</a>.</p>
<p>The manifold class also provides ways of checking whether a vector is <span class="math notranslate nohighlight">\(\textit{tangent}\)</span> to a manifold and ways of projecting a vector to the <span class="math notranslate nohighlight">\(\textit{tangent space}\)</span> of a manifold. In order to better describe what this means, we will now define <span class="math notranslate nohighlight">\(\textit{tangent vectors}\)</span> and <span class="math notranslate nohighlight">\(\textit{tangent spaces}\)</span>.</p>
<div class="section" id="4.1-Tangent-Vectors">
<h2>4.1 Tangent Vectors<a class="headerlink" href="#4.1-Tangent-Vectors" title="Permalink to this headline"></a></h2>
<p>Here we will provide a brief reminder of tangent vectors as a way to lay the groundwork for discussing tangent spaces.</p>
<p>A <span class="math notranslate nohighlight">\(\textbf{tangent vector}\)</span> is a vector that is “tangent” to a curve or surface at a given point. When a vector is “tangent” to a curve, this means that the vector has the same slope as the curve does at that point.</p>
<p><img alt="56a1dd7f93454f43ada303854b7b3998" src="../_images/manifold_tangent_vector.png" /></p>
</div>
<div class="section" id="4.2-Tangent-Spaces">
<h2>4.2 Tangent Spaces<a class="headerlink" href="#4.2-Tangent-Spaces" title="Permalink to this headline"></a></h2>
<p>Now we will introduce the concept of a “tangent space”. The tangent space at a certain point on a manifold is comprised of all of the possible tangent vectors that exist at that point. For example, if you are considering the tangent space on a curve, then the only possible tangent vectors are tangent vectors that point forward and backward along the line (a). However, if you are considering the tangent space at a point on a surface, then the tangent vectors can point forward, backward, left,
right, and everywhere in between, and the set of all tangent vectors forms a plane (b).</p>
<p><img alt="df9b567c82944426abbb99a4212e1f1c" src="../_images/manifold_tangent_space.jpeg" /></p>
<p>Thus, the tangent space of a 1-dimensional manifold (curve) is also one dimensional, and the tangent space of a 2-dimensional manifold (a 2-dimensional surface) is also 2-dimensional.</p>
<p>Similarly, for every n-dimensional manifold, there exists an n-dimensional tangent space at each point on the manifold, and the tangent space is comprised of all possible tangent vectors on that manifold.</p>
</div>
</div>
<div class="section" id="5.-How-is-the-Manifold-class-structured?">
<h1>5. How is the <code class="docutils literal notranslate"><span class="pre">Manifold</span></code> class structured?<a class="headerlink" href="#5.-How-is-the-Manifold-class-structured?" title="Permalink to this headline"></a></h1>
<p>The hierarchical structure of the classes inheriting from the <code class="docutils literal notranslate"><span class="pre">Manifold</span></code> parent class is as follows (this Figure is a courtesy of Nicolas Guigui):</p>
<p><img alt="394fb3b95d264164917cdaad770fbf76" src="../_images/manifold_hierarchy.jpeg" /></p>
<p>As discussed in the previous section, one of the primary purposes of the <code class="docutils literal notranslate"><span class="pre">Manifold</span></code> class is to hold information about various types of manifolds. Rules that are universally true for all manifolds are implemented in methods in the parent class <code class="docutils literal notranslate"><span class="pre">Manifold</span></code>. Rules that are true for some types of manifolds are implemented in the subclasses of <code class="docutils literal notranslate"><span class="pre">Manifold</span></code>: <code class="docutils literal notranslate"><span class="pre">LevelSet</span></code>, <code class="docutils literal notranslate"><span class="pre">OpenSet</span></code>, <code class="docutils literal notranslate"><span class="pre">FiberBundle</span></code>, <code class="docutils literal notranslate"><span class="pre">ProductManifold</span></code>, <code class="docutils literal notranslate"><span class="pre">VectorSpace</span></code>, <code class="docutils literal notranslate"><span class="pre">MatrixLieAlgebra</span></code>, and <code class="docutils literal notranslate"><span class="pre">MatrixLieGroup</span></code>. Specific
types of manifolds are described in methods within these subclasses.</p>
<p>In this notebook, we will focus on describing the subclasses pertenant to the geometry module of geomstats: <code class="docutils literal notranslate"><span class="pre">LevelSet</span></code>, <code class="docutils literal notranslate"><span class="pre">OpenSet</span></code>, <code class="docutils literal notranslate"><span class="pre">ProductManifold</span></code> and <code class="docutils literal notranslate"><span class="pre">VectorSpace</span></code>.</p>
<p>In the following subsections, we will discuss the methods and ideas implemented in the parent class and its subclasses.</p>
<div class="section" id="5.1-The-Parent-Class:-Manifold">
<h2>5.1 The Parent Class: <code class="docutils literal notranslate"><span class="pre">Manifold</span></code><a class="headerlink" href="#5.1-The-Parent-Class:-Manifold" title="Permalink to this headline"></a></h2>
<p>The Manifold parent class is an abstract base class which provides the minimal skeleton of attributes and methods expected in its subclasses. Note that the methods of the abstract parent class are declared, but they contain no implementation, and they are overridden by the subclasses. The properties that are declared in the <code class="docutils literal notranslate"><span class="pre">Manifold</span></code> class are properties that all types of manifold must posess. For example, the following methods and attributes are implemented in <code class="docutils literal notranslate"><span class="pre">Manifold</span></code>:</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">dim</span></code>: <span class="math notranslate nohighlight">\(\textit{attribute}\)</span>. the dimension of the manifold. “How many coordinates are necessary to fully describe the manifold?”</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">belongs()</span></code>: <span class="math notranslate nohighlight">\(\textit{method}\)</span>. evaluates whether a given element belongs to that manifold</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">is_tangent()</span></code>: <span class="math notranslate nohighlight">\(\textit{method}\)</span>. evaluates whether a given vector is a tangent vector at a given point</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">random_point()</span></code>: <span class="math notranslate nohighlight">\(\textit{method}\)</span>. generates a random point that lies on the manifold</p></li>
</ol>
<p>While the abstract methods in Manifold do not contain any implementation, the methods of the subclasses of <code class="docutils literal notranslate"><span class="pre">Manifold</span></code>, such as the <code class="docutils literal notranslate"><span class="pre">Hypersphere</span></code> subclass, <span class="math notranslate nohighlight">\(\textit{are}\)</span> implemented and can be run. We will now exemplify this in the following section</p>
<div class="section" id="5.1.1-Examples-of-Using-Manifold's-Attributes-and-Methods-in-the-Subclass:-Hypersphere">
<h3>5.1.1 Examples of Using <code class="docutils literal notranslate"><span class="pre">Manifold</span></code>’s Attributes and Methods in the Subclass: <code class="docutils literal notranslate"><span class="pre">Hypersphere</span></code><a class="headerlink" href="#5.1.1-Examples-of-Using-Manifold's-Attributes-and-Methods-in-the-Subclass:-Hypersphere" title="Permalink to this headline"></a></h3>
<p><span class="math notranslate nohighlight">\(\textbf{Attributes:}\)</span></p>
<p><code class="docutils literal notranslate"><span class="pre">dim</span></code> : If we build a hypersphere of dimension 2 with the following code, we can check that <code class="docutils literal notranslate"><span class="pre">sphere.dim</span></code> gives back 2. Run the following code to verify this:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span> In [7]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">geomstats.geometry.hypersphere</span> <span class="kn">import</span> <span class="n">Hypersphere</span>
<span class="n">sphere</span> <span class="o">=</span> <span class="n">Hypersphere</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The dimension of the sphere is </span><span class="si">{</span><span class="n">sphere</span><span class="o">.</span><span class="n">dim</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
The dimension of the sphere is 2
</pre></div></div>
</div>
<p><span class="math notranslate nohighlight">\(\textbf{Methods:}\)</span></p>
<p><code class="docutils literal notranslate"><span class="pre">belongs</span></code> : We can re-use the sphere we just built (called “sphere”) and verify that the point (0, 0, 1) belongs to that sphere (it is the north pole). Run the following code to verify this using Geomstats.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span> In [5]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">geomstats.backend</span> <span class="k">as</span> <span class="nn">gs</span>

<span class="n">sphere</span><span class="o">.</span><span class="n">belongs</span><span class="p">(</span><span class="n">gs</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span> Out [5]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
True
</pre></div></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">is_tangent</span></code> : The vector (1, 1, 0 ) is tangent to the sphere at the north pole, since it does not have a vertical component (last component is equal to 0). Run the following code to verify this using Geomstats.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span> In [9]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sphere</span><span class="o">.</span><span class="n">is_tangent</span><span class="p">(</span><span class="n">vector</span><span class="o">=</span><span class="n">gs</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span> <span class="n">base_point</span><span class="o">=</span><span class="n">gs</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span> Out [9]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
True
</pre></div></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">random_point</span></code> : Now, we will use <code class="docutils literal notranslate"><span class="pre">random_point</span></code> to generate a random point, and then we will use <code class="docutils literal notranslate"><span class="pre">belongs</span></code> to prove that this random point belongs to the sphere.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span> In [15]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">geomstats.geometry.hypersphere</span> <span class="kn">import</span> <span class="n">Hypersphere</span>

<span class="n">rp</span><span class="o">=</span><span class="n">Hypersphere</span><span class="o">.</span><span class="n">random_point</span><span class="p">(</span><span class="n">sphere</span><span class="p">)</span>

<span class="n">sphere</span><span class="o">.</span><span class="n">belongs</span><span class="p">(</span><span class="n">rp</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span> Out [15]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
True
</pre></div></div>
</div>
</div>
<div class="section" id="5.1.2-The-Full-Manifold-Class-Code">
<h3>5.1.2 The Full <code class="docutils literal notranslate"><span class="pre">Manifold</span></code> Class Code<a class="headerlink" href="#5.1.2-The-Full-Manifold-Class-Code" title="Permalink to this headline"></a></h3>
<p>You can see all of the methods in the <code class="docutils literal notranslate"><span class="pre">Manifold</span></code> parent class by running the following code. Observe the abstract methods denoted with “&#64;abc.abstractmethod” that do not contain any implementation, but serve as template for the subclasses to overwrite. The code of <code class="docutils literal notranslate"><span class="pre">Manifold</span></code> can also be found <a class="reference external" href="https://github.com/geomstats/geomstats/blob/master/geomstats/geometry/manifold.py">here</a>.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span> In [27]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">inspect</span>

<span class="kn">from</span> <span class="nn">geomstats.geometry.manifold</span> <span class="kn">import</span> <span class="n">Manifold</span>

<span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getsourcelines</span><span class="p">(</span><span class="n">Manifold</span><span class="p">)[</span><span class="mi">0</span><span class="p">]:</span>
    <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
class Manifold(abc.ABC):
    r&#34;&#34;&#34;Class for manifolds.

    Parameters
    ----------
    dim : int
        Dimension of the manifold.
    shape : tuple of int
        Shape of one element of the manifold.
        Optional, default : None.
    metric : RiemannianMetric
        Metric object to use on the manifold.
    default_point_type : str, {\&#39;vector\&#39;, \&#39;matrix\&#39;}
        Point type.
        Optional, default: &#39;vector&#39;.
    default_coords_type : str, {\&#39;intrinsic\&#39;, \&#39;extrinsic\&#39;, etc}
        Coordinate type.
        Optional, default: &#39;intrinsic&#39;.
    &#34;&#34;&#34;

    def __init__(
        self,
        dim,
        shape,
        metric=None,
        default_point_type=None,
        default_coords_type=&#34;intrinsic&#34;,
        **kwargs
    ):
        super(Manifold, self).__init__(**kwargs)
        geomstats.errors.check_integer(dim, &#34;dim&#34;)

        if not isinstance(shape, tuple):
            raise ValueError(&#34;Expected a tuple for the shape argument.&#34;)
        if default_point_type is None:
            default_point_type = POINT_TYPES[len(shape)]

        geomstats.errors.check_parameter_accepted_values(
            default_point_type, &#34;default_point_type&#34;, [&#34;vector&#34;, &#34;matrix&#34;]
        )

        self.dim = dim
        self.shape = shape
        self.default_point_type = default_point_type
        self.default_coords_type = default_coords_type
        self.metric = metric

    @abc.abstractmethod
    def belongs(self, point, atol=gs.atol):
        &#34;&#34;&#34;Evaluate if a point belongs to the manifold.

        Parameters
        ----------
        point : array-like, shape=[..., dim]
            Point to evaluate.
        atol : float
            Absolute tolerance.
            Optional, default: backend atol.

        Returns
        -------
        belongs : array-like, shape=[...,]
            Boolean evaluating if point belongs to the manifold.
        &#34;&#34;&#34;

    @abc.abstractmethod
    def is_tangent(self, vector, base_point, atol=gs.atol):
        &#34;&#34;&#34;Check whether the vector is tangent at base_point.

        Parameters
        ----------
        vector : array-like, shape=[..., dim]
            Vector.
        base_point : array-like, shape=[..., dim]
            Point on the manifold.
        atol : float
            Absolute tolerance.
            Optional, default: backend atol.

        Returns
        -------
        is_tangent : bool
            Boolean denoting if vector is a tangent vector at the base point.
        &#34;&#34;&#34;

    @abc.abstractmethod
    def to_tangent(self, vector, base_point):
        &#34;&#34;&#34;Project a vector to a tangent space of the manifold.

        Parameters
        ----------
        vector : array-like, shape=[..., dim]
            Vector.
        base_point : array-like, shape=[..., dim]
            Point on the manifold.

        Returns
        -------
        tangent_vec : array-like, shape=[..., dim]
            Tangent vector at base point.
        &#34;&#34;&#34;

    @abc.abstractmethod
    def random_point(self, n_samples=1, bound=1.0):
        &#34;&#34;&#34;Sample random points on the manifold.

        If the manifold is compact, a uniform distribution is used.

        Parameters
        ----------
        n_samples : int
            Number of samples.
            Optional, default: 1.
        bound : float
            Bound of the interval in which to sample for non compact manifolds.
            Optional, default: 1.

        Returns
        -------
        samples : array-like, shape=[..., {dim, [n, n]}]
            Points sampled on the hypersphere.
        &#34;&#34;&#34;

    def regularize(self, point):
        &#34;&#34;&#34;Regularize a point to the canonical representation for the manifold.

        Parameters
        ----------
        point : array-like, shape=[..., dim]
            Point.

        Returns
        -------
        regularized_point : array-like, shape=[..., dim]
            Regularized point.
        &#34;&#34;&#34;
        regularized_point = point
        return regularized_point

    @property
    def metric(self):
        &#34;&#34;&#34;Riemannian Metric associated to the Manifold.&#34;&#34;&#34;
        return self._metric

    @metric.setter
    def metric(self, metric):
        if metric is not None:
            if not isinstance(metric, RiemannianMetric):
                raise ValueError(&#34;The argument must be a RiemannianMetric object&#34;)
            if metric.dim != self.dim:
                metric.dim = self.dim
        self._metric = metric
</pre></div></div>
</div>
</div>
</div>
<div class="section" id="5.2-OpenSet">
<h2>5.2 <code class="docutils literal notranslate"><span class="pre">OpenSet</span></code><a class="headerlink" href="#5.2-OpenSet" title="Permalink to this headline"></a></h2>
<p>Earlier in the notebook, we were able to say that a set of points is a manifold if it satisfied one of three constraints. We also said that every manifold can be described by any three of these definitions, and the choice of defintion is merely a question of which definition is most convenient. <code class="docutils literal notranslate"><span class="pre">OpenSet</span></code> provides a way of describing manifolds with local parametrization, which was labeled (1) on our definition list.</p>
<p>One such way to describe a manifold is with the concept of an <span class="math notranslate nohighlight">\(\textbf{Open Set}\)</span>: a manifold is the open sets of a d-dimensional vector space, called <span class="math notranslate nohighlight">\(\textbf{ambient space}\)</span>.</p>
<div class="section" id="5.2.1-What-is-an-Open-Set?">
<h3>5.2.1 What is an Open Set?<a class="headerlink" href="#5.2.1-What-is-an-Open-Set?" title="Permalink to this headline"></a></h3>
<p>Intuitively, an open set is a group of numbers that does not include points on the boundary of whatever they are describing. For example, if you were to take the set of all points between a and b but <span class="math notranslate nohighlight">\(\textbf{not}\)</span> include the values a and b, this would be an open set (shown in figure a). If you were to take the set of all points between a and b and include the values a and b, this would be a closed set (shown in figure b)</p>
<p><img alt="6ebbd5241001465e90436d7a66abbda8" src="../_images/manifold_openSet_lines.png" /></p>
<p>The above examples showed open and closed sets in one dimension. Similarly, in two dimensions, open sets can be defined as sets which do not contain their boundaries. For example, the inside of the sphere, i.e. the ball without its boundary, is a manifold that is an open set. The image below shows an example of an open set (a) and a closed set (b) in two dimensions.</p>
<p><img alt="3c0ab4485b7c4804b98f85cdf8887e3c" src="../_images/manifold_openSurfaces.png" /></p>
</div>
<div class="section" id="5.2.2-What-Methods-are-Implemented-in-OpenSet?">
<h3>5.2.2 What Methods are Implemented in <code class="docutils literal notranslate"><span class="pre">OpenSet</span></code>?<a class="headerlink" href="#5.2.2-What-Methods-are-Implemented-in-OpenSet?" title="Permalink to this headline"></a></h3>
<p>If we know that a manifold is conveniently described as an open set, then some of the manifold’s abstract methods can be rewritten in a specific form. For example, <code class="docutils literal notranslate"><span class="pre">OpenSet</span></code> implements the methods:</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">projection()</span></code>: a method to project any d-dimensional vector to the manifold.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">is_tangent()</span></code>: checks whether the input vector is tangent at the input point.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">to_tangent()</span></code>: projects a vector to a tangent space of the manifold.</p></li>
</ol>
<p>Note that we do not (yet) specify which manifold we are talking about (whether it is a sphere or another surface), we are just saying that we are looking at some manifold that can be described as an open set</p>
<p>Run the code below to see the contents of the <code class="docutils literal notranslate"><span class="pre">OpenSet</span></code> class.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span> In [26]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">inspect</span>

<span class="kn">from</span> <span class="nn">geomstats.geometry.base</span> <span class="kn">import</span> <span class="n">OpenSet</span>

<span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getsourcelines</span><span class="p">(</span><span class="n">OpenSet</span><span class="p">)[</span><span class="mi">0</span><span class="p">]:</span>
    <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
class OpenSet(Manifold, abc.ABC):
    &#34;&#34;&#34;Class for manifolds that are open sets of a vector space.

    In this case, tangent vectors are identified with vectors of the ambient
    space.

    Parameters
    ----------
    dim: int
        Dimension of the manifold. It is often the same as the ambient space
        dimension but may differ in some cases.
    ambient_space: VectorSpace
        Ambient space that contains the manifold.
    &#34;&#34;&#34;

    def __init__(self, dim, ambient_space, **kwargs):
        if &#34;default_point_type&#34; not in kwargs:
            kwargs[&#34;default_point_type&#34;] = ambient_space.default_point_type
        if &#34;shape&#34; not in kwargs:
            kwargs[&#34;shape&#34;] = ambient_space.shape
        super().__init__(dim=dim, **kwargs)
        self.ambient_space = ambient_space

    def is_tangent(self, vector, base_point=None, atol=gs.atol):
        &#34;&#34;&#34;Check whether the vector is tangent at base_point.

        Parameters
        ----------
        vector : array-like, shape=[..., dim]
            Vector.
        base_point : array-like, shape=[..., dim]
            Point on the manifold.
        atol : float
            Absolute tolerance.
            Optional, default: backend atol.

        Returns
        -------
        is_tangent : bool
            Boolean denoting if vector is a tangent vector at the base point.
        &#34;&#34;&#34;
        return self.ambient_space.belongs(vector, atol)

    def to_tangent(self, vector, base_point=None):
        &#34;&#34;&#34;Project a vector to a tangent space of the manifold.

        Parameters
        ----------
        vector : array-like, shape=[..., dim]
            Vector.
        base_point : array-like, shape=[..., dim]
            Point on the manifold.

        Returns
        -------
        tangent_vec : array-like, shape=[..., dim]
            Tangent vector at base point.
        &#34;&#34;&#34;
        return self.ambient_space.projection(vector)

    def random_point(self, n_samples=1, bound=1.0):
        &#34;&#34;&#34;Sample random points on the manifold.

        If the manifold is compact, a uniform distribution is used.

        Parameters
        ----------
        n_samples : int
            Number of samples.
            Optional, default: 1.
        bound : float
            Bound of the interval in which to sample for non compact manifolds.
            Optional, default: 1.

        Returns
        -------
        samples : array-like, shape=[..., {dim, [n, n]}]
            Points sampled on the hypersphere.
        &#34;&#34;&#34;
        sample = self.ambient_space.random_point(n_samples, bound)
        return self.projection(sample)

    @abc.abstractmethod
    def projection(self, point):
        &#34;&#34;&#34;Project a point in ambient manifold on manifold.

        Parameters
        ----------
        point : array-like, shape=[..., dim]
            Point in ambient manifold.

        Returns
        -------
        projected : array-like, shape=[..., dim]
            Projected point.
        &#34;&#34;&#34;
</pre></div></div>
</div>
</div>
</div>
<div class="section" id="5.3-LevelSet">
<h2>5.3 <code class="docutils literal notranslate"><span class="pre">LevelSet</span></code><a class="headerlink" href="#5.3-LevelSet" title="Permalink to this headline"></a></h2>
<div class="section" id="5.3.1-What-is-a-Level-Set?">
<h3>5.3.1 What is a Level Set?<a class="headerlink" href="#5.3.1-What-is-a-Level-Set?" title="Permalink to this headline"></a></h3>
<p>Another elementary class of manifolds are <span class="math notranslate nohighlight">\(\textbf{Level Sets}\)</span>. A level set is the set of values <span class="math notranslate nohighlight">\(x\)</span> for which a function f(x) is equal to a given constant. In other words, a level set is a set of curves for which the fucntion describing a manifold is constant along that curve.</p>
<p>In the same way that <code class="docutils literal notranslate"><span class="pre">OpenSet</span></code> is an implementation of the first definition of a manifold (Local Parametrization), <code class="docutils literal notranslate"><span class="pre">LevelSet</span></code> is an implementation of the second definition of a manifold (Local Implicit Function). a level set is a set of points for which the function <span class="math notranslate nohighlight">\(f\)</span> takes the exact same value. This value is called the “level”, and does not need to be a scalar, it could also be a vector.</p>
<p>For example, consider a hypersphere in three dimensional space. Each of the concentric spheres is a 2-dimensional manifold, each corresponding to a different level <span class="math notranslate nohighlight">\((r1, r2,r3)\)</span>.</p>
<p><img alt="958544e7d9634034ad99f1330ea66593" src="../_images/manifold_LevelSet.png" /></p>
<p>You can see <a class="reference external" href="https://github.com/geomstats/geomstats/blob/20cccf598e94823ef8d7c0821b2968e6d29660c0/geomstats/geometry/hypersphere.py#L22">here</a> that the subclass <code class="docutils literal notranslate"><span class="pre">Hypersphere</span></code> is indeed implemented as a <code class="docutils literal notranslate"><span class="pre">LevelSet</span></code>.</p>
</div>
<div class="section" id="5.3.2-LevelSet-in-Geomstats">
<h3>5.3.2 <code class="docutils literal notranslate"><span class="pre">LevelSet</span></code> in Geomstats<a class="headerlink" href="#5.3.2-LevelSet-in-Geomstats" title="Permalink to this headline"></a></h3>
<p>You can run the code below to see the contents of the <code class="docutils literal notranslate"><span class="pre">LevelSet</span></code> class. The methods of LevelSet are similar to the methods of OpenSet , but their implementation is different. Recall from the (Local Implicit Function) definition, which <code class="docutils literal notranslate"><span class="pre">LevelSet</span></code> is an implementation of, that a manifold of this type must satisfy:</p>
<p>“For every <span class="math notranslate nohighlight">\(p \in M\)</span>, there exists an open set <span class="math notranslate nohighlight">\(U \in \mathbb{R}^{N}\)</span> and a smooth map <span class="math notranslate nohighlight">\(f: U \to \mathbb{R}^{N-d}\)</span> that is a submersion at p, such that <span class="math notranslate nohighlight">\(U \cap M = f^{-1}\)</span>({0}).”</p>
<p><code class="docutils literal notranslate"><span class="pre">OpenSet</span></code> is an implementation of the first manifold definition (Local Parametrization), and therefore need not follow the (Local Implicit Function) rule above. This is the reason that, <code class="docutils literal notranslate"><span class="pre">OpenSet</span></code> methods and <code class="docutils literal notranslate"><span class="pre">LevelSet</span></code> methods are implemented differently. As an example of these different implementations: observe the implementation of the belongs methods in <code class="docutils literal notranslate"><span class="pre">LevelSet</span></code>. For a general level set, in order to verify if a point belongs to the level set, we should verify that the (Local
Implicit Function) definition constraint is met, which is done with the line</p>
<p><code class="docutils literal notranslate"><span class="pre">constraint</span> <span class="pre">=</span> <span class="pre">gs.isclose(self.submersion(point),</span> <span class="pre">value,</span> <span class="pre">atol=atol)</span></code></p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span> In [25]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">inspect</span>

<span class="kn">from</span> <span class="nn">geomstats.geometry.base</span> <span class="kn">import</span> <span class="n">LevelSet</span>

<span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getsourcelines</span><span class="p">(</span><span class="n">LevelSet</span><span class="p">)[</span><span class="mi">0</span><span class="p">]:</span>
    <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
class LevelSet(Manifold, abc.ABC):
    &#34;&#34;&#34;Class for manifolds embedded in a vector space by a submersion.

    Parameters
    ----------
    dim : int
        Dimension of the embedded manifold.
    embedding_space : VectorSpace
        Embedding space.
    default_coords_type : str, {&#39;intrinsic&#39;, &#39;extrinsic&#39;, etc}
        Coordinate type.
        Optional, default: &#39;intrinsic&#39;.
    &#34;&#34;&#34;

    def __init__(
        self,
        dim,
        embedding_space,
        submersion,
        value,
        tangent_submersion,
        default_coords_type=&#34;intrinsic&#34;,
        **kwargs
    ):
        if &#34;shape&#34; not in kwargs:
            kwargs[&#34;shape&#34;] = embedding_space.shape
        super(LevelSet, self).__init__(
            dim=dim,
            default_point_type=embedding_space.default_point_type,
            default_coords_type=default_coords_type,
            **kwargs
        )
        self.embedding_space = embedding_space
        self.embedding_metric = embedding_space.metric
        self.submersion = submersion
        if isinstance(value, float):
            value = gs.array(value)
        self.value = value
        self.tangent_submersion = tangent_submersion

    def belongs(self, point, atol=gs.atol):
        &#34;&#34;&#34;Evaluate if a point belongs to the manifold.

        Parameters
        ----------
        point : array-like, shape=[..., dim]
            Point to evaluate.
        atol : float
            Absolute tolerance.
            Optional, default: backend atol.

        Returns
        -------
        belongs : array-like, shape=[...,]
            Boolean evaluating if point belongs to the manifold.
        &#34;&#34;&#34;
        belongs = self.embedding_space.belongs(point, atol)
        if not gs.any(belongs):
            return belongs
        value = self.value
        constraint = gs.isclose(self.submersion(point), value, atol=atol)
        if value.ndim == 2:
            constraint = gs.all(constraint, axis=(-2, -1))
        elif value.ndim == 1:
            constraint = gs.all(constraint, axis=-1)
        return gs.logical_and(belongs, constraint)

    def is_tangent(self, vector, base_point, atol=gs.atol):
        &#34;&#34;&#34;Check whether the vector is tangent at base_point.

        Parameters
        ----------
        vector : array-like, shape=[..., dim]
            Vector.
        base_point : array-like, shape=[..., dim]
            Point on the manifold.
        atol : float
            Absolute tolerance.
            Optional, default: backend atol.

        Returns
        -------
        is_tangent : bool
            Boolean denoting if vector is a tangent vector at the base point.
        &#34;&#34;&#34;
        belongs = self.embedding_space.is_tangent(vector, base_point, atol)
        tangent_sub_applied = self.tangent_submersion(vector, base_point)
        constraint = gs.isclose(tangent_sub_applied, 0.0, atol=atol)
        value = self.value
        if value.ndim == 2:
            constraint = gs.all(constraint, axis=(-2, -1))
        elif value.ndim == 1:
            constraint = gs.all(constraint, axis=-1)
        return gs.logical_and(belongs, constraint)

    def intrinsic_to_extrinsic_coords(self, point_intrinsic):
        &#34;&#34;&#34;Convert from intrinsic to extrinsic coordinates.

        Parameters
        ----------
        point_intrinsic : array-like, shape=[..., dim]
            Point in the embedded manifold in intrinsic coordinates.

        Returns
        -------
        point_extrinsic : array-like, shape=[..., dim_embedding]
            Point in the embedded manifold in extrinsic coordinates.
        &#34;&#34;&#34;
        raise NotImplementedError(&#34;intrinsic_to_extrinsic_coords is not implemented.&#34;)

    def extrinsic_to_intrinsic_coords(self, point_extrinsic):
        &#34;&#34;&#34;Convert from extrinsic to intrinsic coordinates.

        Parameters
        ----------
        point_extrinsic : array-like, shape=[..., dim_embedding]
            Point in the embedded manifold in extrinsic coordinates,
            i. e. in the coordinates of the embedding manifold.

        Returns
        -------
        point_intrinsic : array-lie, shape=[..., dim]
            Point in the embedded manifold in intrinsic coordinates.
        &#34;&#34;&#34;
        raise NotImplementedError(&#34;extrinsic_to_intrinsic_coords is not implemented.&#34;)

    @abc.abstractmethod
    def projection(self, point):
        &#34;&#34;&#34;Project a point in embedding manifold on embedded manifold.

        Parameters
        ----------
        point : array-like, shape=[..., dim_embedding]
            Point in embedding manifold.

        Returns
        -------
        projected : array-like, shape=[..., dim_embedding]
            Projected point.
        &#34;&#34;&#34;

    @abc.abstractmethod
    def to_tangent(self, vector, base_point):
        &#34;&#34;&#34;Project a vector to a tangent space of the manifold.

        Parameters
        ----------
        vector : array-like, shape=[..., dim]
            Vector.
        base_point : array-like, shape=[..., dim]
            Point on the manifold.

        Returns
        -------
        tangent_vec : array-like, shape=[..., dim]
            Tangent vector at base point.
        &#34;&#34;&#34;
</pre></div></div>
</div>
</div>
</div>
<div class="section" id="4.4-VectorSpace">
<h2>4.4 <code class="docutils literal notranslate"><span class="pre">VectorSpace</span></code><a class="headerlink" href="#4.4-VectorSpace" title="Permalink to this headline"></a></h2>
<p>A <span class="math notranslate nohighlight">\(\textit{vector space}\)</span> is a special case of manifold where a vector exists at each point.</p>
<p>Many operations defined on manifolds become simpler when the manifold is actually a vector space. Additionally, the ambient spaces used to define manifolds as open or closed sets are often vector spaces. Thus, we provide an implementation <code class="docutils literal notranslate"><span class="pre">VectorSpace</span></code>.</p>
<p>This class does not provide another way of describing a manifold. This class is an abstract class that makes sure that the ambient/embedding vector space is compatible with the methods that are called in <code class="docutils literal notranslate"><span class="pre">OpenSet</span></code> and <code class="docutils literal notranslate"><span class="pre">LevelSet</span></code>.</p>
<p>Actual manifolds are implemented as subclasses of this abstract method and must implement all the abstract methods defined in this class.</p>
<p>You can run the code below to see the contents of the <code class="docutils literal notranslate"><span class="pre">VectorSpace</span></code> class. Observe that, in a <code class="docutils literal notranslate"><span class="pre">VectorSpace</span></code> manifold, the manifold is comprised of vectors – and more specifically, tangent vectors. Thus, in the implementation, we can see that in the <code class="docutils literal notranslate"><span class="pre">is_tangent()</span></code> method: in order to check that a vector is a tangent to the manifold, we only need to check that the vector belongs to the vector space.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span> In [24]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">inspect</span>

<span class="kn">from</span> <span class="nn">geomstats.geometry.base</span> <span class="kn">import</span> <span class="n">VectorSpace</span>

<span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getsourcelines</span><span class="p">(</span><span class="n">VectorSpace</span><span class="p">)[</span><span class="mi">0</span><span class="p">]:</span>
    <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
class VectorSpace(Manifold, abc.ABC):
    &#34;&#34;&#34;Abstract class for vector spaces.

    Parameters
    ----------
    shape : tuple
        Shape of the elements of the vector space. The dimension is the
        product of these values by default.
    default_point_type : str, {&#39;vector&#39;, &#39;matrix&#39;}
        Point type.
        Optional, default: &#39;vector&#39;.
    &#34;&#34;&#34;

    def __init__(self, shape, **kwargs):
        if &#34;dim&#34; not in kwargs.keys():
            kwargs[&#34;dim&#34;] = int(gs.prod(gs.array(shape)))
        super(VectorSpace, self).__init__(shape=shape, **kwargs)
        self.shape = shape
        self._basis = None

    def belongs(self, point, atol=gs.atol):
        &#34;&#34;&#34;Evaluate if the point belongs to the vector space.

        This method checks the shape of the input point.

        Parameters
        ----------
        point : array-like, shape=[.., {dim, [n, n]}]
            Point to test.
        atol : float
            Unused here.

        Returns
        -------
        belongs : array-like, shape=[...,]
            Boolean evaluating if point belongs to the space.
        &#34;&#34;&#34;
        minimal_ndim = len(self.shape)
        belongs = point.shape[-minimal_ndim:] == self.shape
        if point.ndim &lt;= minimal_ndim:
            return belongs
        return gs.tile(gs.array([belongs]), [point.shape[0]])

    @staticmethod
    def projection(point):
        &#34;&#34;&#34;Project a point to the vector space.

        This method is for compatibility and returns `point`. `point` should
        have the right shape,

        Parameters
        ----------
        point: array-like, shape[..., {dim, [n, n]}]
            Point.

        Returns
        -------
        point: array-like, shape[..., {dim, [n, n]}]
            Point.
        &#34;&#34;&#34;
        return point

    def is_tangent(self, vector, base_point=None, atol=gs.atol):
        &#34;&#34;&#34;Check whether the vector is tangent at base_point.

        Tangent vectors are identified with points of the vector space so
        this checks the shape of the input vector.

        Parameters
        ----------
        vector : array-like, shape=[..., {dim, [n, n]}]
            Vector.
        base_point : array-like, shape=[..., {dim, [n, n]}]
            Point in the vector space.
        atol : float
            Absolute tolerance.
            Optional, default: backend atol.

        Returns
        -------
        is_tangent : bool
            Boolean denoting if vector is a tangent vector at the base point.
        &#34;&#34;&#34;
        return self.belongs(vector, atol)

    def to_tangent(self, vector, base_point=None):
        &#34;&#34;&#34;Project a vector to a tangent space of the vector space.

        This method is for compatibility and returns vector.

        Parameters
        ----------
        vector : array-like, shape=[..., {dim, [n, n]}]
            Vector.
        base_point : array-like, shape=[..., {dim, [n, n]}]
            Point in the vector space

        Returns
        -------
        tangent_vec : array-like, shape=[..., {dim, [n, n]}]
            Tangent vector at base point.
        &#34;&#34;&#34;
        return self.projection(vector)

    def random_point(self, n_samples=1, bound=1.0):
        &#34;&#34;&#34;Sample in the vector space with a uniform distribution in a box.

        Parameters
        ----------
        n_samples : int
            Number of samples.
            Optional, default: 1.
        bound : float
            Side of hypercube support of the uniform distribution.
            Optional, default: 1.0

        Returns
        -------
        point : array-like, shape=[..., dim]
           Sample.
        &#34;&#34;&#34;
        size = self.shape
        if n_samples != 1:
            size = (n_samples,) + self.shape
        point = bound * (gs.random.rand(*size) - 0.5) * 2
        return point

    @property
    def basis(self):
        &#34;&#34;&#34;Basis of the vector space.&#34;&#34;&#34;
        if self._basis is None:
            self._basis = self._create_basis()

        return self._basis

    @basis.setter
    def basis(self, basis):
        if len(basis) &lt; self.dim:
            raise ValueError(
                &#34;The basis should have length equal to the &#34; &#34;dimension of the space.&#34;
            )
        self._basis = basis

    @abc.abstractmethod
    def _create_basis(self):
        &#34;&#34;&#34;Create a canonical basis.&#34;&#34;&#34;
</pre></div></div>
</div>
</div>
<div class="section" id="4.5-ProductManifold">
<h2>4.5 <code class="docutils literal notranslate"><span class="pre">ProductManifold</span></code><a class="headerlink" href="#4.5-ProductManifold" title="Permalink to this headline"></a></h2>
<p>New manifolds can also be created by composing existing manifolds. A product manifold combines two manifolds <span class="math notranslate nohighlight">\(M_1\)</span> and <span class="math notranslate nohighlight">\(M_2\)</span> to create a new manifold <span class="math notranslate nohighlight">\(M_3\)</span>, and more generally <span class="math notranslate nohighlight">\(N\)</span> manifolds <span class="math notranslate nohighlight">\(M1, ..., M_N\)</span> can be combined to create a new manifold <span class="math notranslate nohighlight">\(M\)</span>.</p>
<div class="section" id="5.5.1-Example">
<h3>5.5.1 Example<a class="headerlink" href="#5.5.1-Example" title="Permalink to this headline"></a></h3>
<p>For example, we can create a product of two spheres as:</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span> In [25]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">geomstats.geometry.product_manifold</span> <span class="kn">import</span> <span class="n">ProductManifold</span>
<span class="n">sphere1</span> <span class="o">=</span> <span class="n">Hypersphere</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="n">sphere2</span> <span class="o">=</span> <span class="n">Hypersphere</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>


<span class="n">product_of_two_spheres</span> <span class="o">=</span> <span class="n">ProductManifold</span><span class="p">([</span><span class="n">sphere1</span><span class="p">,</span> <span class="n">sphere2</span><span class="p">])</span>
</pre></div>
</div>
</div>
<p>If we generate a random point on this product manifold, we will get 6 coordinates: the first 3 represent a point on the first sphere, and the last 3 represent a point on the second sphere:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span> In [26]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">product_of_two_spheres</span><span class="o">.</span><span class="n">random_point</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span> Out [26]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
array([-0.14573203,  0.15373756,  0.97730596, -0.349178  , -0.48842141,
        0.79969947])
</pre></div></div>
</div>
<p>You can run the code below to see the contents of the <code class="docutils literal notranslate"><span class="pre">ProductManifold</span></code> class.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span> In [23]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">inspect</span>

<span class="kn">from</span> <span class="nn">geomstats.geometry.product_manifold</span> <span class="kn">import</span> <span class="n">ProductManifold</span>

<span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getsourcelines</span><span class="p">(</span><span class="n">ProductManifold</span><span class="p">)[</span><span class="mi">0</span><span class="p">]:</span>
    <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
class ProductManifold(Manifold):
    &#34;&#34;&#34;Class for a product of manifolds M_1 x ... x M_n.

    In contrast to the classes NFoldManifold, Landmarks, or DiscretizedCurves,
    the manifolds M_1, ..., M_n need not be the same, nor of
    same dimension, but the list of manifolds needs to be provided.

    By default, a point is represented by an array of shape:
    [..., dim_1 + ... + dim_n_manifolds]
    where n_manifolds is the number of manifolds in the product.
    This type of representation is called &#39;vector&#39;.

    Alternatively, a point can be represented by an array of shape:
    [..., n_manifolds, dim] if the n_manifolds have same dimension dim.
    This type of representation is called `matrix`.

    Parameters
    ----------
    manifolds : list
        List of manifolds in the product.
    default_point_type : str, {&#39;vector&#39;, &#39;matrix&#39;}
        Default representation of points.
        Optional, default: &#39;vector&#39;.
    n_jobs : int
        Number of jobs for parallel computing.
        Optional, default: 1.
    &#34;&#34;&#34;

    # FIXME (nguigs): This only works for 1d points

    def __init__(
        self, manifolds, metrics=None, default_point_type=&#34;vector&#34;, n_jobs=1, **kwargs
    ):
        geomstats.errors.check_parameter_accepted_values(
            default_point_type, &#34;default_point_type&#34;, [&#34;vector&#34;, &#34;matrix&#34;]
        )

        self.dims = [manifold.dim for manifold in manifolds]
        if metrics is None:
            metrics = [manifold.metric for manifold in manifolds]
        metric = ProductRiemannianMetric(
            metrics, default_point_type=default_point_type, n_jobs=n_jobs
        )
        dim = sum(self.dims)
        shape = (
            (dim,) if default_point_type == &#34;vector&#34; else (len(manifolds), self.dims[0])
        )

        super(ProductManifold, self).__init__(
            dim=dim,
            shape=shape,
            metric=metric,
            default_point_type=default_point_type,
            **kwargs,
        )
        self.manifolds = manifolds
        self.n_jobs = n_jobs

    @staticmethod
    def _get_method(manifold, method_name, metric_args):
        return getattr(manifold, method_name)(**metric_args)

    def _iterate_over_manifolds(self, func, args, intrinsic=False):

        cum_index = (
            gs.cumsum(self.dims)[:-1]
            if intrinsic
            else gs.cumsum([k + 1 for k in self.dims])
        )
        arguments = {}
        float_args = {}
        for key, value in args.items():
            if not isinstance(value, float):
                arguments[key] = gs.split(value, cum_index, axis=-1)
            else:
                float_args[key] = value
        args_list = [
            {key: arguments[key][j] for key in arguments}
            for j in range(len(self.manifolds))
        ]
        pool = joblib.Parallel(n_jobs=self.n_jobs)
        out = pool(
            joblib.delayed(self._get_method)(
                self.manifolds[i], func, {**args_list[i], **float_args}
            )
            for i in range(len(self.manifolds))
        )
        return out

    def belongs(self, point, atol=gs.atol):
        &#34;&#34;&#34;Test if a point belongs to the manifold.

        Parameters
        ----------
        point : array-like, shape=[..., {dim, [n_manifolds, dim_each]}]
            Point.
        atol : float,
            Tolerance.

        Returns
        -------
        belongs : array-like, shape=[...,]
            Boolean evaluating if the point belongs to the manifold.
        &#34;&#34;&#34;
        point_type = self.default_point_type

        if point_type == &#34;vector&#34;:
            intrinsic = self.metric.is_intrinsic(point)
            belongs = self._iterate_over_manifolds(
                &#34;belongs&#34;, {&#34;point&#34;: point, &#34;atol&#34;: atol}, intrinsic
            )
            belongs = gs.stack(belongs, axis=-1)

        else:
            belongs = gs.stack(
                [
                    space.belongs(point[..., i, :], atol)
                    for i, space in enumerate(self.manifolds)
                ],
                axis=-1,
            )

        belongs = gs.all(belongs, axis=-1)
        return belongs

    def regularize(self, point):
        &#34;&#34;&#34;Regularize the point into the manifold&#39;s canonical representation.

        Parameters
        ----------
        point : array-like, shape=[..., {dim, [n_manifolds, dim_each]}]
            Point to be regularized.
        point_type : str, {&#39;vector&#39;, &#39;matrix&#39;}
            Representation of point.
            Optional, default: None.

        Returns
        -------
        regularized_point : array-like,
            shape=[..., {dim, [n_manifolds, dim_each]}]
            Point in the manifold&#39;s canonical representation.
        &#34;&#34;&#34;
        point_type = self.default_point_type

        if point_type == &#34;vector&#34;:
            intrinsic = self.metric.is_intrinsic(point)
            regularized_point = self._iterate_over_manifolds(
                &#34;regularize&#34;, {&#34;point&#34;: point}, intrinsic
            )
            regularized_point = gs.concatenate(regularized_point, axis=-1)
        elif point_type == &#34;matrix&#34;:
            regularized_point = [
                manifold_i.regularize(point[..., i, :])
                for i, manifold_i in enumerate(self.manifolds)
            ]
            regularized_point = gs.stack(regularized_point, axis=1)
        return regularized_point

    def random_point(self, n_samples=1, bound=1.0):
        &#34;&#34;&#34;Sample in the product space from the uniform distribution.

        Parameters
        ----------
        n_samples : int, optional
            Number of samples.
        bound : float
            Bound of the interval in which to sample for non compact manifolds.
            Optional, default: 1.

        Returns
        -------
        samples : array-like, shape=[..., {dim, [n_manifolds, dim_each]}]
            Points sampled on the hypersphere.
        &#34;&#34;&#34;
        point_type = self.default_point_type
        geomstats.errors.check_parameter_accepted_values(
            point_type, &#34;point_type&#34;, [&#34;vector&#34;, &#34;matrix&#34;]
        )

        if point_type == &#34;vector&#34;:
            data = self.manifolds[0].random_point(n_samples, bound)
            if len(self.manifolds) &gt; 1:
                for space in self.manifolds[1:]:
                    samples = space.random_point(n_samples, bound)
                    data = gs.concatenate([data, samples], axis=-1)
            return data

        point = [space.random_point(n_samples, bound) for space in self.manifolds]
        samples = gs.stack(point, axis=-2)
        return samples

    def projection(self, point):
        &#34;&#34;&#34;Project a point in product embedding manifold on each manifold.

        Parameters
        ----------
        point : array-like, shape=[..., {dim, [n_manifolds, dim_each]}]
            Point in embedding manifold.

        Returns
        -------
        projected : array-like, shape=[..., {dim, [n_manifolds, dim_each]}]
            Projected point.
        &#34;&#34;&#34;
        point_type = self.default_point_type
        geomstats.errors.check_parameter_accepted_values(
            point_type, &#34;point_type&#34;, [&#34;vector&#34;, &#34;matrix&#34;]
        )

        if point_type == &#34;vector&#34;:
            intrinsic = self.metric.is_intrinsic(point)
            projected_point = self._iterate_over_manifolds(
                &#34;projection&#34;, {&#34;point&#34;: point}, intrinsic
            )
            projected_point = gs.concatenate(projected_point, axis=-1)
        elif point_type == &#34;matrix&#34;:
            projected_point = [
                manifold_i.projection(point[..., i, :])
                for i, manifold_i in enumerate(self.manifolds)
            ]
            projected_point = gs.stack(projected_point, axis=-2)
        return projected_point

    def to_tangent(self, vector, base_point):
        &#34;&#34;&#34;Project a vector to a tangent space of the manifold.

        The tangent space of the product manifold is the direct sum of
        tangent spaces.

        Parameters
        ----------
        vector : array-like, shape=[..., dim]
            Vector.
        base_point : array-like, shape=[..., dim]
            Point on the manifold.

        Returns
        -------
        tangent_vec : array-like, shape=[..., dim]
            Tangent vector at base point.
        &#34;&#34;&#34;
        point_type = self.default_point_type
        geomstats.errors.check_parameter_accepted_values(
            point_type, &#34;point_type&#34;, [&#34;vector&#34;, &#34;matrix&#34;]
        )

        if point_type == &#34;vector&#34;:
            intrinsic = self.metric.is_intrinsic(base_point)
            tangent_vec = self._iterate_over_manifolds(
                &#34;to_tangent&#34;, {&#34;base_point&#34;: base_point, &#34;vector&#34;: vector}, intrinsic
            )
            tangent_vec = gs.concatenate(tangent_vec, axis=-1)
        elif point_type == &#34;matrix&#34;:
            tangent_vec = [
                manifold_i.to_tangent(vector[..., i, :], base_point[..., i, :])
                for i, manifold_i in enumerate(self.manifolds)
            ]
            tangent_vec = gs.stack(tangent_vec, axis=-2)
        return tangent_vec

    def is_tangent(self, vector, base_point, atol=gs.atol):
        &#34;&#34;&#34;Check whether the vector is tangent at base_point.

        The tangent space of the product manifold is the direct sum of
        tangent spaces.

        Parameters
        ----------
        vector : array-like, shape=[..., dim]
            Vector.
        base_point : array-like, shape=[..., dim]
            Point on the manifold.
        atol : float
            Absolute tolerance.
            Optional, default: backend atol.

        Returns
        -------
        is_tangent : bool
            Boolean denoting if vector is a tangent vector at the base point.
        &#34;&#34;&#34;
        point_type = self.default_point_type
        geomstats.errors.check_parameter_accepted_values(
            point_type, &#34;point_type&#34;, [&#34;vector&#34;, &#34;matrix&#34;]
        )

        if point_type == &#34;vector&#34;:
            intrinsic = self.metric.is_intrinsic(base_point)
            is_tangent = self._iterate_over_manifolds(
                &#34;is_tangent&#34;,
                {&#34;base_point&#34;: base_point, &#34;vector&#34;: vector, &#34;atol&#34;: atol},
                intrinsic,
            )
            is_tangent = gs.stack(is_tangent, axis=-1)

        else:
            is_tangent = gs.stack(
                [
                    space.is_tangent(
                        vector[..., i, :], base_point[..., i, :], atol=atol
                    )
                    for i, space in enumerate(self.manifolds)
                ],
                axis=-1,
            )

        is_tangent = gs.all(is_tangent, axis=-1)
        return is_tangent
</pre></div></div>
</div>
</div>
</div>
</div>
<div class="section" id="Conclusion">
<h1>Conclusion<a class="headerlink" href="#Conclusion" title="Permalink to this headline"></a></h1>
<p>Key takeaways from this notebook:</p>
<ol class="arabic simple">
<li><p>There are three ways to define a manifold, and each of these three definitions provide a different option for manifold implementation.</p></li>
<li><p>Learning to work with manifolds is useful because many datasets naturally lie on manifolds.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">Manifold</span></code> class stores information about many types of manifolds. Each of the subclasses implements a different <span class="math notranslate nohighlight">\(\textit{type}\)</span> of manifold (for example, <code class="docutils literal notranslate"><span class="pre">LevelSet</span></code>), and specific manifolds (for example, <code class="docutils literal notranslate"><span class="pre">Hypersphere</span></code>) are implemented within these subclasses.</p></li>
</ol>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="00_foundations__introduction_to_geomstats.html" class="btn btn-neutral float-left" title="What is the motivation for analyzing data on manifolds?" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="03_practical_methods__data_on_manifolds.html" class="btn btn-neutral float-right" title="Tutorial: Data on Manifolds" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022-2023, Geomstats, Inc..
      <span class="lastupdated">Last updated on May 16, 2022, 9:26:38 AM.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>
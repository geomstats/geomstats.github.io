
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>1. What is a Connection? &#8212; Geomstats latest documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=796348d33e8b1d947c94" rel="stylesheet">
<link href="../_static/styles/bootstrap.css?digest=796348d33e8b1d947c94" rel="stylesheet">
<link href="../_static/styles/pydata-sphinx-theme.css?digest=796348d33e8b1d947c94" rel="stylesheet">

  
  <link href="../_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=796348d33e8b1d947c94" rel="stylesheet">
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2">
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2">
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2">

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=796348d33e8b1d947c94">
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=796348d33e8b1d947c94">

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/sphinx_highlight.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'notebooks/02_foundations__connection_riemannian_metric';</script>
    <link rel="canonical" href="geomstats.github.io/notebooks/02_foundations__connection_riemannian_metric.html" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Stratified spaces" href="17_foundations__stratified_spaces.html" />
    <link rel="prev" title="1. Introduction" href="01_foundations__manifolds.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="docsearch:language" content="en">
  </head>
  
  
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="180" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>

  
  <input type="checkbox" class="sidebar-toggle" name="__primary" id="__primary">
  <label class="overlay overlay-primary" for="__primary"></label>

  
  <input type="checkbox" class="sidebar-toggle" name="__secondary" id="__secondary">
  <label class="overlay overlay-secondary" for="__secondary"></label>

  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
      
<form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false">
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
    </div>
  </div>

  
  <nav class="bd-header navbar navbar-expand-lg bd-navbar" id="navbar-main"><div class="bd-header__inner bd-page-width">
  <label class="sidebar-toggle primary-toggle" for="__primary">
      <span class="fa-solid fa-bars"></span>
  </label>
  <div id="navbar-start">
    
    
  


<a class="navbar-brand logo" href="../index.html">

  
  
  
  
  
  
  

  
  
    <p class="title logo__title">Geomstats latest documentation</p>
  
</a>
    
  </div>

  
  <div class="col-lg-9 navbar-header-items">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        <nav class="navbar-nav">
    <p class="sidebar-header-items__title" role="heading" aria-level="1" aria-label="Site Navigation">
        Site Navigation
    </p>
    <ul id="navbar-main-elements" class="navbar-nav">
        
                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../getting_started/index.html">
                        Getting Started
                      </a>
                    </li>
                

                    <li class="nav-item current active">
                      <a class="nav-link nav-internal" href="../explanation/index.html">
                        Explanation
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../tutorials/index.html">
                        Tutorials
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../contributing/index.html">
                        Contributing Guide
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../api/index.html">
                        API Reference
                      </a>
                    </li>
                
            <div class="nav-item dropdown">
                <button class="btn dropdown-toggle nav-item" type="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                    More
                </button>
                <div class="dropdown-menu">
                    
                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../roadmap.html">
                        Roadmap
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../governance.html">
                        Governance
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../gsod.html">
                        Google Season of Docs
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../hackathons.html">
                        Hackathons
                      </a>
                    </li>
                
                </div>
            </div>
            
    </ul>
</nav>
      </div>
      
    </div>

    <div id="navbar-end">
      
        <div class="navbar-end-item navbar-persistent--container">
          
<button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-toggle="tooltip">
  <i class="fa-solid fa-magnifying-glass"></i>
</button>
        </div>
      
      
      <div class="navbar-end-item">
        <button class="theme-switch-button btn btn-sm btn-outline-primary navbar-btn rounded-circle" title="light/dark" aria-label="light/dark" data-toggle="tooltip">
    <span class="theme-switch" data-mode="light"><i class="fa-solid fa-sun"></i></span>
    <span class="theme-switch" data-mode="dark"><i class="fa-solid fa-moon"></i></span>
    <span class="theme-switch" data-mode="auto"><i class="fa-solid fa-circle-half-stroke"></i></span>
</button>
      </div>
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
      </ul>
      </div>
      
    </div>
  </div>


  
  
    <div class="navbar-persistent--mobile">
<button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-toggle="tooltip">
  <i class="fa-solid fa-magnifying-glass"></i>
</button>
    </div>
  

  
  <label class="sidebar-toggle secondary-toggle" for="__secondary">
      <span class="fa-solid fa-outdent"></span>
  </label>
  

</div>
  </nav>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar">
        
  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
      
      <div class="navbar-center-item">
        <nav class="navbar-nav">
    <p class="sidebar-header-items__title" role="heading" aria-level="1" aria-label="Site Navigation">
        Site Navigation
    </p>
    <ul id="navbar-main-elements" class="navbar-nav">
        
                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../getting_started/index.html">
                        Getting Started
                      </a>
                    </li>
                

                    <li class="nav-item current active">
                      <a class="nav-link nav-internal" href="../explanation/index.html">
                        Explanation
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../tutorials/index.html">
                        Tutorials
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../contributing/index.html">
                        Contributing Guide
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../api/index.html">
                        API Reference
                      </a>
                    </li>
                
            <div class="nav-item dropdown">
                <button class="btn dropdown-toggle nav-item" type="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                    More
                </button>
                <div class="dropdown-menu">
                    
                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../roadmap.html">
                        Roadmap
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../governance.html">
                        Governance
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../gsod.html">
                        Google Season of Docs
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../hackathons.html">
                        Hackathons
                      </a>
                    </li>
                
                </div>
            </div>
            
    </ul>
</nav>
      </div>
      
      </div>
    

    
    
    <div class="sidebar-header-items__end">
      
      <div class="navbar-end-item">
        <button class="theme-switch-button btn btn-sm btn-outline-primary navbar-btn rounded-circle" title="light/dark" aria-label="light/dark" data-toggle="tooltip">
    <span class="theme-switch" data-mode="light"><i class="fa-solid fa-sun"></i></span>
    <span class="theme-switch" data-mode="dark"><i class="fa-solid fa-moon"></i></span>
    <span class="theme-switch" data-mode="auto"><i class="fa-solid fa-circle-half-stroke"></i></span>
</button>
      </div>
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
      </ul>
      </div>
      
    </div>
    
  </div>

  
  <div class="sidebar-start-items sidebar-primary__section">
    <div class="sidebar-start-items__item"><nav class="bd-links" id="bd-docs-nav" aria-label="Section navigation">
  <p class="bd-links__title" role="heading" aria-level="1">
    Section Navigation
  </p>
  <div class="bd-toc-item navbar-nav">
    <ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="00_foundations__introduction_to_geomstats.html">What is the motivation for analyzing data on manifolds?</a></li>

<li class="toctree-l1"><a class="reference internal" href="01_foundations__manifolds.html">1. Introduction</a></li>





<li class="toctree-l1 current active"><a class="current reference internal" href="#">1. What is a Connection?</a></li>







<li class="toctree-l1"><a class="reference internal" href="17_foundations__stratified_spaces.html">Stratified spaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="21_foundations__sub_riemannian_geometry_and_the_heisenberg_group.html">Tutorial: Sub-Riemannian geometry on the Heisenberg group</a></li>
</ul>

  </div>
</nav>
    </div>
  </div>
  

  
  <div class="sidebar-end-items sidebar-primary__section">
    <div class="sidebar-end-items__item">
    </div>
  </div>

  
  <div id="rtd-footer-container"></div>

      </div>
      <main id="main-content" class="bd-main">
        
        
        <div class="bd-content">
          <div class="bd-article-container">
            
            <div class="bd-header-article">
                
            </div>
            
            
            <article class="bd-article" role="main">
              
  
<style>
/* CSS for nbsphinx extension */

/* remove conflicting styling from Sphinx themes */
div.nbinput.container div.prompt *,
div.nboutput.container div.prompt *,
div.nbinput.container div.input_area pre,
div.nboutput.container div.output_area pre,
div.nbinput.container div.input_area .highlight,
div.nboutput.container div.output_area .highlight {
    border: none;
    padding: 0;
    margin: 0;
    box-shadow: none;
}

div.nbinput.container > div[class*=highlight],
div.nboutput.container > div[class*=highlight] {
    margin: 0;
}

div.nbinput.container div.prompt *,
div.nboutput.container div.prompt * {
    background: none;
}

div.nboutput.container div.output_area .highlight,
div.nboutput.container div.output_area pre {
    background: unset;
}

div.nboutput.container div.output_area div.highlight {
    color: unset;  /* override Pygments text color */
}

/* avoid gaps between output lines */
div.nboutput.container div[class*=highlight] pre {
    line-height: normal;
}

/* input/output containers */
div.nbinput.container,
div.nboutput.container {
    display: -webkit-flex;
    display: flex;
    align-items: flex-start;
    margin: 0;
    width: 100%;
}
@media (max-width: 540px) {
    div.nbinput.container,
    div.nboutput.container {
        flex-direction: column;
    }
}

/* input container */
div.nbinput.container {
    padding-top: 5px;
}

/* last container */
div.nblast.container {
    padding-bottom: 5px;
}

/* input prompt */
div.nbinput.container div.prompt pre {
    color: #307FC1;
}

/* output prompt */
div.nboutput.container div.prompt pre {
    color: #BF5B3D;
}

/* all prompts */
div.nbinput.container div.prompt,
div.nboutput.container div.prompt {
    width: 4.5ex;
    padding-top: 5px;
    position: relative;
    user-select: none;
}

div.nbinput.container div.prompt > div,
div.nboutput.container div.prompt > div {
    position: absolute;
    right: 0;
    margin-right: 0.3ex;
}

@media (max-width: 540px) {
    div.nbinput.container div.prompt,
    div.nboutput.container div.prompt {
        width: unset;
        text-align: left;
        padding: 0.4em;
    }
    div.nboutput.container div.prompt.empty {
        padding: 0;
    }

    div.nbinput.container div.prompt > div,
    div.nboutput.container div.prompt > div {
        position: unset;
    }
}

/* disable scrollbars and line breaks on prompts */
div.nbinput.container div.prompt pre,
div.nboutput.container div.prompt pre {
    overflow: hidden;
    white-space: pre;
}

/* input/output area */
div.nbinput.container div.input_area,
div.nboutput.container div.output_area {
    -webkit-flex: 1;
    flex: 1;
    overflow: auto;
}
@media (max-width: 540px) {
    div.nbinput.container div.input_area,
    div.nboutput.container div.output_area {
        width: 100%;
    }
}

/* input area */
div.nbinput.container div.input_area {
    border: 1px solid #e0e0e0;
    border-radius: 2px;
    /*background: #f5f5f5;*/
}

/* override MathJax center alignment in output cells */
div.nboutput.container div[class*=MathJax] {
    text-align: left !important;
}

/* override sphinx.ext.imgmath center alignment in output cells */
div.nboutput.container div.math p {
    text-align: left;
}

/* standard error */
div.nboutput.container div.output_area.stderr {
    background: #fdd;
}

/* ANSI colors */
.ansi-black-fg { color: #3E424D; }
.ansi-black-bg { background-color: #3E424D; }
.ansi-black-intense-fg { color: #282C36; }
.ansi-black-intense-bg { background-color: #282C36; }
.ansi-red-fg { color: #E75C58; }
.ansi-red-bg { background-color: #E75C58; }
.ansi-red-intense-fg { color: #B22B31; }
.ansi-red-intense-bg { background-color: #B22B31; }
.ansi-green-fg { color: #00A250; }
.ansi-green-bg { background-color: #00A250; }
.ansi-green-intense-fg { color: #007427; }
.ansi-green-intense-bg { background-color: #007427; }
.ansi-yellow-fg { color: #DDB62B; }
.ansi-yellow-bg { background-color: #DDB62B; }
.ansi-yellow-intense-fg { color: #B27D12; }
.ansi-yellow-intense-bg { background-color: #B27D12; }
.ansi-blue-fg { color: #208FFB; }
.ansi-blue-bg { background-color: #208FFB; }
.ansi-blue-intense-fg { color: #0065CA; }
.ansi-blue-intense-bg { background-color: #0065CA; }
.ansi-magenta-fg { color: #D160C4; }
.ansi-magenta-bg { background-color: #D160C4; }
.ansi-magenta-intense-fg { color: #A03196; }
.ansi-magenta-intense-bg { background-color: #A03196; }
.ansi-cyan-fg { color: #60C6C8; }
.ansi-cyan-bg { background-color: #60C6C8; }
.ansi-cyan-intense-fg { color: #258F8F; }
.ansi-cyan-intense-bg { background-color: #258F8F; }
.ansi-white-fg { color: #C5C1B4; }
.ansi-white-bg { background-color: #C5C1B4; }
.ansi-white-intense-fg { color: #A1A6B2; }
.ansi-white-intense-bg { background-color: #A1A6B2; }

.ansi-default-inverse-fg { color: #FFFFFF; }
.ansi-default-inverse-bg { background-color: #000000; }

.ansi-bold { font-weight: bold; }
.ansi-underline { text-decoration: underline; }


div.nbinput.container div.input_area div[class*=highlight] > pre,
div.nboutput.container div.output_area div[class*=highlight] > pre,
div.nboutput.container div.output_area div[class*=highlight].math,
div.nboutput.container div.output_area.rendered_html,
div.nboutput.container div.output_area > div.output_javascript,
div.nboutput.container div.output_area:not(.rendered_html) > img{
    padding: 5px;
    margin: 0;
}

/* fix copybtn overflow problem in chromium (needed for 'sphinx_copybutton') */
div.nbinput.container div.input_area > div[class^='highlight'],
div.nboutput.container div.output_area > div[class^='highlight']{
    overflow-y: hidden;
}

/* hide copybtn icon on prompts (needed for 'sphinx_copybutton') */
.prompt .copybtn {
    display: none;
}

/* Some additional styling taken form the Jupyter notebook CSS */
.jp-RenderedHTMLCommon table,
div.rendered_html table {
  border: none;
  border-collapse: collapse;
  border-spacing: 0;
  color: black;
  font-size: 12px;
  table-layout: fixed;
}
.jp-RenderedHTMLCommon thead,
div.rendered_html thead {
  border-bottom: 1px solid black;
  vertical-align: bottom;
}
.jp-RenderedHTMLCommon tr,
.jp-RenderedHTMLCommon th,
.jp-RenderedHTMLCommon td,
div.rendered_html tr,
div.rendered_html th,
div.rendered_html td {
  text-align: right;
  vertical-align: middle;
  padding: 0.5em 0.5em;
  line-height: normal;
  white-space: normal;
  max-width: none;
  border: none;
}
.jp-RenderedHTMLCommon th,
div.rendered_html th {
  font-weight: bold;
}
.jp-RenderedHTMLCommon tbody tr:nth-child(odd),
div.rendered_html tbody tr:nth-child(odd) {
  background: #f5f5f5;
}
.jp-RenderedHTMLCommon tbody tr:hover,
div.rendered_html tbody tr:hover {
  background: rgba(66, 165, 245, 0.2);
}
</style>
<div class="admonition note">
  <p>Notebook source code:
    <a class="reference external" href="https://github.com/geomstats/geomstats/blob/master/notebooks/02_foundations__connection_riemannian_metric.ipynb">notebooks/02_foundations__connection_riemannian_metric.ipynb</a>
    <br>Run it yourself on binder
    <a href="https://mybinder.org/v2/gh/geomstats/geomstats/master?filepath=notebooks/02_foundations__connection_riemannian_metric.ipynb"><img alt="Binder badge"
    src="https://mybinder.org/badge_logo.svg"
    style="vertical-align:text-bottom"></a>
  </p>
</div><p><span class="math notranslate nohighlight">\(\textbf{Lead Author: Adele Myers}\)</span></p>
<p>Inspired by: Guigui, Miolane, Pennec, 2022. Introduction to Riemannian Geometry and Geometric Statistics: from basic theory to implementation with Geomstats.</p>
<p>In this section, we will:</p>
<ol class="arabic simple">
<li><p>Define the Connection</p></li>
<li><p>Discuss parallel vector fields and parallel transport</p></li>
<li><p>Define Geodesics with the Connection</p></li>
<li><p>Define the Connection in Local Coordinates (with Christoffel Symbols)</p></li>
<li><p>Discuss Logarithms and Exponentials</p></li>
<li><p>Give an overview of the Connection Class in Geomstats</p></li>
<li><p>Discuss the RiemannianMetric subclass of the Connection Class</p></li>
</ol>
<p>This notebook provides an overview of the <span class="math notranslate nohighlight">\(\textbf{Connection}\)</span> class in Geomstats. Intuitively: a connection is a mathematical operator that tells you how much a vector will change when you move it along a manifold in the direction of another vector. The symbol for connection is <span class="math notranslate nohighlight">\(\nabla\)</span>, and <span class="math notranslate nohighlight">\(\nabla_{\vec{u}} \vec{v}\)</span> denotes how much vector <span class="math notranslate nohighlight">\(\vec{v}\)</span> would change if you moved it an infinitesimal distance in the direction of vector <span class="math notranslate nohighlight">\(\vec{u}\)</span> (see figure below).</p>
<p><img alt="8a1fae1dfd7144f7ad4d9683c6d729cc" src="../_images/conn_connection_def.png" /></p>
<section id="1.-What-is-a-Connection?">
<h1>1. What is a Connection?<a class="headerlink" href="#1.-What-is-a-Connection?" title="Permalink to this heading">#</a></h1>
<p>We will start by defining the connection <span class="math notranslate nohighlight">\(\textit{mathematically}\)</span>, and then we will define the connection again in a more <span class="math notranslate nohighlight">\(\textit{conceptual and intuitive}\)</span> way with examples.</p>
<section id="1.1-General-Mathematical-Definition-of-the-Connection">
<h2>1.1 General Mathematical Definition of the Connection<a class="headerlink" href="#1.1-General-Mathematical-Definition-of-the-Connection" title="Permalink to this heading">#</a></h2>
<p>Let <span class="math notranslate nohighlight">\(M\)</span> be a smooth manifold. A <span class="math notranslate nohighlight">\(\textbf{connection}\)</span> on <span class="math notranslate nohighlight">\(M\)</span> is an <span class="math notranslate nohighlight">\(\mathbb{R}\)</span>-bilinear map <span class="math notranslate nohighlight">\(\nabla: \Gamma (T M) \times \Gamma (T M) \to \Gamma (T M)\)</span> that verifies for all <span class="math notranslate nohighlight">\(X,Y \in \Gamma (T M), \forall f \in C^\infty(M)\)</span>:</p>
<ol class="arabic simple">
<li><p>(linearity of the <span class="math notranslate nohighlight">\(1^{st}\)</span> argument): <span class="math notranslate nohighlight">\(\nabla_{f X} Y = f \nabla_{X} Y\)</span></p></li>
<li><p>(Leibniz rule in <span class="math notranslate nohighlight">\(2^{nd}\)</span> argument): <span class="math notranslate nohighlight">\(\nabla_{X} (fY) = X(f)Y+ f\nabla_{X} Y\)</span></p></li>
</ol>
<p><span class="math notranslate nohighlight">\(\textbf{What is this saying}:\)</span></p>
<p><span class="math notranslate nohighlight">\(\textbf{1. First, let's dissect the map}\)</span> <span class="math notranslate nohighlight">\(\nabla: \Gamma (T M) \times \Gamma (T M) \to \Gamma (T M)\)</span>.</p>
<p>“<span class="math notranslate nohighlight">\(\nabla:\)</span>” - this part is saying that it is the connection (denoted <span class="math notranslate nohighlight">\(\nabla\)</span>) that is performing the transformation.</p>
<p>“<span class="math notranslate nohighlight">\(T M\)</span>” - this symbolizes the <span class="math notranslate nohighlight">\(\textbf{tangent bundle}\)</span> of the manifold <span class="math notranslate nohighlight">\(M\)</span>. A tangent bundle is the collection of all tangent spaces on the manifold <span class="math notranslate nohighlight">\(M\)</span>. A tangent bundle is itself also a manifold.</p>
<p>“<span class="math notranslate nohighlight">\(\Gamma(T M)\)</span>” - <span class="math notranslate nohighlight">\(\Gamma(T M)\)</span> denotes the space of vector fields. A single element of <span class="math notranslate nohighlight">\(\Gamma(T M)\)</span> is a single vector field on the manifold <span class="math notranslate nohighlight">\(M\)</span>. A vector field is comprised of a set of vectors on the manifold, where there is a vector at each point, and that vector is an element of the tangent space at that point (shown below).</p>
<p><img alt="539a11e6fe7e447ba0c6a28ad887d8a4" src="../_images/conn_vector_field.png" /></p>
<p>Putting all of this together, <span class="math notranslate nohighlight">\(\nabla: \Gamma (T M) \times \Gamma (T M) \to \Gamma (T M)\)</span> is simply saying that the connection is a transformation which takes two arguments, both of which are vector fields (comprised of tangent vectors), and the result of the transformation is another vector field (comprised of tangent vectors).</p>
<p><span class="math notranslate nohighlight">\(\textbf{2. Now, let's consider the conditions that the connection must satsify.}\)</span> 1. (linearity of the <span class="math notranslate nohighlight">\(1^{st}\)</span> argument): <span class="math notranslate nohighlight">\(\nabla_{f X} Y = f \nabla_{X} Y\)</span></p>
<ol class="arabic simple" start="2">
<li><p>(Leibniz rule in <span class="math notranslate nohighlight">\(2^{nd}\)</span> argument): <span class="math notranslate nohighlight">\(\nabla_{X} (fY) = X(f)Y+ f\nabla_{X} Y\)</span></p></li>
</ol>
<p>Here, there is not much to dissect mathematically, but we should wonder why the connection must satisfy the conditions. The vector field <span class="math notranslate nohighlight">\(\nabla_{X} Y\)</span> (remember <span class="math notranslate nohighlight">\(X\)</span> and <span class="math notranslate nohighlight">\(Y\)</span> are vector <span class="math notranslate nohighlight">\(\textit{fields}\)</span>) is also called the <span class="math notranslate nohighlight">\(\textbf{covariant derivative}\)</span> of <span class="math notranslate nohighlight">\(Y\)</span> with respect to <span class="math notranslate nohighlight">\(X\)</span>. If we think of <span class="math notranslate nohighlight">\(\nabla_{X}\)</span> as a derivative of some sort, then it makes sense that <span class="math notranslate nohighlight">\(\nabla_{X}\)</span> would have to follow a set of rules. Condition 1 is the equivalent
of saying <span class="math notranslate nohighlight">\(\frac{d(fX)}{dx}=f\frac{d(X)}{dx}\)</span> in euclidean space. Similarly, condition 2 is the differential geometry equivalent of the product rule: <span class="math notranslate nohighlight">\(\frac{d(u*v)}{dx}= \frac{d(u)}{dx}*v +u*\frac{d(v)}{dx}\)</span>. In summary, the connection must follow rules just as our familiar derivative must follow rules, and these rules have a similar form.</p>
</section>
<section id="1.2-What-does-the-Connection-actually-do?-–-a-more-friendly-description-of-the-connection,-with-an-example">
<h2>1.2 What does the Connection actually do? – a more friendly description of the connection, with an example<a class="headerlink" href="#1.2-What-does-the-Connection-actually-do?-–-a-more-friendly-description-of-the-connection,-with-an-example" title="Permalink to this heading">#</a></h2>
<p>Consider a single vector <span class="math notranslate nohighlight">\(\vec{a_p}\)</span>, tangent to the manifold at point <span class="math notranslate nohighlight">\(p\)</span> (shown in the figure below).</p>
<p><img alt="7cbb9265a0494352a81cd726822968f5" src="../_images/conn_single_vector.png" /></p>
<p>Now, suppose you want to see what vector <span class="math notranslate nohighlight">\(\vec{a_p}\)</span> looks like when it is translated to a different point on the manifold. You may be asking why we are placing importance on this question– because for a vector in cartesian coordinates, this question would be trivial. If you translated vector <span class="math notranslate nohighlight">\(\vec{a_p}\)</span> to a different point in cartesian coordinates, the vector itself would not change (as shown in the figure below).</p>
<p><img alt="462b300c19bc43fba76981f717435b57" src="../_images/conn_cartesian_transport.png" /></p>
<p>A spatially translated vector in cartesian coordinates does not change because the basis vectors in cartesian coordinates are translationally invariant, meaning all points in cartesian coordinates have the same set of basis vectors.</p>
<p>This is not, however, necessarily true for points on a manifold– if you move a tangent vector from one point to another (i.e. from one tangent space to another), the vector will not necessarily look the same after this transformation. (The figure below shows that when <span class="math notranslate nohighlight">\(\vec{a_p}\)</span> is translated to a different point on the manifold, it could be pointing in a direction different from its original direction.)</p>
<p><img alt="606a9193179946d5be6ecd062f99517a" src="../_images/conn_manifold_transport_problem.png" /></p>
<p>This is why the connection is such an important concept as we analyze data on manifolds. The connection helps us quantify how much a vector will change when we move it from one point to another on a manifold.</p>
<p>More specifically, the connection is able to tell us how one vector will change if it is moved in the direction of another vector. For example, if vectors <span class="math notranslate nohighlight">\(\vec{a}\)</span> and <span class="math notranslate nohighlight">\(\vec{b}\)</span> exist in the same tangent plane, then the connection <span class="math notranslate nohighlight">\(\nabla_{\vec{b}} \vec{a}\)</span> tells us how much the vector <span class="math notranslate nohighlight">\(\vec{a}\)</span> will change if it is moved an infinitesimally small distance in the direction of <span class="math notranslate nohighlight">\(\vec{b}\)</span> (shown in the figure below).</p>
<p><img alt="4f5728f981104a4381298a091d94ce03" src="../_images/conn_connection_2.png" /></p>
</section>
</section>
<section id="2.-Why-is-the-Connection-important-(big-picture)?-–-parallel-transport,-parallel-vector-fields">
<h1>2. Why is the Connection important (big picture)? – parallel transport, parallel vector fields<a class="headerlink" href="#2.-Why-is-the-Connection-important-(big-picture)?-–-parallel-transport,-parallel-vector-fields" title="Permalink to this heading">#</a></h1>
<p>The connection defines <span class="math notranslate nohighlight">\(\textit{how much a vector will change when you move it in a certain direction}\)</span>, and thus the connection also defines what it means for a vector <span class="math notranslate nohighlight">\(\textbf{not}\)</span> to change when you move it in a certain direction. (If the connection between two vectors: <span class="math notranslate nohighlight">\(\nabla_{\vec{u}} \vec{v}\)</span> is equal to zero, then <span class="math notranslate nohighlight">\(\vec{v}\)</span> does not change as you move it along <span class="math notranslate nohighlight">\(\vec{u}\)</span>.) In this section, we will use this aspect of the connection to define
<span class="math notranslate nohighlight">\(\textbf{parallel vector fields}\)</span>, which will allow us to introduce the notion of <span class="math notranslate nohighlight">\(\textbf{parallel transport}\)</span>.</p>
<p><span class="math notranslate nohighlight">\(\textbf{The Notion of &quot;Parallel&quot; in Euclidean Space-- and why this definition does not work in &quot;manifold space&quot;.}\)</span></p>
<p>In Euclidean space, we say that two vectors, <span class="math notranslate nohighlight">\(\vec{a}\)</span> and <span class="math notranslate nohighlight">\(\vec{b}\)</span> are “parallel” if they are “side by side” and have the same distance continuously between them. However, we cannot use this same notion of “parallel” on a manifold because manifolds are more complicated spaces. In fact, on a manifold, we cannot even define the notion of “distance” without equipping a manifold with something called a “metric” (which we will discuss later in this notebook).</p>
<p>Long story short: on manifolds, the word “parallel” does not hold the same simple definition that it holds in cartesian coordinates. In differential geometry, the notion of “parallel” is defined by <span class="math notranslate nohighlight">\(\textbf{parallel vector fields}\)</span>. <span class="math notranslate nohighlight">\(\textbf{Parallel vector fields}\)</span> are then used to define and construct the idea of <span class="math notranslate nohighlight">\(\textbf{parallel transport}\)</span>.</p>
<section id="2.1-Parallel-Vector-Fields">
<h2>2.1 Parallel Vector Fields<a class="headerlink" href="#2.1-Parallel-Vector-Fields" title="Permalink to this heading">#</a></h2>
<p>The connection defines <span class="math notranslate nohighlight">\(\textit{how much a vector changes when you move it in a certain direction}\)</span>, and thus the connection also defines what it means for a vector <span class="math notranslate nohighlight">\(\textbf{not}\)</span> to change when you move it in a certain direction. This will allow us to introduce the concept of a parallel vector field.</p>
<p><span class="math notranslate nohighlight">\(\textbf{1. Precise Definition of a Parallel vector field}\)</span></p>
<p>Let <span class="math notranslate nohighlight">\(M\)</span> be a smooth manifold and <span class="math notranslate nohighlight">\(\nabla\)</span> a connection on <span class="math notranslate nohighlight">\(M\)</span>. For any curve <span class="math notranslate nohighlight">\(\gamma : [a,b] \to M\)</span> in <span class="math notranslate nohighlight">\(M\)</span>, a vector fied <span class="math notranslate nohighlight">\(X\)</span> is a <span class="math notranslate nohighlight">\(''\textbf{parallel vector field}''\)</span> <span class="math notranslate nohighlight">\(\textit{along a curve}\)</span> <span class="math notranslate nohighlight">\(\gamma(t)\)</span> if</p>
<div class="math notranslate nohighlight">
\[\nabla_{\dot{\gamma}(t)} X(t)=0\]</div>
<p>where <span class="math notranslate nohighlight">\(\dot{\gamma}(t)\)</span> is a vector that is tangent to the curve <span class="math notranslate nohighlight">\(\gamma(t)\)</span>.</p>
<p><span class="math notranslate nohighlight">\(\textbf{2. What does this mean?}\)</span></p>
<p>When we say that <span class="math notranslate nohighlight">\(X\)</span> is “parallel”, you may be asking yourself “parallel to what?” because when we say that a vector is “parallel” in Euclidean space, we mean that the vector is parallel <span class="math notranslate nohighlight">\(\textit{to}\)</span> another vector. However, when we say that a <span class="math notranslate nohighlight">\(\textbf{vector field}\)</span> is <span class="math notranslate nohighlight">\(\textbf{parallel}\)</span> <span class="math notranslate nohighlight">\(\textbf{along a curve}\)</span> on a manifold, the definition of “parallel” is given by the relation above.</p>
<p>Let’s explain the definition above in words instead of math notation. First remember that a vector field <span class="math notranslate nohighlight">\(\textbf{X}\)</span> is comprised of a set of vectors <span class="math notranslate nohighlight">\(\vec{X_p} \in \textbf{T_pM}\)</span> where <span class="math notranslate nohighlight">\(p\)</span> can be any point on the manifold.</p>
<p>Now, consider a vector field <span class="math notranslate nohighlight">\(\textbf{X}\)</span> that lies along a curve <span class="math notranslate nohighlight">\(\gamma(t)\)</span>. This means that each one of the vectors in <span class="math notranslate nohighlight">\(\textbf{X}\)</span> stems from a point along <span class="math notranslate nohighlight">\(\gamma(t)\)</span>. This vector field is a <span class="math notranslate nohighlight">\(\textbf{parallel vector field}\)</span> if it satisfies:</p>
<div class="math notranslate nohighlight">
\[\nabla_{\dot{\gamma}(t)} X(t)=0.\]</div>
<p>In other words: if we were to move each point in the vector field <span class="math notranslate nohighlight">\(\textbf{X}\)</span> infinitesimally along the curve <span class="math notranslate nohighlight">\(\gamma\)</span> in the direction of <span class="math notranslate nohighlight">\(\gamma\)</span>’s tangent vector <span class="math notranslate nohighlight">\(\dot{\gamma}\)</span>, the vector field <span class="math notranslate nohighlight">\(\textbf{X}\)</span> would not change. Note that this means that in differential geometry, we can only define the term “parallel” when we define it <span class="math notranslate nohighlight">\(\textit{along a curve}\)</span>. The figure below shows that at each point <span class="math notranslate nohighlight">\(t\)</span> along the curve <span class="math notranslate nohighlight">\(\gamma\)</span>, the vector
field satisfies <span class="math notranslate nohighlight">\(\nabla_{\dot{\gamma}(t)} X(t)=0\)</span>, which means that the vector field shown in pink is a parallel vector field.</p>
<p><img alt="cd1099c6f5454db38010d4a74431c5c4" src="../_images/conn_parallel_vector_field1.jpeg" /></p>
</section>
<section id="2.2-Parallel-Transport">
<h2>2.2 Parallel Transport<a class="headerlink" href="#2.2-Parallel-Transport" title="Permalink to this heading">#</a></h2>
<p>The parallel transport of a vector <span class="math notranslate nohighlight">\(\vec{v}\)</span> along <span class="math notranslate nohighlight">\(\gamma\)</span> from point <span class="math notranslate nohighlight">\(\gamma(a)\)</span> to point <span class="math notranslate nohighlight">\(\gamma(s)\)</span> is denoted by <span class="math notranslate nohighlight">\(\vec{v'} = \prod_{\gamma,a}^s \vec{v}\)</span>. Parallel transport along a curve <span class="math notranslate nohighlight">\(\gamma\)</span> tells us what an initial tangent vector <span class="math notranslate nohighlight">\(\vec{v}\)</span> would look like if it is transported along the curve <span class="math notranslate nohighlight">\(\gamma\)</span> from point <span class="math notranslate nohighlight">\(\gamma(a)\)</span> to point <span class="math notranslate nohighlight">\(\gamma(s)\)</span>. Thus, the parallel transport tells us what a vector would look like if it was
transported from one tangent space (<span class="math notranslate nohighlight">\(T_{\gamma(a)}M\)</span>) to another tangent space (<span class="math notranslate nohighlight">\(T_{\gamma(s)}M\)</span>).</p>
<p>Conceptually, this is exactly like solving a differential equation: we can find a “solution” (in this case: the transported vector) to the equation <span class="math notranslate nohighlight">\(\nabla_{\dot \gamma(t)} X(\gamma(t)) = 0\)</span> if we are given initial conditions (in this case: an initial point and tangent vector). Note that <span class="math notranslate nohighlight">\(X(\gamma(t))\)</span> in the differential equation simply indicates that the vector field <span class="math notranslate nohighlight">\(X\)</span> is parallel along the curve <span class="math notranslate nohighlight">\(\gamma(t)\)</span>. In other words, the parallel transport calculates the
parallel vector field along the curve <span class="math notranslate nohighlight">\(\gamma(t)\)</span> and then selects the element of the vector field that lies at the final point <span class="math notranslate nohighlight">\(\gamma(s)\)</span>. The figure below shows this process.</p>
<p><img alt="c09e77ac848341f39c0113a34d645532" src="../_images/conn_parallel_transport.jpeg" /></p>
<p>Note that the connection was able to tell us how a vector would change infinitesimally if we move a vector in the direction of another vector, but here, we are able to use parallel transport to calculate how a vector will change if it is translated a <span class="math notranslate nohighlight">\(\textbf{non-infinitesimal}\)</span> distance.</p>
</section>
</section>
<section id="3.-Defining-Geodesics-with-the-Conneciton">
<h1>3. Defining Geodesics with the Conneciton<a class="headerlink" href="#3.-Defining-Geodesics-with-the-Conneciton" title="Permalink to this heading">#</a></h1>
<section id="3.1-Intuitive-Definition-of-a-Geodesic">
<h2>3.1 Intuitive Definition of a Geodesic<a class="headerlink" href="#3.1-Intuitive-Definition-of-a-Geodesic" title="Permalink to this heading">#</a></h2>
<p>To gain intuition about what a geodesic is, we can think of a geodesic as the “shortest path” between two points on a geodesic. Note, however, that at this point we cannot quantify ‘’distance’’ because we have not yet introduced Riemannian metrics yet (introduced later in this notebook). Still, we wanted to present this more intuitive definition here for readers who have never heard of a geodesic before.</p>
</section>
<section id="3.2-Defining-a-geodesic-with-the-connection">
<h2>3.2 Defining a geodesic with the connection<a class="headerlink" href="#3.2-Defining-a-geodesic-with-the-connection" title="Permalink to this heading">#</a></h2>
<p>Each point and tangent vector pair on a manifold has a unique geodesic going through it. We can use the connection and parallel vector fields to provide another definition of a geodesic. A curve is said to be “autoparallel” (and a geodesic) if</p>
<div class="math notranslate nohighlight">
\[\nabla_{\dot{\gamma}(t)} \dot{\gamma}(t)=0\]</div>
<p>is true for all <span class="math notranslate nohighlight">\(t\)</span> along the curve. This means that for each point on a geodesic, moving that point’s tangent vector in the direction of itself will not change the tangent vector.</p>
</section>
<section id="3.3-Building-Intuition-with-Physics">
<h2>3.3 Building Intuition with Physics<a class="headerlink" href="#3.3-Building-Intuition-with-Physics" title="Permalink to this heading">#</a></h2>
<p>It is difficult to comprehend why geodesics are important without examples. Physics, and general relativity in particular, provides many such examples. One of the best examples arises when we consider the paths of objects in spacetime. Spacetime is the <span class="math notranslate nohighlight">\(\textit{four-dimensional}\)</span> “fabric” that makes up the universe, and it is a manifold. Spacetime curves around masses (like planets, stars, black holes), which means that in those areas, we cannot approximate the space as being Euclidean. It
is in these spaces that we must use geodesics to predict the paths that objects will follow– because free particles (and light) follow geodesics in space.</p>
<p>In fact, telescopes have confirmed that light bends around very massive objects like black holes (shown below).</p>
<p><img alt="d46010fe1f1b4526b030706e0a01583c" src="../_images/conn_black_hole.png" /></p>
<p>This is just one example of why geodesics are crucial to understanding real-world data. Other examples exist in areas like biophysics where the trajectory of cells along a manifold may follow geodesics.</p>
</section>
</section>
<section id="4.-Description-of-Connection-in-Local-Coordinates-(using-Christoffel-Symbols)">
<h1>4. Description of Connection in Local Coordinates (using Christoffel Symbols)<a class="headerlink" href="#4.-Description-of-Connection-in-Local-Coordinates-(using-Christoffel-Symbols)" title="Permalink to this heading">#</a></h1>
<p>In <span class="math notranslate nohighlight">\(\textbf{local coordinates}\)</span>, the connection can be described mathematically using <span class="math notranslate nohighlight">\(\textbf{Christoffel Symbols}\)</span>:</p>
<div class="math notranslate nohighlight">
\[\nabla_{\partial_i} \partial_j = \Gamma_{i j}^{k} \partial_k\]</div>
<p>where <span class="math notranslate nohighlight">\(\partial_i,\partial_j\)</span> are basis vectors and elements of <span class="math notranslate nohighlight">\(T_pM\)</span> (the tangent space of some point <span class="math notranslate nohighlight">\(p\)</span> on the manifold), and <span class="math notranslate nohighlight">\(\Gamma\)</span> is called a <span class="math notranslate nohighlight">\(\textbf{Christoffel symbol}\)</span>. How ‘’local’’ is ‘’local’’? Local coordinates describe a coordinate system that is limited to an infinitely small area on a manifold. This makes sense because the connection is only defined infinitesimally.</p>
<section id="4.1-Math-Notation:-\mathbf{-\partial_i}-Basis-Vector">
<h2>4.1 Math Notation: <span class="math notranslate nohighlight">\(\mathbf{ \partial_i}\)</span> Basis Vector<a class="headerlink" href="#4.1-Math-Notation:-\mathbf{-\partial_i}-Basis-Vector" title="Permalink to this heading">#</a></h2>
<p><span class="math notranslate nohighlight">\({\partial_i}\)</span> is equivalent to <span class="math notranslate nohighlight">\(\vec{e}_i\)</span>. For example, in three dimensions, one could express the basis vectors <span class="math notranslate nohighlight">\(\hat{x}, \hat{y}, \hat{z}\)</span> as either <span class="math notranslate nohighlight">\(\vec{e}_x, \vec{e}_y, \vec{e}_z\)</span> or as <span class="math notranslate nohighlight">\(\partial_x, \partial_y, \partial_z\)</span>.</p>
<p><img alt="ed6cc252cdc04bb1a0accfffcd4c9101" src="../_images/conn_basis_vectors.png" /></p>
<p>Note/practicality: basis vectors on a manifold may differ at each point, which means that basis vectors are actually dependent on the tangent space <span class="math notranslate nohighlight">\(T_pM\)</span> to which they belong. Thus, we “should” be writing <span class="math notranslate nohighlight">\(\vec{e}_i(p)\)</span>, but in practice, the point <span class="math notranslate nohighlight">\(p\)</span> is omitted.</p>
</section>
<section id="4.2-Einstein-Notation">
<h2>4.2 Einstein Notation<a class="headerlink" href="#4.2-Einstein-Notation" title="Permalink to this heading">#</a></h2>
<p>The <span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(j\)</span> in each Christoffel symbol can index any one of the basis vectors of a space. For example, in 3D space, <span class="math notranslate nohighlight">\(i\)</span> can be <span class="math notranslate nohighlight">\(x, y,\)</span> or <span class="math notranslate nohighlight">\(z\)</span>, and <span class="math notranslate nohighlight">\(j\)</span> can be <span class="math notranslate nohighlight">\(x, y,\)</span> or <span class="math notranslate nohighlight">\(z\)</span>. The <span class="math notranslate nohighlight">\(k\)</span> in the Christoffel symbol is different because it is used in a superscript and a subscript. In Einstein notation, when a letter is used in a superscript and a subscript, this is equivalent to a sum over all basis vectors.</p>
<p>For example, if we chose <span class="math notranslate nohighlight">\(i=x\)</span> and <span class="math notranslate nohighlight">\(j=z\)</span>, then the connection statement (where the sum over <span class="math notranslate nohighlight">\(k\)</span> is stated explicitly) would read as:</p>
<div class="math notranslate nohighlight">
\[\nabla_{\partial_x} \partial_z = \Gamma_{x z}^{k} \partial_k\]</div>
<div class="math notranslate nohighlight">
\[=\Sigma_{k=x,y,z} \Gamma_{x z}^{k} \partial_k\]</div>
<div class="math notranslate nohighlight">
\[=\Gamma_{x z}^{x} \partial_x + \Gamma_{x z}^{y} \partial_y + \Gamma_{x z}^{z} \partial_z\]</div>
</section>
<section id="4.3-What-does-a-Christoffel-Symbol-represent?">
<h2>4.3 What does a Christoffel Symbol represent?<a class="headerlink" href="#4.3-What-does-a-Christoffel-Symbol-represent?" title="Permalink to this heading">#</a></h2>
<p>The best way to gain intuition of what a Christoffel symbol represents is through an example.</p>
<p>As discussed in section 1.2, the connection <span class="math notranslate nohighlight">\(\nabla_{\partial_x} \partial_z\)</span> would tell us how the basis vector <span class="math notranslate nohighlight">\(\partial_z\)</span> would change if we moved it along the manifold in the direction of <span class="math notranslate nohighlight">\(\partial_x\)</span>. Now, we know that we can represent <span class="math notranslate nohighlight">\(\nabla_{\partial_x} \partial_z\)</span> with Christoffel symbols as:</p>
<div class="math notranslate nohighlight">
\[\nabla_{\partial_x} \partial_z = \Gamma_{x z}^{x} \partial_x + \Gamma_{x z}^{y} \partial_y + \Gamma_{x z}^{z} \partial_z\]</div>
<p>so the right hand side of the equation should tell us something about the overall rate of change of <span class="math notranslate nohighlight">\(\partial_z\)</span> when we move <span class="math notranslate nohighlight">\(\partial_z\)</span> in the direction of <span class="math notranslate nohighlight">\(\partial_x\)</span>. Therefore, it seems natural that each of the Christoffel symbols would represent a rate of change. For example, <span class="math notranslate nohighlight">\(\Gamma_{x z}^{y}\)</span> tells us the rate of change (in the <span class="math notranslate nohighlight">\(\partial_y\)</span> direction) of <span class="math notranslate nohighlight">\(\partial_z\)</span> when we move <span class="math notranslate nohighlight">\(\partial_z\)</span> in the direction of <span class="math notranslate nohighlight">\(\partial_x\)</span>.</p>
</section>
<section id="4.4-The-Geodesic-Equation-in-local-coordinates">
<h2>4.4 The Geodesic Equation in local coordinates<a class="headerlink" href="#4.4-The-Geodesic-Equation-in-local-coordinates" title="Permalink to this heading">#</a></h2>
<p>The geodesic equation can also be expressed in terms of Christoffel symbols in local coordinates:</p>
<div class="math notranslate nohighlight">
\[\ddot{\gamma}^{k}(t)+\Gamma_{i j}^{k} \dot{\gamma}^{i}(t) \dot{\gamma}^{j}(t)=0.\]</div>
</section>
<section id="4.5-Why-should-we-care-about-Christoffel-Symbols-and-this-representation-of-the-connection?">
<h2>4.5 Why should we care about Christoffel Symbols and this representation of the connection?<a class="headerlink" href="#4.5-Why-should-we-care-about-Christoffel-Symbols-and-this-representation-of-the-connection?" title="Permalink to this heading">#</a></h2>
<p>The ability to represent the connection with Christoffel symbols is <span class="math notranslate nohighlight">\(\textit{essential}\)</span> because Christoffel symbols are something we can actually compute. Up until now, we have presented somewhat abstract formulae with no actual method for computation. Now, with Christoffel symbols, we can compute actual values for the connection. We do not yet have the tools to calculate Christoffel symbols at this point in our tutorial, but we will learn later in the notebook.</p>
</section>
</section>
<section id="5.-Additional-Important-Mathematical-concepts-utilized-by-Connection-Class:-Logarithm,-Exponential">
<h1>5. Additional Important Mathematical concepts utilized by <code class="docutils literal notranslate"><span class="pre">Connection</span></code> Class: Logarithm, Exponential<a class="headerlink" href="#5.-Additional-Important-Mathematical-concepts-utilized-by-Connection-Class:-Logarithm,-Exponential" title="Permalink to this heading">#</a></h1>
<p>In Euclidean space, addition and subtraction allow us to operate on initial points to generate new points. On manifolds, exponentials and logarithms allow us to operate on points and/or tangent vectors to get new points or tangent vectors.</p>
<section id="Exponentials-on-Manifolds">
<h2>Exponentials on Manifolds<a class="headerlink" href="#Exponentials-on-Manifolds" title="Permalink to this heading">#</a></h2>
<p>In Euclidean space, <span class="math notranslate nohighlight">\(\textit{addition}\)</span> is a tool which takes two points <span class="math notranslate nohighlight">\(p_1, p_2\)</span>, “adds” them, and generates a third, larger point <span class="math notranslate nohighlight">\(p_3\)</span> (as shown in the figure below). Addition gives us a way to “move forward” in Euclidean space.</p>
<p><img alt="1af556ba1d784477964ddbdf5c6e1a84" src="../_images/conn_addition.png" /></p>
<p>On manifolds, the <span class="math notranslate nohighlight">\(\textit{exponential}\)</span> provides a tool which “takes the exponential of the tangent vector at point <span class="math notranslate nohighlight">\(p\)</span>” to generate a third point on the manifold. The exponential does this by 1) identifying the unique geodesic <span class="math notranslate nohighlight">\(\gamma\)</span> that goes through <span class="math notranslate nohighlight">\(p\)</span> and <span class="math notranslate nohighlight">\(v_p\)</span>, 2) identifying the “length” <span class="math notranslate nohighlight">\(l\)</span> of the tangent vector <span class="math notranslate nohighlight">\(v_p\)</span>, and 3) calculating another point <span class="math notranslate nohighlight">\(p'\)</span> along <span class="math notranslate nohighlight">\(\gamma(t)\)</span> that is a “distance” <span class="math notranslate nohighlight">\(l\)</span> from the initial point
<span class="math notranslate nohighlight">\(p\)</span> (see figure below). Note again that the notion of “length” and “distance” is different on a manifold than it is in Euclidean space and that quantifying length is not something that we will be able to do without specifying a metric (discussed in <code class="docutils literal notranslate"><span class="pre">RiemannianMetric</span></code> section).</p>
<p><img alt="8943e7471693481f8c80762e31fa6078" src="../_images/conn_exponential.png" /></p>
<p>The exponential is often described as being the “differential geometry version” of addition.</p>
</section>
<section id="Logarithms-on-Manifolds">
<h2>Logarithms on Manifolds<a class="headerlink" href="#Logarithms-on-Manifolds" title="Permalink to this heading">#</a></h2>
<p>In Euclidean space, <span class="math notranslate nohighlight">\(\textit{subtraction}\)</span> is an operation which allows us to take the third point <span class="math notranslate nohighlight">\(p_3\)</span> and one of the initial points <span class="math notranslate nohighlight">\(p_1\)</span> and extract the other initial point <span class="math notranslate nohighlight">\(p_2\)</span> (as shown in the figure below).</p>
<p><img alt="d0b27f3f80894f9f9217fe261b900148" src="../_images/conn_subtraction.png" /></p>
<p>Similarly, the <span class="math notranslate nohighlight">\(\textit{logarithm}\)</span> allows us to take the final point <span class="math notranslate nohighlight">\(p'\)</span> and the initial point <span class="math notranslate nohighlight">\(p\)</span> to extract the tangent vector <span class="math notranslate nohighlight">\(v_p\)</span> at the initial point. The logarithm is able to do this by 1) identifying the unique geodesic <span class="math notranslate nohighlight">\(\gamma\)</span> that connects the two points 2) calculating the “length” of that geodesic 3) generating the unique tangent vector at <span class="math notranslate nohighlight">\(p\)</span>, with a “length” equal to that of the geodesic (shown in the figure below). Again, remember that
“length” is not something that we can quantify without specifying a metric, which we will not be able to do until the <code class="docutils literal notranslate"><span class="pre">RiemannianMetric</span></code> section.</p>
<p>A key point here is that if you know a point and a tangent vector at that point, you can calculate a unique geodesic that goes through that point, and similarly, if you know the point and geodesic, you should be able to extract the unique tangent vector that produced that geodesic.</p>
<p><img alt="7082c84fd25e4670a935cb9bcd45fb0b" src="../_images/conn_logarithm.png" /></p>
<p>The logarithm is the inverse map of the exponential and is often described as being the “differential geometry version” of subtraction.</p>
</section>
</section>
<section id="6.-Geomstats-Documentation:-The-Connection-Class">
<h1>6. Geomstats Documentation: The <code class="docutils literal notranslate"><span class="pre">Connection</span></code> Class<a class="headerlink" href="#6.-Geomstats-Documentation:-The-Connection-Class" title="Permalink to this heading">#</a></h1>
<p>The <code class="docutils literal notranslate"><span class="pre">Connection</span></code> class in geomstats has four methods and one subclass, whose structure is shown below:</p>
<p><img alt="3f03eeee449d418c8b039b21aaa8b838" src="../_images/conn_connection_hierarchy_1.png" /></p>
<p>The methods of the <code class="docutils literal notranslate"><span class="pre">Connection</span></code> class also equip the <code class="docutils literal notranslate"><span class="pre">RiemannianMetric</span></code> subclass with the tools it needs to perform calculations on manifolds (we will discuss the <code class="docutils literal notranslate"><span class="pre">RiemannianMetric</span></code> class later in this notebook).</p>
<p>We will first print the key methods of the <code class="docutils literal notranslate"><span class="pre">Connection</span></code> class, and then at the end we will print the entire connection class for anyone who is interested.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span> In [1]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()))</span>
<span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>

<span class="kn">import</span> <span class="nn">geomstats.backend</span> <span class="k">as</span> <span class="nn">gs</span>

<span class="n">gs</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">2020</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area stderr docutils container">
<div class="highlight"><pre>
INFO: Using numpy backend
</pre></div></div>
</div>
<section id="6.1-method:-parallel_transport()">
<h2>6.1 method: <code class="docutils literal notranslate"><span class="pre">parallel_transport()</span></code><a class="headerlink" href="#6.1-method:-parallel_transport()" title="Permalink to this heading">#</a></h2>
<p>This is the method in the <code class="docutils literal notranslate"><span class="pre">Connection</span></code> class which calculates the parallel transport of a given tangent vector, in the direction of another tangent vector. Run the following code to see the <code class="docutils literal notranslate"><span class="pre">parallel_transport</span></code> method in Geomstats:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span> In [6]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">inspect</span>

<span class="kn">from</span> <span class="nn">geomstats.geometry.connection</span> <span class="kn">import</span> <span class="n">Connection</span>
<span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getsourcelines</span><span class="p">(</span><span class="n">Connection</span><span class="o">.</span><span class="n">parallel_transport</span><span class="p">)[</span><span class="mi">0</span><span class="p">]:</span>
    <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
<br/></pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
    def parallel_transport(
        self, tangent_vec, base_point, direction=None, end_point=None
    ):
        r&#34;&#34;&#34;Compute the parallel transport of a tangent vector.

        Closed-form solution for the parallel transport of a tangent vector
        along the geodesic between two points `base_point` and `end_point`
        or alternatively defined by :math:`t\mapsto exp_(base_point)(
        t*direction)`.

        Parameters
        ----------
        tangent_vec : array-like, shape=[..., {dim, [n, m]}]
            Tangent vector at base point to be transported.
        base_point : array-like, shape=[..., {dim, [n, m]}]
            Point on the manifold. Point to transport from.
        direction : array-like, shape=[..., {dim, [n, m]}]
            Tangent vector at base point, along which the parallel transport
            is computed.
            Optional, default: None.
        end_point : array-like, shape=[..., {dim, [n, m]}]
            Point on the manifold. Point to transport to.
            Optional, default: None.

        Returns
        -------
        transported_tangent_vec: array-like, shape=[..., {dim, [n, m]}]
            Transported tangent vector at `exp_(base_point)(tangent_vec_b)`.
        &#34;&#34;&#34;
        raise NotImplementedError(
            &#34;The closed-form solution of parallel transport is not known, &#34;
            &#34;use the ladder_parallel_transport instead.&#34;
        )
</pre></div></div>
</div>
</section>
<section id="6.2-method:-geodesic_equation()">
<h2>6.2 method: <code class="docutils literal notranslate"><span class="pre">geodesic_equation()</span></code><a class="headerlink" href="#6.2-method:-geodesic_equation()" title="Permalink to this heading">#</a></h2>
<p>This is the method in the <code class="docutils literal notranslate"><span class="pre">Connection</span></code> class which calculates the geodesic that a given tangent vector will follow on the manifold. In this code, note the use of the christoffel symbols that allows us to give the expression of the geodesic equation in local coordinates. Also note the use of the function “einsum” which refers to the Einstein summation that we described above. Run the code below to see the <code class="docutils literal notranslate"><span class="pre">geodesic_equation</span></code> method in Geomstats.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span> In [4]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">inspect</span>

<span class="kn">from</span> <span class="nn">geomstats.geometry.connection</span> <span class="kn">import</span> <span class="n">Connection</span>
<span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getsourcelines</span><span class="p">(</span><span class="n">Connection</span><span class="o">.</span><span class="n">geodesic_equation</span><span class="p">)[</span><span class="mi">0</span><span class="p">]:</span>
    <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
    def geodesic_equation(self, state, _time):
        &#34;&#34;&#34;Compute the geodesic ODE associated with the connection.

        Parameters
        ----------
        state : array-like, shape=[..., dim]
            Tangent vector at the position.
        _time : array-like, shape=[..., dim]
            Point on the manifold, the position at which to compute the
            geodesic ODE.

        Returns
        -------
        geodesic_ode : array-like, shape=[..., dim]
            Value of the vector field to be integrated at position.
        &#34;&#34;&#34;
        position, velocity = state
        gamma = self.christoffels(position)
        equation = gs.einsum(&#34;...kij,...i-&gt;...kj&#34;, gamma, velocity)
        equation = -gs.einsum(&#34;...kj,...j-&gt;...k&#34;, equation, velocity)
        return gs.stack([velocity, equation])
</pre></div></div>
</div>
</section>
<section id="6.3-method:-exp()-(exponential)">
<h2>6.3 method: <code class="docutils literal notranslate"><span class="pre">exp()</span></code> (exponential)<a class="headerlink" href="#6.3-method:-exp()-(exponential)" title="Permalink to this heading">#</a></h2>
<p>This is the method in the <code class="docutils literal notranslate"><span class="pre">Connection</span></code> class which computes the exponential of a point and a vector on a manifold. Run the following code to see the <code class="docutils literal notranslate"><span class="pre">exp</span></code> method in Geomstats:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span> In [2]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">inspect</span>

<span class="kn">from</span> <span class="nn">geomstats.geometry.connection</span> <span class="kn">import</span> <span class="n">Connection</span>
<span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getsourcelines</span><span class="p">(</span><span class="n">Connection</span><span class="o">.</span><span class="n">exp</span><span class="p">)[</span><span class="mi">0</span><span class="p">]:</span>
    <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
    def exp(
        self,
        tangent_vec,
        base_point,
        n_steps=N_STEPS,
        step=&#34;euler&#34;,
        point_type=None,
        **kwargs
    ):
        &#34;&#34;&#34;Exponential map associated to the affine connection.

        Exponential map at base_point of tangent_vec computed by integration
        of the geodesic equation (initial value problem), using the
        christoffel symbols.

        Parameters
        ----------
        tangent_vec : array-like, shape=[..., dim]
            Tangent vector at the base point.
        base_point : array-like, shape=[..., dim]
            Point on the manifold.
        n_steps : int
            Number of discrete time steps to take in the integration.
            Optional, default: N_STEPS.
        step : str, {&#39;euler&#39;, &#39;rk4&#39;}
            The numerical scheme to use for integration.
            Optional, default: &#39;euler&#39;.
        point_type : str, {&#39;vector&#39;, &#39;matrix&#39;}
            Type of representation used for points.
            Optional, default: None.

        Returns
        -------
        exp : array-like, shape=[..., dim]
            Point on the manifold.
        &#34;&#34;&#34;
        base_point = gs.broadcast_to(base_point, tangent_vec.shape)

        initial_state = gs.stack([base_point, tangent_vec])

        flow = integrate(
            self.geodesic_equation, initial_state, n_steps=n_steps, step=step
        )

        exp = flow[-1][0]
        return exp
</pre></div></div>
</div>
</section>
<section id="6.4-method:-log()-(logarithm)">
<h2>6.4 method: <code class="docutils literal notranslate"><span class="pre">log()</span></code> (logarithm)<a class="headerlink" href="#6.4-method:-log()-(logarithm)" title="Permalink to this heading">#</a></h2>
<p>This is the method in the <code class="docutils literal notranslate"><span class="pre">Connection</span></code> class which computes the logarithm of two points on a manifold. Run the following code to see the <code class="docutils literal notranslate"><span class="pre">log</span></code> method in Geomstats:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span> In [7]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">inspect</span>

<span class="kn">from</span> <span class="nn">geomstats.geometry.connection</span> <span class="kn">import</span> <span class="n">Connection</span>
<span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getsourcelines</span><span class="p">(</span><span class="n">Connection</span><span class="o">.</span><span class="n">log</span><span class="p">)[</span><span class="mi">0</span><span class="p">]:</span>
    <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
    def log(
        self,
        point,
        base_point,
        n_steps=N_STEPS,
        step=&#34;euler&#34;,
        max_iter=25,
        verbose=False,
        tol=gs.atol,
    ):
        &#34;&#34;&#34;Compute logarithm map associated to the affine connection.

        Solve the boundary value problem associated to the geodesic equation
        using the Christoffel symbols and conjugate gradient descent.

        Parameters
        ----------
        point : array-like, shape=[..., dim]
            Point on the manifold.
        base_point : array-like, shape=[..., dim]
            Point on the manifold.
        n_steps : int
            Number of discrete time steps to take in the integration.
            Optional, default: N_STEPS.
        step : str, {&#39;euler&#39;, &#39;rk4&#39;}
            Numerical scheme to use for integration.
            Optional, default: &#39;euler&#39;.
        max_iter
        verbose
        tol

        Returns
        -------
        tangent_vec : array-like, shape=[..., dim]
            Tangent vector at the base point.
        &#34;&#34;&#34;
        max_shape = point.shape
        if len(point.shape) &lt;= len(base_point.shape):
            max_shape = base_point.shape

        def objective(velocity):
            &#34;&#34;&#34;Define the objective function.&#34;&#34;&#34;
            velocity = gs.array(velocity)
            velocity = gs.cast(velocity, dtype=base_point.dtype)
            velocity = gs.reshape(velocity, max_shape)
            delta = self.exp(velocity, base_point, n_steps, step) - point
            return gs.sum(delta**2)

        objective_with_grad = gs.autodiff.value_and_grad(objective, to_numpy=True)

        tangent_vec = gs.flatten(gs.random.rand(*max_shape))

        res = minimize(
            objective_with_grad,
            tangent_vec,
            method=&#34;L-BFGS-B&#34;,
            jac=True,
            options={&#34;disp&#34;: verbose, &#34;maxiter&#34;: max_iter},
            tol=tol,
        )

        tangent_vec = gs.array(res.x)
        tangent_vec = gs.reshape(tangent_vec, max_shape)
        tangent_vec = gs.cast(tangent_vec, dtype=base_point.dtype)
        return tangent_vec
</pre></div></div>
</div>
</section>
<section id="6.5-The-full-Connection-class">
<h2>6.5 The full <code class="docutils literal notranslate"><span class="pre">Connection</span></code> class<a class="headerlink" href="#6.5-The-full-Connection-class" title="Permalink to this heading">#</a></h2>
<p>Run the code below to see the entire code for the <code class="docutils literal notranslate"><span class="pre">Connection</span></code> class:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span> In [4]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">inspect</span>

<span class="kn">from</span> <span class="nn">geomstats.geometry.connection</span> <span class="kn">import</span> <span class="n">Connection</span>
<span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getsourcelines</span><span class="p">(</span><span class="n">Connection</span><span class="p">)[</span><span class="mi">0</span><span class="p">]:</span>
    <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
<br/></pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
class Connection(ABC):
    r&#34;&#34;&#34;Class for affine connections.

    Parameters
    ----------
    dim : int
        Dimension of the underlying manifold.
    shape : tuple of int
        Shape of one element of the manifold.
        Optional, default : (dim, ).
    default_point_type : str, {\&#39;vector\&#39;, \&#39;matrix\&#39;}
        Point type.
        Optional, default: \&#39;vector\&#39;.
    default_coords_type : str, {\&#39;intrinsic\&#39;, \&#39;extrinsic\&#39;, etc}
        Coordinate type.
        Optional, default: \&#39;intrinsic\&#39;.
    &#34;&#34;&#34;

    def __init__(
        self, dim, shape=None, default_point_type=None, default_coords_type=&#34;intrinsic&#34;
    ):
        if shape is None:
            shape = (dim,)
        if default_point_type is None:
            default_point_type = POINT_TYPES[len(shape)]

        geomstats.errors.check_integer(dim, &#34;dim&#34;)
        geomstats.errors.check_parameter_accepted_values(
            default_point_type, &#34;default_point_type&#34;, [&#34;vector&#34;, &#34;matrix&#34;]
        )

        self.dim = dim
        self.shape = shape
        self.default_point_type = default_point_type
        self.default_coords_type = default_coords_type

    def christoffels(self, base_point):
        &#34;&#34;&#34;Christoffel symbols associated with the connection.

        Parameters
        ----------
        base_point : array-like, shape=[..., dim]
            Point on the manifold.

        Returns
        -------
        gamma : array-like, shape=[..., dim, dim, dim]
            Christoffel symbols, with the contravariant index on
            the first dimension.
        &#34;&#34;&#34;
        raise NotImplementedError(&#34;The Christoffel symbols are not implemented.&#34;)

    def geodesic_equation(self, state, _time):
        &#34;&#34;&#34;Compute the geodesic ODE associated with the connection.

        Parameters
        ----------
        state : array-like, shape=[..., dim]
            Tangent vector at the position.
        _time : array-like, shape=[..., dim]
            Point on the manifold, the position at which to compute the
            geodesic ODE.

        Returns
        -------
        geodesic_ode : array-like, shape=[..., dim]
            Value of the vector field to be integrated at position.
        &#34;&#34;&#34;
        position, velocity = state
        gamma = self.christoffels(position)
        equation = gs.einsum(&#34;...kij,...i-&gt;...kj&#34;, gamma, velocity)
        equation = -gs.einsum(&#34;...kj,...j-&gt;...k&#34;, equation, velocity)
        return gs.stack([velocity, equation])

    def exp(
        self,
        tangent_vec,
        base_point,
        n_steps=N_STEPS,
        step=&#34;euler&#34;,
        point_type=None,
        **kwargs
    ):
        &#34;&#34;&#34;Exponential map associated to the affine connection.

        Exponential map at base_point of tangent_vec computed by integration
        of the geodesic equation (initial value problem), using the
        christoffel symbols.

        Parameters
        ----------
        tangent_vec : array-like, shape=[..., dim]
            Tangent vector at the base point.
        base_point : array-like, shape=[..., dim]
            Point on the manifold.
        n_steps : int
            Number of discrete time steps to take in the integration.
            Optional, default: N_STEPS.
        step : str, {&#39;euler&#39;, &#39;rk4&#39;}
            The numerical scheme to use for integration.
            Optional, default: &#39;euler&#39;.
        point_type : str, {&#39;vector&#39;, &#39;matrix&#39;}
            Type of representation used for points.
            Optional, default: None.

        Returns
        -------
        exp : array-like, shape=[..., dim]
            Point on the manifold.
        &#34;&#34;&#34;
        initial_state = gs.stack([base_point, tangent_vec])
        flow = integrate(
            self.geodesic_equation, initial_state, n_steps=n_steps, step=step
        )

        exp = flow[-1][0]
        return exp

    def log(
        self,
        point,
        base_point,
        n_steps=N_STEPS,
        step=&#34;euler&#34;,
        max_iter=25,
        verbose=False,
        tol=gs.atol,
    ):
        &#34;&#34;&#34;Compute logarithm map associated to the affine connection.

        Solve the boundary value problem associated to the geodesic equation
        using the Christoffel symbols and conjugate gradient descent.

        Parameters
        ----------
        point : array-like, shape=[..., dim]
            Point on the manifold.
        base_point : array-like, shape=[..., dim]
            Point on the manifold.
        n_steps : int
            Number of discrete time steps to take in the integration.
            Optional, default: N_STEPS.
        step : str, {&#39;euler&#39;, &#39;rk4&#39;}
            Numerical scheme to use for integration.
            Optional, default: &#39;euler&#39;.
        max_iter
        verbose
        tol

        Returns
        -------
        tangent_vec : array-like, shape=[..., dim]
            Tangent vector at the base point.
        &#34;&#34;&#34;
        max_shape = point.shape
        if len(point.shape) &lt;= len(base_point.shape):
            max_shape = base_point.shape

        def objective(velocity):
            &#34;&#34;&#34;Define the objective function.&#34;&#34;&#34;
            velocity = gs.array(velocity)
            velocity = gs.cast(velocity, dtype=base_point.dtype)
            velocity = gs.reshape(velocity, max_shape)
            delta = self.exp(velocity, base_point, n_steps, step) - point
            return gs.sum(delta**2)

        objective_with_grad = gs.autodiff.value_and_grad(objective, to_numpy=True)

        tangent_vec = gs.flatten(gs.random.rand(*max_shape))

        res = minimize(
            objective_with_grad,
            tangent_vec,
            method=&#34;L-BFGS-B&#34;,
            jac=True,
            options={&#34;disp&#34;: verbose, &#34;maxiter&#34;: max_iter},
            tol=tol,
        )

        tangent_vec = gs.array(res.x)
        tangent_vec = gs.reshape(tangent_vec, max_shape)
        tangent_vec = gs.cast(tangent_vec, dtype=base_point.dtype)
        return tangent_vec

    def _pole_ladder_step(
        self, base_point, next_point, base_shoot, return_geodesics=False, **kwargs
    ):
        &#34;&#34;&#34;Compute one Pole Ladder step.

        One step of pole ladder scheme [LP2013a]_ using the geodesic to
        transport along as main_geodesic of the parallelogram.

        Parameters
        ----------
        base_point : array-like, shape=[..., dim]
            Point on the manifold, from which to transport.
        next_point : array-like, shape=[..., dim]
            Point on the manifold, to transport to.
        base_shoot : array-like, shape=[..., dim]
            Point on the manifold, end point of the geodesics starting
            from the base point with initial speed to be transported.
        return_geodesics : bool, optional (defaults to False)
            Whether to return the geodesics of the
            construction.

        Returns
        -------
        next_step : dict of array-like and callable with following keys:
            next_tangent_vec : array-like, shape=[..., dim]
                Tangent vector at end point.
            end_point : array-like, shape=[..., dim]
                Point on the manifold, closes the geodesic parallelogram of the
                construction.
            geodesics : list of callable, len=3 (only if
            `return_geodesics=True`)
                Three geodesics of the construction.

        References
        ----------
        .. [LP2013a] Marco Lorenzi, Xavier Pennec. Efficient Parallel Transport
         of Deformations in Time Series of Images: from Schild&#39;s to
         Pole Ladder. Journal of Mathematical Imaging and Vision, Springer
         Verlag, 2013,50 (1-2), pp.5-17. ⟨10.1007/s10851-013-0470-3⟩
        &#34;&#34;&#34;
        mid_tangent_vector_to_shoot = (
            1.0 / 2.0 * self.log(base_point=base_point, point=next_point, **kwargs)
        )

        mid_point = self.exp(
            base_point=base_point, tangent_vec=mid_tangent_vector_to_shoot, **kwargs
        )

        tangent_vector_to_shoot = -self.log(
            base_point=mid_point, point=base_shoot, **kwargs
        )

        end_shoot = self.exp(
            base_point=mid_point, tangent_vec=tangent_vector_to_shoot, **kwargs
        )

        geodesics = []
        if return_geodesics:
            main_geodesic = self.geodesic(
                initial_point=base_point, end_point=next_point
            )
            diagonal = self.geodesic(initial_point=mid_point, end_point=base_shoot)
            final_geodesic = self.geodesic(
                initial_point=next_point, end_point=end_shoot
            )
            geodesics = [main_geodesic, diagonal, final_geodesic]
        return {&#34;geodesics&#34;: geodesics, &#34;end_point&#34;: end_shoot}

    def _schild_ladder_step(
        self, base_point, next_point, base_shoot, return_geodesics=False, **kwargs
    ):
        &#34;&#34;&#34;Compute one Schild&#39;s Ladder step.

        One step of the Schild&#39;s ladder scheme [LP2013a]_ using the geodesic to
        transport along as one side of the parallelogram.

        Parameters
        ----------
        base_point : array-like, shape=[..., dim]
            Point on the manifold, from which to transport.
        next_point : array-like, shape=[..., dim]
            Point on the manifold, to transport to.
        base_shoot : array-like, shape=[..., dim]
            Point on the manifold, end point of the geodesics starting
            from the base point with initial speed to be transported.
        return_geodesics : bool
            Whether to return points computed along each geodesic of the
            construction.
            Optional, default: False.

        Returns
        -------
        transported_tangent_vector : array-like, shape=[..., dim]
            Tangent vector at end point.
        end_point : array-like, shape=[..., dim]
            Point on the manifold, closes the geodesic parallelogram of the
            construction.

        References
        ----------
        .. [LP2013a] Marco Lorenzi, Xavier Pennec. Efficient Parallel Transport
         of Deformations in Time Series of Images: from Schild&#39;s to
         Pole Ladder. Journal of Mathematical Imaging and Vision, Springer
         Verlag, 2013,50 (1-2), pp.5-17. ⟨10.1007/s10851-013-0470-3⟩
        &#34;&#34;&#34;
        mid_tangent_vector_to_shoot = (
            1.0 / 2.0 * self.log(base_point=base_shoot, point=next_point, **kwargs)
        )

        mid_point = self.exp(
            base_point=base_shoot, tangent_vec=mid_tangent_vector_to_shoot, **kwargs
        )

        tangent_vector_to_shoot = -self.log(
            base_point=mid_point, point=base_point, **kwargs
        )

        end_shoot = self.exp(
            base_point=mid_point, tangent_vec=tangent_vector_to_shoot, **kwargs
        )

        geodesics = []
        if return_geodesics:
            main_geodesic = self.geodesic(
                initial_point=base_point, end_point=next_point
            )
            diagonal = self.geodesic(initial_point=base_point, end_point=end_shoot)
            second_diagonal = self.geodesic(
                initial_point=base_shoot, end_point=next_point
            )
            final_geodesic = self.geodesic(
                initial_point=next_point, end_point=end_shoot
            )
            geodesics = [main_geodesic, diagonal, second_diagonal, final_geodesic]
        return {&#34;geodesics&#34;: geodesics, &#34;end_point&#34;: end_shoot}

    def ladder_parallel_transport(
        self,
        tangent_vec,
        base_point,
        direction,
        n_rungs=1,
        scheme=&#34;pole&#34;,
        alpha=1,
        **single_step_kwargs
    ):
        &#34;&#34;&#34;Approximate parallel transport using the pole ladder scheme.

        Approximate Parallel transport using either the pole ladder or the
        Schild&#39;s ladder scheme [LP2013b]_. Pole ladder is exact in symmetric
        spaces and of order two in general while Schild&#39;s ladder is a first
        order approximation [GP2020]_. Both schemes are available on any affine
        connection manifolds whose exponential and logarithm maps are
        implemented. `tangent_vec` is transported along the geodesic starting
        at the base_point with initial tangent vector `direction`.

        Parameters
        ----------
        tangent_vec : array-like, shape=[..., dim]
            Tangent vector at base point to transport.
        direction : array-like, shape=[..., dim]
            Tangent vector at base point, initial speed of the geodesic along
            which to transport.
        base_point : array-like, shape=[..., dim]
            Point on the manifold, initial position of the geodesic along
            which to transport.
        n_rungs : int
            Number of steps of the ladder.
            Optional, default: 1.
        scheme : str, {&#39;pole&#39;, &#39;schild&#39;}
            The scheme to use for the construction of the ladder at each step.
            Optional, default: &#39;pole&#39;.
        alpha : float
            Exponent for the scaling of the vector to transport. Must be
            greater or equal to 1, 2 is optimal. See [GP2020]_.
            Optional, default: 2
        **single_step_kwargs : keyword arguments for the step functions

        Returns
        -------
        ladder : dict of array-like and callable with following keys
            transported_tangent_vector : array-like, shape=[..., dim]
                Approximation of the parallel transport of tangent vector a.
            trajectory : list of list of callable, len=n_steps
                List of lists containing the geodesics of the
                construction, only if `return_geodesics=True` in the step
                function. The geodesics are methods of the class connection.

        References
        ----------
        .. [LP2013b] Lorenzi, Marco, and Xavier Pennec. “Efficient Parallel
        Transport of Deformations in Time Series of Images: From Schild to
        Pole Ladder.” Journal of Mathematical Imaging and Vision 50, no. 1
        (September 1, 2014): 5–17. https://doi.org/10.1007/s10851-013-0470-3.


        .. [GP2020] Guigui, Nicolas, and Xavier Pennec. “Numerical Accuracy
        of Ladder Schemes for Parallel Transport on Manifolds.”
        Foundations of Computational Mathematics, June 18, 2021.
        https://doi.org/10.1007/s10208-021-09515-x.
        &#34;&#34;&#34;
        geomstats.errors.check_integer(n_rungs, &#34;n_rungs&#34;)
        if alpha &lt; 1:
            raise ValueError(&#34;alpha must be greater or equal to one&#34;)
        current_point = base_point
        next_tangent_vec = tangent_vec / (n_rungs**alpha)
        methods = {&#34;pole&#34;: self._pole_ladder_step, &#34;schild&#34;: self._schild_ladder_step}
        single_step = methods[scheme]
        base_shoot = self.exp(base_point=current_point, tangent_vec=next_tangent_vec)
        trajectory = []
        for i_point in range(n_rungs):
            frac_tan_vector_b = (i_point + 1) / n_rungs * direction
            next_point = self.exp(base_point=base_point, tangent_vec=frac_tan_vector_b)
            next_step = single_step(
                base_point=current_point,
                next_point=next_point,
                base_shoot=base_shoot,
                **single_step_kwargs
            )
            current_point = next_point
            base_shoot = next_step[&#34;end_point&#34;]
            trajectory.append(next_step[&#34;geodesics&#34;])
        transported_tangent_vec = self.log(base_shoot, current_point)
        if n_rungs % 2 == 1 and scheme == &#34;pole&#34;:
            transported_tangent_vec *= -1.0
        transported_tangent_vec *= n_rungs**alpha
        return {
            &#34;transported_tangent_vec&#34;: transported_tangent_vec,
            &#34;end_point&#34;: current_point,
            &#34;trajectory&#34;: trajectory,
        }

    def curvature(self, tangent_vec_a, tangent_vec_b, tangent_vec_c, base_point):
        r&#34;&#34;&#34;Compute the curvature.

        For three vectors fields :math:`X|_P = tangent_vec_a,
        Y|_P = tangent_vec_b, Z|_P = tangent_vec_c` with tangent vector
        specified in argument at the base point :math:`P`,
        the curvature is defined by :math:`R(X,Y)Z = \nabla_{[X,Y]}Z
        - \nabla_X\nabla_Y Z + \nabla_Y\nabla_X Z`.

        Parameters
        ----------
        tangent_vec_a : array-like, shape=[..., {dim, [n, m]}]
            Tangent vector at `base_point`.
        tangent_vec_b : array-like, shape=[..., {dim, [n, m]}]
            Tangent vector at `base_point`.
        tangent_vec_c : array-like, shape=[..., {dim, [n, m]}]
            Tangent vector at `base_point`.
        base_point :  array-like, shape=[..., {dim, [n, m]}]
            Point on the group. Optional, default is the identity.

        Returns
        -------
        curvature : array-like, shape=[..., {dim, [n, m]}]
            Tangent vector at `base_point`.
        &#34;&#34;&#34;
        raise NotImplementedError(&#34;The curvature is not implemented.&#34;)

    def directional_curvature(self, tangent_vec_a, tangent_vec_b, base_point):
        &#34;&#34;&#34;Compute the directional curvature (tidal force operator).

        For two vectors fields :math:`X|_P = tangent_vec_a`, and :math:
        `Y|_P = tangent_vec_b` with tangent vector specified in argument at
        the base point :math:`P`, the directional curvature, better known
        in relativity as the tidal force operator, is defined by
        :math:`R_Y(X) = R(Y,X)Y`.

        Parameters
        ----------
        tangent_vec_a : array-like, shape=[..., dim]
            Tangent vector at `base_point`.
        tangent_vec_b : array-like, shape=[..., dim]
            Tangent vector at `base_point`.
        base_point :  array-like, shape=[..., dim]
            Base-point on the manifold.

        Returns
        -------
        directional_curvature : array-like, shape=[..., dim]
            Tangent vector at `base_point`.
        &#34;&#34;&#34;
        return self.curvature(tangent_vec_b, tangent_vec_a, tangent_vec_b, base_point)

    def curvature_derivative(
        self,
        tangent_vec_a,
        tangent_vec_b,
        tangent_vec_c,
        tangent_vec_d,
        base_point=None,
    ):
        r&#34;&#34;&#34;Compute the covariant derivative of the curvature.

        For four vectors fields :math:`H|_P = tangent_vec_a, X|_P =
        tangent_vec_b, Y|_P = tangent_vec_c, Z|_P = tangent_vec_d` with
        tangent vector value specified in argument at the base point `P`,
        the covariant derivative of the curvature
        :math:`(\nabla_H R)(X, Y) Z |_P` is computed at the base point P.

        Parameters
        ----------
        tangent_vec_a : array-like, shape=[..., {dim, [n, m]}]
            Tangent vector at `base_point`.
        tangent_vec_b : array-like, shape=[..., {dim, [n, m]}]
            Tangent vector at `base_point`.
        tangent_vec_c : array-like, shape=[..., {dim, [n, m]}]
            Tangent vector at `base_point`.
        tangent_vec_d : array-like, shape=[..., {dim, [n, m]}]
            Tangent vector at `base_point`.
        base_point :  array-like, shape=[..., {dim, [n, m]}]
            Point on the group. Optional, default is the identity.

        Returns
        -------
        curvature_derivative : array-like, shape=[..., dim]
            Tangent vector at base-point.
        &#34;&#34;&#34;
        raise NotImplementedError(&#34;The curvature is not implemented.&#34;)

    def directional_curvature_derivative(
        self, tangent_vec_a, tangent_vec_b, base_point=None
    ):
        r&#34;&#34;&#34;Compute the covariant derivative of the directional curvature.

        For two vectors fields :math:`X|_P = tangent_vec_a, Y|_P =
        tangent_vec_b` with tangent vector value specified in argument at the
        base point `P`, the covariant derivative (in the direction &#39;X&#39;)
        :math:`(\nabla_X R_Y)(X) |_P = (\nabla_X R)(Y, X) Y |_P` of the
        directional curvature (in the direction `Y`)
        :math:`R_Y(X) = R(Y, X) Y`  is a quadratic tensor in &#39;X&#39; and &#39;Y&#39; that
        plays an important role in the computation of the moments of the
        empirical Fréchet mean.

        References
        ----------
        .. [Pennec] Pennec, xavier. Curvature effects on the empirical mean in
        Riemannian and affine Manifolds: a non-asymptotic high concentration
        expansion in the small-sample regime. Preprint. June 2019.
        https://arxiv.org/abs/1906.07418
        &#34;&#34;&#34;
        return self.curvature_derivative(
            tangent_vec_a, tangent_vec_b, tangent_vec_a, tangent_vec_b, base_point
        )

    def geodesic(self, initial_point, end_point=None, initial_tangent_vec=None):
        &#34;&#34;&#34;Generate parameterized function for the geodesic curve.

        Geodesic curve defined by either:
        - an initial point and an initial tangent vector,
        - an initial point and an end point.

        Parameters
        ----------
        initial_point : array-like, shape=[..., dim]
            Point on the manifold, initial point of the geodesic.
        end_point : array-like, shape=[..., dim], optional
            Point on the manifold, end point of the geodesic. If None,
            an initial tangent vector must be given.
        initial_tangent_vec : array-like, shape=[..., dim],
            Tangent vector at base point, the initial speed of the geodesics.
            Optional, default: None.
            If None, an end point must be given and a logarithm is computed.

        Returns
        -------
        path : callable
            Time parameterized geodesic curve. If a batch of initial
            conditions is passed, the output array&#39;s first dimension
            represents the different initial conditions, and the second
            corresponds to time.
        &#34;&#34;&#34;
        point_type = self.default_point_type

        if end_point is None and initial_tangent_vec is None:
            raise ValueError(
                &#34;Specify an end point or an initial tangent &#34;
                &#34;vector to define the geodesic.&#34;
            )
        if end_point is not None:
            shooting_tangent_vec = self.log(point=end_point, base_point=initial_point)
            if initial_tangent_vec is not None:
                if not gs.allclose(shooting_tangent_vec, initial_tangent_vec):
                    raise RuntimeError(
                        &#34;The shooting tangent vector is too&#34;
                        &#34; far from the input initial tangent vector.&#34;
                    )
            initial_tangent_vec = shooting_tangent_vec

        if point_type == &#34;vector&#34;:
            initial_point = gs.to_ndarray(initial_point, to_ndim=2)
            initial_tangent_vec = gs.to_ndarray(initial_tangent_vec, to_ndim=2)

        else:
            initial_point = gs.to_ndarray(initial_point, to_ndim=3)
            initial_tangent_vec = gs.to_ndarray(initial_tangent_vec, to_ndim=3)
        n_initial_conditions = initial_tangent_vec.shape[0]

        if n_initial_conditions &gt; 1 and len(initial_point) == 1:
            initial_point = gs.stack([initial_point[0]] * n_initial_conditions)

        def path(t):
            &#34;&#34;&#34;Generate parameterized function for geodesic curve.

            Parameters
            ----------
            t : array-like, shape=[n_points,]
                Times at which to compute points of the geodesics.
            &#34;&#34;&#34;
            t = gs.array(t)
            t = gs.cast(t, initial_tangent_vec.dtype)
            t = gs.to_ndarray(t, to_ndim=1)
            if point_type == &#34;vector&#34;:
                tangent_vecs = gs.einsum(&#34;i,...k-&gt;...ik&#34;, t, initial_tangent_vec)
            else:
                tangent_vecs = gs.einsum(&#34;i,...kl-&gt;...ikl&#34;, t, initial_tangent_vec)

            points_at_time_t = [
                self.exp(tv, pt) for tv, pt in zip(tangent_vecs, initial_point)
            ]
            points_at_time_t = gs.stack(points_at_time_t, axis=0)

            return (
                points_at_time_t[0] if n_initial_conditions == 1 else points_at_time_t
            )

        return path

    def parallel_transport(
        self, tangent_vec, base_point, direction=None, end_point=None
    ):
        r&#34;&#34;&#34;Compute the parallel transport of a tangent vector.

        Closed-form solution for the parallel transport of a tangent vector
        along the geodesic between two points `base_point` and `end_point`
        or alternatively defined by :math:`t\mapsto exp_(base_point)(
        t*direction)`.

        Parameters
        ----------
        tangent_vec : array-like, shape=[..., {dim, [n, m]}]
            Tangent vector at base point to be transported.
        base_point : array-like, shape=[..., {dim, [n, m]}]
            Point on the manifold. Point to transport from.
        direction : array-like, shape=[..., {dim, [n, m]}]
            Tangent vector at base point, along which the parallel transport
            is computed.
            Optional, default: None.
        end_point : array-like, shape=[..., {dim, [n, m]}]
            Point on the manifold. Point to transport to.
            Optional, default: None.

        Returns
        -------
        transported_tangent_vec: array-like, shape=[..., {dim, [n, m]}]
            Transported tangent vector at `exp_(base_point)(tangent_vec_b)`.
        &#34;&#34;&#34;
        raise NotImplementedError(
            &#34;The closed-form solution of parallel transport is not known, &#34;
            &#34;use the ladder_parallel_transport instead.&#34;
        )
</pre></div></div>
</div>
</section>
</section>
<section id="7.-RiemannianMetric-Sub-Class">
<h1>7. <code class="docutils literal notranslate"><span class="pre">RiemannianMetric</span></code> Sub-Class<a class="headerlink" href="#7.-RiemannianMetric-Sub-Class" title="Permalink to this heading">#</a></h1>
<p>The <code class="docutils literal notranslate"><span class="pre">RiemannianMetric</span></code> class is the only subclass of the <code class="docutils literal notranslate"><span class="pre">Connection</span></code> class. Its function in <code class="docutils literal notranslate"><span class="pre">Geomstats</span></code> is so important that we will dedicate a whole additional section of this notebook to it.</p>
<section id="7.1-Riemannian-Metrics">
<h2>7.1 Riemannian Metrics<a class="headerlink" href="#7.1-Riemannian-Metrics" title="Permalink to this heading">#</a></h2>
<p>When we considered “connections” on manifolds, we had to erase what we thought we knew about transporting vectors. We had to accept the fact that transporting a vector is much more complicated on a manifold because the basis vectors are not identical at each point on a manifold, which leads to much more complicated calculations. Additionally, we had to generalize what we knew about transporting vectors on a Euclidean space.</p>
<p>Similarly, here we will erase our previous notions of “measurement” (distance, angles, curvature, etc.) because the concept of such measurements is quite different on manifolds than in Euclidean space. In fact, there is no way to define notions of such measurements on a manifold until you equip the manifold with a something called a ‘’metric’’.</p>
<p>A <span class="math notranslate nohighlight">\(\textbf{Riemannian Metric}\)</span> <span class="math notranslate nohighlight">\(g\)</span> on a manifold <span class="math notranslate nohighlight">\(M\)</span> is a family of inner products <span class="math notranslate nohighlight">\((\langle.,.\rangle_p)_{p\in M}\)</span> on each tangent space <span class="math notranslate nohighlight">\(T_pM\)</span> such that <span class="math notranslate nohighlight">\(\langle.,.\rangle_p\)</span> depends smoothly on <span class="math notranslate nohighlight">\(p\)</span>. If this does not make sense, then just understand that a Riemannian Metric allows us to describe the space of a manifold using “inner products”, which allows us to define distance functions and other measurement functions on manifolds.</p>
</section>
<section id="7.2-How-is-the-Riemannian-Metric-Connected-with-the-Connection?">
<h2>7.2 How is the Riemannian Metric Connected with the Connection?<a class="headerlink" href="#7.2-How-is-the-Riemannian-Metric-Connected-with-the-Connection?" title="Permalink to this heading">#</a></h2>
<p><span class="math notranslate nohighlight">\(\textbf{1. First, each Riemannian Metric generates a unique Levi-Civita connection.}\)</span> A Levi-Civita connection is a special type of connection that is “torsion-free” and “compatible”. For now, do not worry about what “torsion-free” and “compatible” mean. Just know that when we work with connections in Geomstats, we are working with Levi-Civita connections.</p>
<p><span class="math notranslate nohighlight">\(\textbf{2. Second, the Riemannian Metric ''g'' allows us to calculate Christoffel symbols.}\)</span> Recall from earlier in this notebook that we can calculate the connection in local coordinates by using christoffel symbols (<span class="math notranslate nohighlight">\(\Gamma_{i j}^{k}\)</span>). However, we can only calculate these Christoffel symbols if we have equip the manifold with a metric. In the case of a Levi-Civita connection, the Christoffel symbols can be calculated from the metric as follows:</p>
<div class="math notranslate nohighlight">
\[\Gamma_{i j}^{k} = \frac{1}{2}g^{lk}(\partial_i g_{jl}+\partial_j g_{li}-\partial_l g_{ij})\]</div>
</section>
<section id="7.3-RiemannianMetric-in-Geomstats">
<h2>7.3 <code class="docutils literal notranslate"><span class="pre">RiemannianMetric</span></code> in <code class="docutils literal notranslate"><span class="pre">Geomstats</span></code><a class="headerlink" href="#7.3-RiemannianMetric-in-Geomstats" title="Permalink to this heading">#</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">RiemannianMetric</span></code> subclass is the class that actually performs calculations on manifolds. This is because we cannot perform “general” calculations like logarithm, exponential, parallel transport, and calculating geodesics without first being equip with a metric. The <code class="docutils literal notranslate"><span class="pre">RiemannianMetric</span></code> subclass contains a collection of metrics that <code class="docutils literal notranslate"><span class="pre">Geomstats</span></code> users may use to perform calculations on manifolds. The structure of the <code class="docutils literal notranslate"><span class="pre">RiemannianMetric</span></code> class is shown below.</p>
<p><img alt="49976a1b6e8b4f968eda2e63c2a2c3dc" src="../_images/conn_connection_hierarchy.jpg" /></p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span> In [8]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">geomstats.geometry.riemannian_metric</span> <span class="kn">import</span> <span class="n">RiemannianMetric</span>
<span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getsourcelines</span><span class="p">(</span><span class="n">RiemannianMetric</span><span class="p">)[</span><span class="mi">0</span><span class="p">]:</span>
    <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
<br/></pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
class RiemannianMetric(Connection, ABC):
    &#34;&#34;&#34;Class for Riemannian and pseudo-Riemannian metrics.

    The associated Levi-Civita connection on the tangent bundle.

    Parameters
    ----------
    dim : int
        Dimension of the manifold.
    shape : tuple of int
        Shape of one element of the manifold.
        Optional, default : (dim, ).
    signature : tuple
        Signature of the metric.
        Optional, default: None.
    default_point_type : str, {&#39;vector&#39;, &#39;matrix&#39;}
        Point type.
        Optional, default: &#39;vector&#39;.
    &#34;&#34;&#34;

    def __init__(self, dim, shape=None, signature=None, default_point_type=None):
        super(RiemannianMetric, self).__init__(
            dim=dim, shape=shape, default_point_type=default_point_type
        )
        if signature is None:
            signature = (dim, 0)
        self.signature = signature

    def metric_matrix(self, base_point=None):
        &#34;&#34;&#34;Metric matrix at the tangent space at a base point.

        Parameters
        ----------
        base_point : array-like, shape=[..., dim]
            Base point.
            Optional, default: None.

        Returns
        -------
        mat : array-like, shape=[..., dim, dim]
            Inner-product matrix.
        &#34;&#34;&#34;
        raise NotImplementedError(
            &#34;The computation of the metric matrix&#34; &#34; is not implemented.&#34;
        )

    def cometric_matrix(self, base_point=None):
        &#34;&#34;&#34;Inner co-product matrix at the cotangent space at a base point.

        This represents the cometric matrix, i.e. the inverse of the
        metric matrix.

        Parameters
        ----------
        base_point : array-like, shape=[..., dim]
            Base point.
            Optional, default: None.

        Returns
        -------
        mat : array-like, shape=[..., dim, dim]
            Inverse of inner-product matrix.
        &#34;&#34;&#34;
        metric_matrix = self.metric_matrix(base_point)
        cometric_matrix = gs.linalg.inv(metric_matrix)
        return cometric_matrix

    def inner_product_derivative_matrix(self, base_point=None):
        &#34;&#34;&#34;Compute derivative of the inner prod matrix at base point.

        Parameters
        ----------
        base_point : array-like, shape=[..., dim]
            Base point.
            Optional, default: None.

        Returns
        -------
        mat : array-like, shape=[..., dim, dim]
            Derivative of inverse of inner-product matrix.
        &#34;&#34;&#34;
        metric_derivative = gs.autodiff.jacobian(self.metric_matrix)
        return metric_derivative(base_point)

    def christoffels(self, base_point):
        r&#34;&#34;&#34;Compute Christoffel symbols of the Levi-Civita connection.

        The Koszul formula defining the Levi-Civita connection gives the
        expression of the Christoffel symbols with respect to the metric:
        :math:`\Gamma^k_{ij}(p) = \frac{1}{2} g^{lk}(
        \partial_i g_{jl} + \partial_j g_{li} - \partial_l g_{ij})`,
        where:
        - :math:`p` represents the base point, and
        - :math:`g` represents the Riemannian metric tensor.

        Parameters
        ----------
        base_point: array-like, shape=[..., dim]
            Base point.

        Returns
        -------
        christoffels: array-like, shape=[..., dim, dim, dim]
            Christoffel symbols.
        &#34;&#34;&#34;
        cometric_mat_at_point = self.cometric_matrix(base_point)
        metric_derivative_at_point = self.inner_product_derivative_matrix(base_point)
        term_1 = gs.einsum(
            &#34;...lk,...jli-&gt;...kij&#34;, cometric_mat_at_point, metric_derivative_at_point
        )
        term_2 = gs.einsum(
            &#34;...lk,...lij-&gt;...kij&#34;, cometric_mat_at_point, metric_derivative_at_point
        )
        term_3 = -gs.einsum(
            &#34;...lk,...ijl-&gt;...kij&#34;, cometric_mat_at_point, metric_derivative_at_point
        )

        christoffels = 0.5 * (term_1 + term_2 + term_3)
        return christoffels

    def inner_product(self, tangent_vec_a, tangent_vec_b, base_point):
        &#34;&#34;&#34;Inner product between two tangent vectors at a base point.

        Parameters
        ----------
        tangent_vec_a: array-like, shape=[..., dim]
            Tangent vector at base point.
        tangent_vec_b: array-like, shape=[..., dim]
            Tangent vector at base point.
        base_point: array-like, shape=[..., dim]
            Base point.
            Optional, default: None.

        Returns
        -------
        inner_product : array-like, shape=[...,]
            Inner-product.
        &#34;&#34;&#34;
        inner_prod_mat = self.metric_matrix(base_point)
        aux = gs.einsum(&#34;...j,...jk-&gt;...k&#34;, tangent_vec_a, inner_prod_mat)
        inner_prod = gs.einsum(&#34;...k,...k-&gt;...&#34;, aux, tangent_vec_b)
        return inner_prod

    def inner_coproduct(self, cotangent_vec_a, cotangent_vec_b, base_point):
        &#34;&#34;&#34;Compute inner coproduct between two cotangent vectors at base point.

        This is the inner product associated to the cometric matrix.

        Parameters
        ----------
        cotangent_vec_a : array-like, shape=[..., dim]
            Cotangent vector at `base_point`.
        cotangent_vet_b : array-like, shape=[..., dim]
            Cotangent vector at `base_point`.
        base_point : array-like, shape=[..., dim]
            Point on the manifold.

        Returns
        -------
        inner_coproduct : float
            Inner coproduct between the two cotangent vectors.
        &#34;&#34;&#34;
        vector_2 = gs.einsum(
            &#34;...ij,...j-&gt;...i&#34;, self.cometric_matrix(base_point), cotangent_vec_b
        )
        inner_coproduct = gs.einsum(&#34;...i,...i-&gt;...&#34;, cotangent_vec_a, vector_2)
        return inner_coproduct

    def hamiltonian(self, state):
        r&#34;&#34;&#34;Compute the hamiltonian energy associated to the cometric.

        The Hamiltonian at state :math:`(q, p)` is defined by

        .. math:
            H(q, p) = \frac{1}{2} &lt;p, p&gt;_q

        where :math:`&lt;\cdot, \cdot&gt;_q` is the cometric at :math:`q`.

        Parameters
        ----------
        state : tuple of arrays
            Position and momentum variables. The position is a point on the
            manifold, while the momentum is cotangent vector.

        Returns
        -------
        energy : float
            Hamiltonian energy at `state`.
        &#34;&#34;&#34;
        position, momentum = state
        return 1.0 / 2 * self.inner_coproduct(momentum, momentum, position)

    def squared_norm(self, vector, base_point=None):
        &#34;&#34;&#34;Compute the square of the norm of a vector.

        Squared norm of a vector associated to the inner product
        at the tangent space at a base point.

        Parameters
        ----------
        vector : array-like, shape=[..., dim]
            Vector.
        base_point : array-like, shape=[..., dim]
            Base point.
            Optional, default: None.

        Returns
        -------
        sq_norm : array-like, shape=[...,]
            Squared norm.
        &#34;&#34;&#34;
        sq_norm = self.inner_product(vector, vector, base_point)
        return sq_norm

    def norm(self, vector, base_point=None):
        &#34;&#34;&#34;Compute norm of a vector.

        Norm of a vector associated to the inner product
        at the tangent space at a base point.

        Note: This only works for positive-definite
        Riemannian metrics and inner products.

        Parameters
        ----------
        vector : array-like, shape=[..., dim]
            Vector.
        base_point : array-like, shape=[..., dim]
            Base point.
            Optional, default: None.

        Returns
        -------
        norm : array-like, shape=[...,]
            Norm.
        &#34;&#34;&#34;
        sq_norm = self.squared_norm(vector, base_point)
        norm = gs.sqrt(sq_norm)
        return norm

    def normalize(self, vector, base_point):
        &#34;&#34;&#34;Normalize tangent vector at a given point.

        Parameters
        ----------
        vector : array-like, shape=[..., dim]
            Tangent vector at base_point.
        base_point : array-like, shape=[..., dim]
            Point.

        Returns
        -------
        normalized_vector : array-like, shape=[..., dim]
            Unit tangent vector at base_point.
        &#34;&#34;&#34;
        norm = self.norm(vector, base_point)
        norm = gs.where(norm == 0, gs.ones(norm.shape), norm)
        normalized_vector = gs.einsum(&#34;...i,...-&gt;...i&#34;, vector, 1 / norm)
        return normalized_vector

    def random_unit_tangent_vec(self, base_point, n_vectors=1):
        &#34;&#34;&#34;Generate a random unit tangent vector at a given point.

        Parameters
        ----------
        base_point : array-like, shape=[..., dim]
            Point.
        n_vectors : float
            Number of vectors to be generated at base_point.
            For vectorization purposes n_vectors can be greater than 1 iff base_point
            constitues of a single point.

        Returns
        -------
        normalized_vector : array-like, shape=[..., n_vectors, dim]
            Random unit tangent vector at base_point.
        &#34;&#34;&#34;
        shape = base_point.shape
        if len(shape) &gt; 1 and shape[-2] &gt; 1 and n_vectors &gt; 1:
            raise ValueError(
                &#34;Several tangent vectors is only applicable to a single base point.&#34;
            )
        random_vector = gs.squeeze(gs.random.rand(n_vectors, *shape))
        normalized_vector = self.normalize(random_vector, base_point)
        return gs.squeeze(normalized_vector)

    def squared_dist(self, point_a, point_b, **kwargs):
        &#34;&#34;&#34;Squared geodesic distance between two points.

        Parameters
        ----------
        point_a : array-like, shape=[..., dim]
            Point.
        point_b : array-like, shape=[..., dim]
            Point.

        Returns
        -------
        sq_dist : array-like, shape=[...,]
            Squared distance.
        &#34;&#34;&#34;
        log = self.log(point=point_b, base_point=point_a, **kwargs)

        sq_dist = self.squared_norm(vector=log, base_point=point_a)
        return sq_dist

    def dist(self, point_a, point_b, **kwargs):
        &#34;&#34;&#34;Geodesic distance between two points.

        Note: It only works for positive definite
        Riemannian metrics.

        Parameters
        ----------
        point_a : array-like, shape=[..., dim]
            Point.
        point_b : array-like, shape=[..., dim]
            Point.

        Returns
        -------
        dist : array-like, shape=[...,]
            Distance.
        &#34;&#34;&#34;
        sq_dist = self.squared_dist(point_a, point_b, **kwargs)
        dist = gs.sqrt(sq_dist)
        return dist

    def dist_broadcast(self, point_a, point_b):
        &#34;&#34;&#34;Compute the geodesic distance between points.

        If n_samples_a == n_samples_b then dist is the element-wise
        distance result of a point in points_a with the point from
        points_b of the same index. If n_samples_a not equal to
        n_samples_b then dist is the result of applying geodesic
        distance for each point from points_a to all points from
        points_b.

        Parameters
        ----------
        point_a : array-like, shape=[n_samples_a, dim]
            Set of points in the Poincare ball.
        point_b : array-like, shape=[n_samples_b, dim]
            Second set of points in the Poincare ball.

        Returns
        -------
        dist : array-like,
            shape=[n_samples_a, dim] or [n_samples_a, n_samples_b, dim]
            Geodesic distance between the two points.
        &#34;&#34;&#34;
        ndim = len(self.shape)

        if point_a.shape[-ndim:] != point_b.shape[-ndim:]:
            raise ValueError(&#34;Manifold dimensions not equal&#34;)

        if ndim in (point_a.ndim, point_b.ndim) or (point_a.shape == point_b.shape):
            return self.dist(point_a, point_b)

        n_samples = point_a.shape[0] * point_b.shape[0]
        point_a_broadcast, point_b_broadcast = gs.broadcast_arrays(
            point_a[:, None], point_b[None, ...]
        )

        point_a_flatten = gs.reshape(
            point_a_broadcast, (n_samples,) + point_a.shape[-ndim:]
        )
        point_b_flatten = gs.reshape(
            point_b_broadcast, (n_samples,) + point_a.shape[-ndim:]
        )

        dist = self.dist(point_a_flatten, point_b_flatten)
        dist = gs.reshape(dist, (point_a.shape[0], point_b.shape[0]))
        dist = gs.squeeze(dist)
        return dist

    def dist_pairwise(self, points, n_jobs=1, **joblib_kwargs):
        &#34;&#34;&#34;Compute the pairwise distance between points.

        Parameters
        ----------
        points : array-like, shape=[n_samples, dim]
            Set of points in the manifold.
        n_jobs : int
            Number of jobs to run in parallel, using joblib. Note that a
            higher number of jobs may not be beneficial when one computation
            of a geodesic distance is cheap.
            Optional. Default: 1.
        **joblib_kwargs : dict
            Keyword arguments to joblib.Parallel

        Returns
        -------
        dist : array-like, shape=[n_samples, n_samples]
            Pairwise distance matrix between all the points.

        See Also
        --------
        `joblib documentations &lt;https://joblib.readthedocs.io/en/latest/&gt;`_
        &#34;&#34;&#34;
        n_samples = points.shape[0]
        rows, cols = gs.triu_indices(n_samples)

        @joblib.delayed
        @joblib.wrap_non_picklable_objects
        def pickable_dist(x, y):
            &#34;&#34;&#34;Wrap distance function to make it pickable.&#34;&#34;&#34;
            return self.dist(x, y)

        pool = joblib.Parallel(n_jobs=n_jobs, **joblib_kwargs)
        out = pool(pickable_dist(points[i], points[j]) for i, j in zip(rows, cols))

        pairwise_dist = geometry.symmetric_matrices.SymmetricMatrices.from_vector(
            gs.array(out)
        )
        return pairwise_dist

    def diameter(self, points):
        &#34;&#34;&#34;Give the distance between two farthest points.

        Distance between the two points that are farthest away from each other
        in points.

        Parameters
        ----------
        points : array-like, shape=[..., dim]
            Points.

        Returns
        -------
        diameter : float
            Distance between two farthest points.
        &#34;&#34;&#34;
        diameter = 0.0
        n_points = points.shape[0]

        for i in range(n_points - 1):
            dist_to_neighbors = self.dist(points[i, :], points[i + 1 :, :])
            dist_to_farthest_neighbor = gs.amax(dist_to_neighbors)
            diameter = gs.maximum(diameter, dist_to_farthest_neighbor)

        return diameter

    def closest_neighbor_index(self, point, neighbors):
        &#34;&#34;&#34;Closest neighbor of point among neighbors.

        Parameters
        ----------
        point : array-like, shape=[..., dim]
            Point.
        neighbors : array-like, shape=[n_neighbors, dim]
            Neighbors.

        Returns
        -------
        closest_neighbor_index : int
            Index of closest neighbor.
        &#34;&#34;&#34;
        n_points = point.shape[0] if gs.ndim(point) == gs.ndim(neighbors) else 1
        n_neighbors = neighbors.shape[0]

        if n_points &gt; 1 and n_neighbors &gt; 1:
            neighbors = gs.repeat(neighbors, n_points, axis=0)

            point = gs.concatenate([point for _ in range(n_neighbors)])

        closest_neighbor_index = gs.argmin(
            gs.transpose(
                gs.reshape(self.dist(point, neighbors), (n_neighbors, n_points)),
            ),
            axis=1,
        )

        if n_points == 1:
            return closest_neighbor_index[0]

        return closest_neighbor_index

    def normal_basis(self, basis, base_point=None):
        &#34;&#34;&#34;Normalize the basis with respect to the metric.

        This corresponds to a renormalization of each basis vector.

        Parameters
        ----------
        basis : array-like, shape=[dim, dim]
            Matrix of a metric.
        base_point

        Returns
        -------
        basis : array-like, shape=[dim, n, n]
            Normal basis.
        &#34;&#34;&#34;
        norms = self.squared_norm(basis, base_point)

        return gs.einsum(&#34;i, ikl-&gt;ikl&#34;, 1.0 / gs.sqrt(norms), basis)

    def sectional_curvature(self, tangent_vec_a, tangent_vec_b, base_point=None):
        r&#34;&#34;&#34;Compute the sectional curvature.

        For two orthonormal tangent vectors :math:`x,y` at a base point,
        the sectional curvature is defined by :math:`&lt;R(x, y)x, y&gt; =
        &lt;R_x(y), y&gt;`. For non-orthonormal vectors vectors, it is
        :math:`&lt;R(x, y)x, y&gt; / \\|x \wedge y\\|^2`.

        Parameters
        ----------
        tangent_vec_a : array-like, shape=[..., n, n]
            Tangent vector at `base_point`.
        tangent_vec_b : array-like, shape=[..., n, n]
            Tangent vector at `base_point`.
        base_point : array-like, shape=[..., n, n]
            Point in the group. Optional, default is the identity

        Returns
        -------
        sectional_curvature : array-like, shape=[...,]
            Sectional curvature at `base_point`.

        See Also
        --------
        https://en.wikipedia.org/wiki/Sectional_curvature
        &#34;&#34;&#34;
        curvature = self.curvature(
            tangent_vec_a, tangent_vec_b, tangent_vec_a, base_point
        )
        sectional = self.inner_product(curvature, tangent_vec_b, base_point)
        norm_a = self.squared_norm(tangent_vec_a, base_point)
        norm_b = self.squared_norm(tangent_vec_b, base_point)
        inner_ab = self.inner_product(tangent_vec_a, tangent_vec_b, base_point)
        normalization_factor = norm_a * norm_b - inner_ab**2

        condition = gs.isclose(normalization_factor, 0.0)
        normalization_factor = gs.where(condition, EPSILON, normalization_factor)
        return gs.where(~condition, sectional / normalization_factor, 0.0)
</pre></div></div>
</div>
</section>
</section>
<section id="8.-Conclusion">
<h1>8. Conclusion<a class="headerlink" href="#8.-Conclusion" title="Permalink to this heading">#</a></h1>
<p>Key take-aways from this notebook: 1. The connection tells us how much one vector in <span class="math notranslate nohighlight">\(T_pM\)</span> changes when you move it infinitesimally in the direction of another vector in <span class="math notranslate nohighlight">\(T_pM\)</span>. 2. The connection defines what it means for a vector to change, so it also allows us to define what it means for a vector to <span class="math notranslate nohighlight">\(\textbf{not}\)</span> change. This allows us to define the notion of parallel vector fields and parallel transport. 3. A parallel vector field <span class="math notranslate nohighlight">\(X\)</span> along a curve <span class="math notranslate nohighlight">\(\gamma\)</span>
satisfies</p>
<div class="math notranslate nohighlight">
\[\nabla_{\dot{\gamma}(t)} X(t)=0\]</div>
<p>which means that each point along <span class="math notranslate nohighlight">\(\gamma\)</span>, the vector <span class="math notranslate nohighlight">\(x \in X\)</span> will not change if it is moved infinitesimally in the direction of the curve’s tangent vector <span class="math notranslate nohighlight">\(\dot{\gamma(t)}\)</span>. 4. The parallel transport tells you what a vector would look like if you transported it non-infinitesimally along a curve. 5. Equipping a manifold with a Riemannian metric is the only way to define a notion of ’’distance“, ’’length” or any other sort of measurement on manifolds.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span> In [ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>
</pre></div>
</div>
</div>
</section>


            </article>
            
            
            
            <footer class="bd-footer-article">
                <!-- Previous / next buttons -->
<div class='prev-next-area'>
  <a class='left-prev' id="prev-link" href="01_foundations__manifolds.html" title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
          <p class="prev-next-subtitle">previous</p>
          <p class="prev-next-title">1. Introduction</p>
      </div>
  </a>
  <a class='right-next' id="next-link" href="17_foundations__stratified_spaces.html" title="next page">
  <div class="prev-next-info">
      <p class="prev-next-subtitle">next</p>
      <p class="prev-next-title">Stratified spaces</p>
  </div>
  <i class="fa-solid fa-angle-right"></i>
  </a>
</div>
            </footer>
            
          </div>
          
          
          
            <div class="bd-sidebar-secondary bd-toc">
              
<div class="toc-item">
  
<div class="tocsection onthispage">
    <i class="fa-solid fa-list"></i> On this page
</div>
<nav id="bd-toc-nav" class="page-toc">
    <ul class="visible nav section-nav flex-column">
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#">
   1. What is a Connection?
  </a>
  <ul class="visible nav section-nav flex-column">
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#1.1-General-Mathematical-Definition-of-the-Connection">
     1.1 General Mathematical Definition of the Connection
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#1.2-What-does-the-Connection-actually-do?-–-a-more-friendly-description-of-the-connection,-with-an-example">
     1.2 What does the Connection actually do? – a more friendly description of the connection, with an example
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#2.-Why-is-the-Connection-important-(big-picture)?-–-parallel-transport,-parallel-vector-fields">
   2. Why is the Connection important (big picture)? – parallel transport, parallel vector fields
  </a>
  <ul class="visible nav section-nav flex-column">
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#2.1-Parallel-Vector-Fields">
     2.1 Parallel Vector Fields
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#2.2-Parallel-Transport">
     2.2 Parallel Transport
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#3.-Defining-Geodesics-with-the-Conneciton">
   3. Defining Geodesics with the Conneciton
  </a>
  <ul class="visible nav section-nav flex-column">
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#3.1-Intuitive-Definition-of-a-Geodesic">
     3.1 Intuitive Definition of a Geodesic
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#3.2-Defining-a-geodesic-with-the-connection">
     3.2 Defining a geodesic with the connection
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#3.3-Building-Intuition-with-Physics">
     3.3 Building Intuition with Physics
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#4.-Description-of-Connection-in-Local-Coordinates-(using-Christoffel-Symbols)">
   4. Description of Connection in Local Coordinates (using Christoffel Symbols)
  </a>
  <ul class="visible nav section-nav flex-column">
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#4.1-Math-Notation:-\mathbf{-\partial_i}-Basis-Vector">
     4.1 Math Notation:
     <span class="math notranslate nohighlight">
      \(\mathbf{ \partial_i}\)
     </span>
     Basis Vector
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#4.2-Einstein-Notation">
     4.2 Einstein Notation
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#4.3-What-does-a-Christoffel-Symbol-represent?">
     4.3 What does a Christoffel Symbol represent?
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#4.4-The-Geodesic-Equation-in-local-coordinates">
     4.4 The Geodesic Equation in local coordinates
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#4.5-Why-should-we-care-about-Christoffel-Symbols-and-this-representation-of-the-connection?">
     4.5 Why should we care about Christoffel Symbols and this representation of the connection?
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#5.-Additional-Important-Mathematical-concepts-utilized-by-Connection-Class:-Logarithm,-Exponential">
   5. Additional Important Mathematical concepts utilized by
   <code class="docutils literal notranslate">
    <span class="pre">
     Connection
    </span>
   </code>
   Class: Logarithm, Exponential
  </a>
  <ul class="visible nav section-nav flex-column">
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#Exponentials-on-Manifolds">
     Exponentials on Manifolds
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#Logarithms-on-Manifolds">
     Logarithms on Manifolds
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#6.-Geomstats-Documentation:-The-Connection-Class">
   6. Geomstats Documentation: The
   <code class="docutils literal notranslate">
    <span class="pre">
     Connection
    </span>
   </code>
   Class
  </a>
  <ul class="visible nav section-nav flex-column">
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#6.1-method:-parallel_transport()">
     6.1 method:
     <code class="docutils literal notranslate">
      <span class="pre">
       parallel_transport()
      </span>
     </code>
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#6.2-method:-geodesic_equation()">
     6.2 method:
     <code class="docutils literal notranslate">
      <span class="pre">
       geodesic_equation()
      </span>
     </code>
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#6.3-method:-exp()-(exponential)">
     6.3 method:
     <code class="docutils literal notranslate">
      <span class="pre">
       exp()
      </span>
     </code>
     (exponential)
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#6.4-method:-log()-(logarithm)">
     6.4 method:
     <code class="docutils literal notranslate">
      <span class="pre">
       log()
      </span>
     </code>
     (logarithm)
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#6.5-The-full-Connection-class">
     6.5 The full
     <code class="docutils literal notranslate">
      <span class="pre">
       Connection
      </span>
     </code>
     class
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#7.-RiemannianMetric-Sub-Class">
   7.
   <code class="docutils literal notranslate">
    <span class="pre">
     RiemannianMetric
    </span>
   </code>
   Sub-Class
  </a>
  <ul class="visible nav section-nav flex-column">
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#7.1-Riemannian-Metrics">
     7.1 Riemannian Metrics
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#7.2-How-is-the-Riemannian-Metric-Connected-with-the-Connection?">
     7.2 How is the Riemannian Metric Connected with the Connection?
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#7.3-RiemannianMetric-in-Geomstats">
     7.3
     <code class="docutils literal notranslate">
      <span class="pre">
       RiemannianMetric
      </span>
     </code>
     in
     <code class="docutils literal notranslate">
      <span class="pre">
       Geomstats
      </span>
     </code>
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#8.-Conclusion">
   8. Conclusion
  </a>
 </li>
</ul>

</nav>
</div>

<div class="toc-item">
  
<div id="searchbox"></div>
</div>

<div class="toc-item">
  
</div>

<div class="toc-item">
  
<div class="tocsection sourcelink">
    <a href="../_sources/notebooks/02_foundations__connection_riemannian_metric.ipynb.txt">
        <i class="fa-solid fa-file-lines"></i> Show Source
    </a>
</div>

</div>

            </div>
          
          
        </div>
        <footer class="bd-footer-content">
          <div class="bd-footer-content__inner">
            
          </div>
        </footer>
        
      </main>
    </div>
  </div>

  
    
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=796348d33e8b1d947c94"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=796348d33e8b1d947c94"></script>

  <footer class="bd-footer"><div class="bd-footer__inner container">
  
  <div class="footer-item">
    
<p class="copyright">

    &copy; Copyright 2022-2023, Geomstats, Inc..<br>

</p>

  </div>
  
  <div class="footer-item">
    <p class="theme-version">
    Built with the
    <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">
        PyData Sphinx Theme
    </a>
    0.12.0.
</p>
  </div>
  
  <div class="footer-item">
    
<p class="sphinx-version">
Created using <a href="http://sphinx-doc.org/">Sphinx</a> 5.3.0.<br>
</p>

  </div>
  
</div>
  </footer>
  </body>
</html>
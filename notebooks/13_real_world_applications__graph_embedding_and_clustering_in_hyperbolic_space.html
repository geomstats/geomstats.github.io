<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Tutorial: Hyperbolic Embedding of Graphs and Clustering &mdash; Geomstats latest documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/sg_gallery.css" type="text/css" />
    <link rel="canonical" href="geomstats.github.io/notebooks/13_real_world_applications__graph_embedding_and_clustering_in_hyperbolic_space.html" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
        <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Tutorial: Classifying hands poses with Kendall shape spaces" href="14_real_world_applications__hand_poses_analysis_in_kendall_shape_space.html" />
    <link rel="prev" title="Tutorial: Hand gesture classification with EMG data using Riemannian metrics" href="12_real_world_applications__emg_sign_classification_in_spd_manifold.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> Geomstats
          </a>
              <div class="version">
                latest
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Getting started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../first-steps.html">First steps</a></li>
<li class="toctree-l1"><a class="reference internal" href="../examples.html">Code Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api-reference.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gsod.html">Google Season of Docs: Project Page</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Tutorials</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="00_foundations__introduction_to_geomstats.html">What is the motivation for analyzing data on manifolds?</a></li>
<li class="toctree-l1"><a class="reference internal" href="00_foundations__introduction_to_geomstats.html#What-will-you-learn-in-these-tutorials?">What will you learn in these tutorials?</a></li>
<li class="toctree-l1"><a class="reference internal" href="01_foundations__manifolds.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="01_foundations__manifolds.html#2.-What-is-a-Manifold?">2. What is a Manifold?</a></li>
<li class="toctree-l1"><a class="reference internal" href="01_foundations__manifolds.html#3.-Why-do-we-care-about-manifolds?">3. Why do we care about manifolds?</a></li>
<li class="toctree-l1"><a class="reference internal" href="01_foundations__manifolds.html#4.-What-does-the-Manifold-class-do?">4. What does the <code class="docutils literal notranslate"><span class="pre">Manifold</span></code> class do?</a></li>
<li class="toctree-l1"><a class="reference internal" href="01_foundations__manifolds.html#5.-How-is-the-Manifold-class-structured?">5. How is the <code class="docutils literal notranslate"><span class="pre">Manifold</span></code> class structured?</a></li>
<li class="toctree-l1"><a class="reference internal" href="01_foundations__manifolds.html#Conclusion">Conclusion</a></li>
<li class="toctree-l1"><a class="reference internal" href="03_practical_methods__data_on_manifolds.html">Tutorial: Data on Manifolds</a></li>
<li class="toctree-l1"><a class="reference internal" href="04_practical_methods__from_vector_spaces_to_manifolds.html">Tutorial: From vector spaces to manifolds</a></li>
<li class="toctree-l1"><a class="reference internal" href="05_practical_methods__simple_machine_learning_on_tangent_spaces.html">Tutorial: Learning on Tangent Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="06_practical_methods__riemannian_frechet_mean_and_tangent_pca.html">Tutorial: Fréchet Mean and Tangent PCA</a></li>
<li class="toctree-l1"><a class="reference internal" href="07_practical_methods__riemannian_kmeans.html">Tutorial: K-Means clustering on a Riemannian Manifold</a></li>
<li class="toctree-l1"><a class="reference internal" href="08_practical_methods__information_geometry.html">Tutorial: Information geometry</a></li>
<li class="toctree-l1"><a class="reference internal" href="09_practical_methods__implement_your_own_riemannian_geometry.html">Tutorial: Implement your own Riemannian Geometry</a></li>
<li class="toctree-l1"><a class="reference internal" href="10_practical_methods__shape_analysis.html">Tutorial: Shape analysis of curves with the Square Root Velocity metric</a></li>
<li class="toctree-l1"><a class="reference internal" href="11_real_world_applications__cell_shapes_analysis.html">Shape Analysis of Cancer Cells</a></li>
<li class="toctree-l1"><a class="reference internal" href="11_real_world_applications__cell_shapes_analysis.html#1.-Introduction-and-Motivation">1. Introduction and Motivation</a></li>
<li class="toctree-l1"><a class="reference internal" href="11_real_world_applications__cell_shapes_analysis.html#2.-Dataset-Description">2. Dataset Description</a></li>
<li class="toctree-l1"><a class="reference internal" href="11_real_world_applications__cell_shapes_analysis.html#3.-Preprocessing">3. Preprocessing</a></li>
<li class="toctree-l1"><a class="reference internal" href="11_real_world_applications__cell_shapes_analysis.html#4-Data-Analysis">4 Data Analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="11_real_world_applications__cell_shapes_analysis.html#Analyze-Distances-to-the-&quot;Global&quot;-Mean-Shape">Analyze Distances to the “Global” Mean Shape</a></li>
<li class="toctree-l1"><a class="reference internal" href="11_real_world_applications__cell_shapes_analysis.html#Hypothesis-Testing-on-Equality-of-Means">Hypothesis Testing on Equality of Means</a></li>
<li class="toctree-l1"><a class="reference internal" href="11_real_world_applications__cell_shapes_analysis.html#Visualization-of-the-Mean-of-each-Treatment">Visualization of the Mean of each Treatment</a></li>
<li class="toctree-l1"><a class="reference internal" href="11_real_world_applications__cell_shapes_analysis.html#Distance-of-the-Cell-Shapes-to-their-Own-Mean-Shape">Distance of the Cell Shapes to their Own Mean Shape</a></li>
<li class="toctree-l1"><a class="reference internal" href="12_real_world_applications__emg_sign_classification_in_spd_manifold.html">Tutorial: Hand gesture classification with EMG data using Riemannian metrics</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Tutorial: Hyperbolic Embedding of Graphs and Clustering</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#Introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#Setup">Setup</a></li>
<li class="toctree-l2"><a class="reference internal" href="#Parameters-and-Initialization">Parameters and Initialization</a></li>
<li class="toctree-l2"><a class="reference internal" href="#Loss-function.">Loss function.</a></li>
<li class="toctree-l2"><a class="reference internal" href="#Riemannian-optimization.">Riemannian optimization.</a></li>
<li class="toctree-l2"><a class="reference internal" href="#Capturing-the-graph-structure">Capturing the graph structure</a></li>
<li class="toctree-l2"><a class="reference internal" href="#Numerically-optimizing-the-loss-function">Numerically optimizing the loss function</a></li>
<li class="toctree-l2"><a class="reference internal" href="#Plotting-results">Plotting results</a></li>
<li class="toctree-l2"><a class="reference internal" href="#References">References</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="14_real_world_applications__hand_poses_analysis_in_kendall_shape_space.html">Tutorial: Classifying hands poses with Kendall shape spaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="15_real_world_applications__optic_nerve_heads_analysis_in_kendall_shape_space.html">Tutorial: Computing with shapes of landmarks in Kendall shape spaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="16_real_world_applications__visualizations_in_kendall_shape_spaces.html">Tutorial : Computing with triangular shapes in Kendall framework</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Geomstats</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Tutorial: Hyperbolic Embedding of Graphs and Clustering</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/notebooks/13_real_world_applications__graph_embedding_and_clustering_in_hyperbolic_space.ipynb.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  
<style>
/* CSS for nbsphinx extension */

/* remove conflicting styling from Sphinx themes */
div.nbinput.container div.prompt *,
div.nboutput.container div.prompt *,
div.nbinput.container div.input_area pre,
div.nboutput.container div.output_area pre,
div.nbinput.container div.input_area .highlight,
div.nboutput.container div.output_area .highlight {
    border: none;
    padding: 0;
    margin: 0;
    box-shadow: none;
}

div.nbinput.container > div[class*=highlight],
div.nboutput.container > div[class*=highlight] {
    margin: 0;
}

div.nbinput.container div.prompt *,
div.nboutput.container div.prompt * {
    background: none;
}

div.nboutput.container div.output_area .highlight,
div.nboutput.container div.output_area pre {
    background: unset;
}

div.nboutput.container div.output_area div.highlight {
    color: unset;  /* override Pygments text color */
}

/* avoid gaps between output lines */
div.nboutput.container div[class*=highlight] pre {
    line-height: normal;
}

/* input/output containers */
div.nbinput.container,
div.nboutput.container {
    display: -webkit-flex;
    display: flex;
    align-items: flex-start;
    margin: 0;
    width: 100%;
}
@media (max-width: 540px) {
    div.nbinput.container,
    div.nboutput.container {
        flex-direction: column;
    }
}

/* input container */
div.nbinput.container {
    padding-top: 5px;
}

/* last container */
div.nblast.container {
    padding-bottom: 5px;
}

/* input prompt */
div.nbinput.container div.prompt pre {
    color: #307FC1;
}

/* output prompt */
div.nboutput.container div.prompt pre {
    color: #BF5B3D;
}

/* all prompts */
div.nbinput.container div.prompt,
div.nboutput.container div.prompt {
    width: 4.5ex;
    padding-top: 5px;
    position: relative;
    user-select: none;
}

div.nbinput.container div.prompt > div,
div.nboutput.container div.prompt > div {
    position: absolute;
    right: 0;
    margin-right: 0.3ex;
}

@media (max-width: 540px) {
    div.nbinput.container div.prompt,
    div.nboutput.container div.prompt {
        width: unset;
        text-align: left;
        padding: 0.4em;
    }
    div.nboutput.container div.prompt.empty {
        padding: 0;
    }

    div.nbinput.container div.prompt > div,
    div.nboutput.container div.prompt > div {
        position: unset;
    }
}

/* disable scrollbars on prompts */
div.nbinput.container div.prompt pre,
div.nboutput.container div.prompt pre {
    overflow: hidden;
}

/* input/output area */
div.nbinput.container div.input_area,
div.nboutput.container div.output_area {
    -webkit-flex: 1;
    flex: 1;
    overflow: auto;
}
@media (max-width: 540px) {
    div.nbinput.container div.input_area,
    div.nboutput.container div.output_area {
        width: 100%;
    }
}

/* input area */
div.nbinput.container div.input_area {
    border: 1px solid #e0e0e0;
    border-radius: 2px;
    /*background: #f5f5f5;*/
}

/* override MathJax center alignment in output cells */
div.nboutput.container div[class*=MathJax] {
    text-align: left !important;
}

/* override sphinx.ext.imgmath center alignment in output cells */
div.nboutput.container div.math p {
    text-align: left;
}

/* standard error */
div.nboutput.container div.output_area.stderr {
    background: #fdd;
}

/* ANSI colors */
.ansi-black-fg { color: #3E424D; }
.ansi-black-bg { background-color: #3E424D; }
.ansi-black-intense-fg { color: #282C36; }
.ansi-black-intense-bg { background-color: #282C36; }
.ansi-red-fg { color: #E75C58; }
.ansi-red-bg { background-color: #E75C58; }
.ansi-red-intense-fg { color: #B22B31; }
.ansi-red-intense-bg { background-color: #B22B31; }
.ansi-green-fg { color: #00A250; }
.ansi-green-bg { background-color: #00A250; }
.ansi-green-intense-fg { color: #007427; }
.ansi-green-intense-bg { background-color: #007427; }
.ansi-yellow-fg { color: #DDB62B; }
.ansi-yellow-bg { background-color: #DDB62B; }
.ansi-yellow-intense-fg { color: #B27D12; }
.ansi-yellow-intense-bg { background-color: #B27D12; }
.ansi-blue-fg { color: #208FFB; }
.ansi-blue-bg { background-color: #208FFB; }
.ansi-blue-intense-fg { color: #0065CA; }
.ansi-blue-intense-bg { background-color: #0065CA; }
.ansi-magenta-fg { color: #D160C4; }
.ansi-magenta-bg { background-color: #D160C4; }
.ansi-magenta-intense-fg { color: #A03196; }
.ansi-magenta-intense-bg { background-color: #A03196; }
.ansi-cyan-fg { color: #60C6C8; }
.ansi-cyan-bg { background-color: #60C6C8; }
.ansi-cyan-intense-fg { color: #258F8F; }
.ansi-cyan-intense-bg { background-color: #258F8F; }
.ansi-white-fg { color: #C5C1B4; }
.ansi-white-bg { background-color: #C5C1B4; }
.ansi-white-intense-fg { color: #A1A6B2; }
.ansi-white-intense-bg { background-color: #A1A6B2; }

.ansi-default-inverse-fg { color: #FFFFFF; }
.ansi-default-inverse-bg { background-color: #000000; }

.ansi-bold { font-weight: bold; }
.ansi-underline { text-decoration: underline; }


div.nbinput.container div.input_area div[class*=highlight] > pre,
div.nboutput.container div.output_area div[class*=highlight] > pre,
div.nboutput.container div.output_area div[class*=highlight].math,
div.nboutput.container div.output_area.rendered_html,
div.nboutput.container div.output_area > div.output_javascript,
div.nboutput.container div.output_area:not(.rendered_html) > img{
    padding: 5px;
    margin: 0;
}

/* fix copybtn overflow problem in chromium (needed for 'sphinx_copybutton') */
div.nbinput.container div.input_area > div[class^='highlight'],
div.nboutput.container div.output_area > div[class^='highlight']{
    overflow-y: hidden;
}

/* hide copybtn icon on prompts (needed for 'sphinx_copybutton') */
.prompt .copybtn {
    display: none;
}

/* Some additional styling taken form the Jupyter notebook CSS */
div.rendered_html table {
  border: none;
  border-collapse: collapse;
  border-spacing: 0;
  color: black;
  font-size: 12px;
  table-layout: fixed;
}
div.rendered_html thead {
  border-bottom: 1px solid black;
  vertical-align: bottom;
}
div.rendered_html tr,
div.rendered_html th,
div.rendered_html td {
  text-align: right;
  vertical-align: middle;
  padding: 0.5em 0.5em;
  line-height: normal;
  white-space: normal;
  max-width: none;
  border: none;
}
div.rendered_html th {
  font-weight: bold;
}
div.rendered_html tbody tr:nth-child(odd) {
  background: #f5f5f5;
}
div.rendered_html tbody tr:hover {
  background: rgba(66, 165, 245, 0.2);
}

/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<div class="admonition note">
  <p>Notebook source code:
    <a class="reference external" href="https://github.com/geomstats/geomstats/blob/master/notebooks/13_real_world_applications__graph_embedding_and_clustering_in_hyperbolic_space.ipynb">notebooks/13_real_world_applications__graph_embedding_and_clustering_in_hyperbolic_space.ipynb</a>
    <br>Run it yourself on binder
    <a href="https://mybinder.org/v2/gh/geomstats/geomstats/master?filepath=notebooks/13_real_world_applications__graph_embedding_and_clustering_in_hyperbolic_space.ipynb"><img alt="Binder badge"
    src="https://mybinder.org/badge_logo.svg"
    style="vertical-align:text-bottom"></a>
  </p>
</div><div class="section" id="Tutorial:-Hyperbolic-Embedding-of-Graphs-and-Clustering">
<h1>Tutorial: Hyperbolic Embedding of Graphs and Clustering<a class="headerlink" href="#Tutorial:-Hyperbolic-Embedding-of-Graphs-and-Clustering" title="Permalink to this headline"></a></h1>
<p>Lead authors: Thomas Gerald and Hadi Zaatiti.</p>
<div class="section" id="Introduction">
<h2>Introduction<a class="headerlink" href="#Introduction" title="Permalink to this headline"></a></h2>
<p>From social networks to parse trees, knowledge graphs to protein interaction networks, Graph-Structured Data is endemic to a wide variety of natural and engineered systems. Often, understanding the structure and/or dynamics of these graphs yields insight into the systems under investigation. Take, for example, the problems of finding key influencers or distinct communities within social networks.</p>
<p>The goal of graph embedding is to find a way of representing the graph in a space which more readily lends itself to analysis/investigation. One approach is to identify points in a vector space with nodes of the graph in such a way that important relations between nodes are preserved via relations between their corresponding points.</p>
<p>There are a wide variety of methods which approach this problem in different ways and for different aims, say for clustering or for link prediction. Recently, the embedding of Graph Structured Data (GSD) on manifolds has received considerable attention. In particular, much work has shown that hyperbolic spaces are beneficial for a wide variety of tasks with GSD <a class="reference external" href="#References">[ND2017]</a>. This tutorial shows how to learn such embeddings using the Poincaré Ball manifold and the well-known ‘Karate
Club’ social network dataset with <code class="docutils literal notranslate"><span class="pre">geomstats</span></code>. This data and several others can be found in the <code class="docutils literal notranslate"><span class="pre">datasets.data</span></code> module of the project’s github repository.</p>
<p><img alt="KarateEmbedding" src="../_images/karate_embedding_iterations.gif" /> <em>Learning a Poincaré disk embedding of the Karate club graph dataset</em></p>
</div>
<div class="section" id="Setup">
<h2>Setup<a class="headerlink" href="#Setup" title="Permalink to this headline"></a></h2>
<p>We start by importing standard tools for logging and visualization, allowing us to draw the embedding of the GSD on the manifold. Next, we import the manifold of interest, visualization tools, and other methods from <code class="docutils literal notranslate"><span class="pre">geomstats</span></code>.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span> In [1]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()))</span>
<span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span> In [2]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="kn">import</span> <span class="nn">geomstats.backend</span> <span class="k">as</span> <span class="nn">gs</span>
<span class="kn">import</span> <span class="nn">geomstats.visualization</span> <span class="k">as</span> <span class="nn">visualization</span>

<span class="kn">from</span> <span class="nn">geomstats.datasets.utils</span> <span class="kn">import</span> <span class="n">load_karate_graph</span>
<span class="kn">from</span> <span class="nn">geomstats.geometry.poincare_ball</span> <span class="kn">import</span> <span class="n">PoincareBall</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area stderr docutils container">
<div class="highlight"><pre>
INFO: Using numpy backend
</pre></div></div>
</div>
</div>
<div class="section" id="Parameters-and-Initialization">
<h2>Parameters and Initialization<a class="headerlink" href="#Parameters-and-Initialization" title="Permalink to this headline"></a></h2>
<p>We define the following parameters needed for embedding:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Parameter</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>random.seed</p></td>
<td><p>An initial manually set number for generating
pseudorandom numbers</p></td>
</tr>
<tr class="row-odd"><td><p>dim</p></td>
<td><p>Dimensions of the manifold used for embedding</p></td>
</tr>
<tr class="row-even"><td><p>max_epochs</p></td>
<td><p>Number of iterations for learning the embedding</p></td>
</tr>
<tr class="row-odd"><td><p>lr</p></td>
<td><p>Learning rate</p></td>
</tr>
<tr class="row-even"><td><p>n_negative</p></td>
<td><p>Number of negative samples</p></td>
</tr>
<tr class="row-odd"><td><p>context_size</p></td>
<td><p>Size of the considered context for each node of the
graph</p></td>
</tr>
</tbody>
</table>
<p>Let us discuss a few things about the parameters of the above table. The number of dimensions should be high (i.e., 10+) for large datasets (i.e., where the number of nodes/edges is significantly large). In this tutorial we consider a dataset that is quite small with only 34 nodes. The Poincaré disk of only two dimensions is therefore sufficient to capture the complexity of the graph and provide a faithful representation. Some parameters are hard to know in advance, such as <code class="docutils literal notranslate"><span class="pre">max_epochs</span></code> and
<code class="docutils literal notranslate"><span class="pre">lr</span></code>. These should be tuned specifically for each dataset. Visualization can help with tuning the parameters. Also, one can perform a grid search to find values of these parameters which maximize some performance function. In learning embeddings, one can consider performance metrics such as a measure for cluster seperability or normalized mutual information (NMI) or others. Similarly, the number of negative samples and context size can also be thought of as hyperparameters and will be further
discussed in the sequel. An instance of the <code class="docutils literal notranslate"><span class="pre">Graph</span></code> class is created and set to the Karate club dataset.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span> In [2]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gs</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">1234</span><span class="p">)</span>
<span class="n">dim</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">max_epochs</span> <span class="o">=</span> <span class="mi">100</span>
<span class="n">lr</span> <span class="o">=</span> <span class="mf">0.05</span>
<span class="n">n_negative</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">context_size</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">karate_graph</span> <span class="o">=</span> <span class="n">load_karate_graph</span><span class="p">()</span>
</pre></div>
</div>
</div>
<p>The Zachary karate club network was collected from the members of a university karate club by Wayne Zachary in 1977. Each node represents a member of the club, and each edge represents an undirected relation between two members. An often discussed problem using this dataset is to find the two groups of people into which the karate club split after an argument between two teachers. <img alt="dcb174a401c5492680d1cca9790b63ef" class="no-scaled-link" src="../_images/karate_graph.png" style="width: 60%;" /> Some information about the dataset is displayed to provide insight into its
complexity.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span> In [3]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">nb_vertices_by_edges</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">e_2</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">e_2</span> <span class="ow">in</span> <span class="n">karate_graph</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>
<span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Number of vertices: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">karate_graph</span><span class="o">.</span><span class="n">edges</span><span class="p">))</span>
<span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
    <span class="s2">&quot;Mean edge-vertex ratio: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">nb_vertices_by_edges</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">karate_graph</span><span class="o">.</span><span class="n">edges</span><span class="p">)),</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area stderr docutils container">
<div class="highlight"><pre>
INFO: Number of vertices: 34
INFO: Mean edge-vertex ratio: 4.588235294117647
</pre></div></div>
</div>
<p>Denote <span class="math notranslate nohighlight">\(V\)</span> as the set of nodes and <span class="math notranslate nohighlight">\(E \subset V\times V\)</span> the set of edges. The goal of embedding GSD is to provide a faithful and exploitable representation of the graph structure. It is mainly achieved by preserving <em>first-order</em> proximity that enforces nodes sharing edges to be close to each other. It can additionally preserve <em>second-order</em> proximity that enforces two nodes sharing the same context (i.e., nodes that share neighbors but are not necessarily directly connected) to be
close. Let <span class="math notranslate nohighlight">\(\mathbb{B}^m\)</span> be the Poincaré Ball of dimension <span class="math notranslate nohighlight">\(m\)</span> equipped with the distance function <span class="math notranslate nohighlight">\(d\)</span>. The below figure shows geodesics between pairs of points on <span class="math notranslate nohighlight">\(\mathbb{B}^2\)</span>. Geodesics are the shortest path between two points. The distance function <span class="math notranslate nohighlight">\(d\)</span> of two points is the length of the geodesic that links them.</p>
<p><img alt="b41c5c431cbc48bb826da499e21a5a01" class="no-scaled-link" src="../_images/geodesics.png" style="width: 40%;" /></p>
<p>Declaring an instance of the <code class="docutils literal notranslate"><span class="pre">PoincareBall</span></code> manifold of two dimensions in <code class="docutils literal notranslate"><span class="pre">geomstats</span></code> is straightforward:</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span> In [4]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">hyperbolic_manifold</span> <span class="o">=</span> <span class="n">PoincareBall</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p><em>first</em> and <em>second-order</em> proximities can be achieved by optimising the following loss functions:</p>
</div>
<div class="section" id="Loss-function.">
<h2>Loss function.<a class="headerlink" href="#Loss-function." title="Permalink to this headline"></a></h2>
<p>To preserve first and second-order proximities we adopt a loss function similar to (Nickel, 2017) and consider the negative sampling approach as in (Mikolov, 2013) :</p>
<div class="math notranslate nohighlight">
\[\mathcal{L} = - \sum_{v_i\in V} \sum_{v_j \in C_i} \bigg[ log(\sigma(-d^2(\phi_i, \phi_j'))) + \sum_{v_k\sim \mathcal{P}_n} log(\sigma(d^2(\phi_i, \phi_k')))  \bigg]\]</div>
<p>where <span class="math notranslate nohighlight">\(\sigma(x)=\frac{1}{1+e^{-x}}\)</span> is the sigmoid function and <span class="math notranslate nohighlight">\(\phi_i \in \mathbb{B}^m\)</span> is the embedding of the <span class="math notranslate nohighlight">\(i\)</span>-th node of <span class="math notranslate nohighlight">\(V\)</span>, <span class="math notranslate nohighlight">\(C_i\)</span> the nodes in the context of the <span class="math notranslate nohighlight">\(i\)</span>-th node, <span class="math notranslate nohighlight">\(\phi_j'\in \mathbb{B}^m\)</span> the embedding of <span class="math notranslate nohighlight">\(v_j\in C_i\)</span> and <span class="math notranslate nohighlight">\(\mathcal{P}_n\)</span> the negative sampling distribution over <span class="math notranslate nohighlight">\(V\)</span>: <span class="math notranslate nohighlight">\(\mathcal{P}_n(v)=\frac{deg(v)^{3/4}}{\sum_{v_i\in V}deg(v_i)^{3/4}}\)</span>. Intuitively one can see that to minimizing <span class="math notranslate nohighlight">\(L\)</span>,
the distance between <span class="math notranslate nohighlight">\(v_i\)</span> and <span class="math notranslate nohighlight">\(v_j\)</span> should get smaller, while the one between <span class="math notranslate nohighlight">\(v_i\)</span> and <span class="math notranslate nohighlight">\(v_k\)</span> would get larger. <img alt="6c010ed4ebdb440c9ca58f3a2b54b9d7" class="no-scaled-link" src="../_images/notations.png" style="width: 40%;" /></p>
</div>
<div class="section" id="Riemannian-optimization.">
<h2>Riemannian optimization.<a class="headerlink" href="#Riemannian-optimization." title="Permalink to this headline"></a></h2>
<p>Following the idea of (Ganea, 2018) we use the following formula to optimize <span class="math notranslate nohighlight">\(L\)</span>:</p>
<div class="math notranslate nohighlight">
\[\phi^{t+1} = \text{Exp}_{\phi^t} \left( -lr \frac{\partial L}{\partial \phi} \right)\]</div>
<p>where <span class="math notranslate nohighlight">\(\phi\)</span> is a parameter of <span class="math notranslate nohighlight">\(L\)</span>, <span class="math notranslate nohighlight">\(t\in\{1,2,\cdots\}\)</span> is the epoch iteration number and <span class="math notranslate nohighlight">\(lr\)</span> is the learning rate. The formula consists of first computing the usual gradient of the loss function giving the direction in which the parameter should move. The Riemannian exponential map <span class="math notranslate nohighlight">\(\text{Exp}\)</span> is a function that takes a base point <span class="math notranslate nohighlight">\(\phi^t\)</span> and some direction vector <span class="math notranslate nohighlight">\(T\)</span> and returns the point <span class="math notranslate nohighlight">\(\phi^{t+1}\)</span> such that <span class="math notranslate nohighlight">\(\phi^{t+1}\)</span> belongs to
the geodesic initiated from <span class="math notranslate nohighlight">\(\phi{t}\)</span> in the direction of <span class="math notranslate nohighlight">\(T\)</span> and the length of the geoedesic curve between <span class="math notranslate nohighlight">\(\phi^t\)</span> and <span class="math notranslate nohighlight">\(\phi^{t+1}\)</span> is of 1 unit. The Riemannian exponential map is implemented as a method of the <code class="docutils literal notranslate"><span class="pre">PoincareBallMetric</span></code> class in the <code class="docutils literal notranslate"><span class="pre">geometry</span></code> module of <code class="docutils literal notranslate"><span class="pre">geomstats</span></code>.</p>
<p>Therefore to minimize <span class="math notranslate nohighlight">\(L\)</span> we will need to compute its gradient. Several steps are required to do so, 1. Compute the gradient of the squared distance 2. Compute the gradient of the log sigmoid 3. Compute the gradient of the composision of 1. and 2.</p>
<p>For 1., we use the formula proposed by (Arnaudon, 2013) which uses the Riemannian logarithmic map to compute the gradient of the distance. This is implemented as</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span> In [5]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">grad_squared_distance</span><span class="p">(</span><span class="n">point_a</span><span class="p">,</span> <span class="n">point_b</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Gradient of squared hyperbolic distance.</span>

<span class="sd">    Gradient of the squared distance based on the</span>
<span class="sd">    Ball representation according to point_a</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    point_a : array-like, shape=[n_samples, dim]</span>
<span class="sd">        First point in hyperbolic space.</span>
<span class="sd">    point_b : array-like, shape=[n_samples, dim]</span>
<span class="sd">        Second point in hyperbolic space.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dist : array-like, shape=[n_samples, 1]</span>
<span class="sd">        Geodesic squared distance between the two points.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">hyperbolic_metric</span> <span class="o">=</span> <span class="n">PoincareBall</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">metric</span>
    <span class="n">log_map</span> <span class="o">=</span> <span class="n">hyperbolic_metric</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">point_b</span><span class="p">,</span> <span class="n">point_a</span><span class="p">)</span>

    <span class="k">return</span> <span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">log_map</span>
</pre></div>
</div>
</div>
<p>For 2. define the <code class="docutils literal notranslate"><span class="pre">log_sigmoid</span></code> corresponding as follows:</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span> In [6]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">log_sigmoid</span><span class="p">(</span><span class="n">vector</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Logsigmoid function.</span>

<span class="sd">    Apply log sigmoid function</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    vector : array-like, shape=[n_samples, dim]</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    result : array-like, shape=[n_samples, dim]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">gs</span><span class="o">.</span><span class="n">log</span><span class="p">((</span><span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">gs</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">vector</span><span class="p">))))</span>
</pre></div>
</div>
</div>
<p>The gradient of the logarithm of sigmoid function is implemented as:</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span> In [7]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">grad_log_sigmoid</span><span class="p">(</span><span class="n">vector</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Gradient of log sigmoid function.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    vector : array-like, shape=[n_samples, dim]</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    gradient : array-like, shape=[n_samples, dim]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">gs</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">vector</span><span class="p">))</span>
</pre></div>
</div>
</div>
<p>For 3., apply the composition rule to obtain the gradient of <span class="math notranslate nohighlight">\(L\)</span>. The following function given <span class="math notranslate nohighlight">\(\phi_i\)</span>, <span class="math notranslate nohighlight">\(\phi'_j\)</span> and <span class="math notranslate nohighlight">\(\phi'_k\)</span> returns the total value of <span class="math notranslate nohighlight">\(L\)</span> and its gradient vector at <span class="math notranslate nohighlight">\(\phi_i\)</span>. For the value of <span class="math notranslate nohighlight">\(L\)</span> the loss function formula is simply applied. For the gradient, we apply the composition of <code class="docutils literal notranslate"><span class="pre">grad_log_sigmoid</span></code> with <code class="docutils literal notranslate"><span class="pre">grad_squared_distance</span></code> while paying attention to the signs.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span> In [8]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">loss</span><span class="p">(</span><span class="n">example_embedding</span><span class="p">,</span> <span class="n">context_embedding</span><span class="p">,</span> <span class="n">negative_embedding</span><span class="p">,</span> <span class="n">manifold</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute loss and grad.</span>

<span class="sd">    Compute loss and grad given embedding of the current example,</span>
<span class="sd">    embedding of the context and negative sampling embedding.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n_edges</span><span class="p">,</span> <span class="n">dim</span> <span class="o">=</span> <span class="n">negative_embedding</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">example_embedding</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">example_embedding</span> <span class="o">=</span> <span class="n">gs</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">example_embedding</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">context_embedding</span> <span class="o">=</span> <span class="n">gs</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">context_embedding</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">positive_distance</span> <span class="o">=</span> <span class="n">manifold</span><span class="o">.</span><span class="n">metric</span><span class="o">.</span><span class="n">squared_dist</span><span class="p">(</span>
        <span class="n">example_embedding</span><span class="p">,</span> <span class="n">context_embedding</span>
    <span class="p">)</span>
    <span class="n">positive_loss</span> <span class="o">=</span> <span class="n">log_sigmoid</span><span class="p">(</span><span class="o">-</span><span class="n">positive_distance</span><span class="p">)</span>

    <span class="n">reshaped_example_embedding</span> <span class="o">=</span> <span class="n">gs</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">example_embedding</span><span class="p">,</span> <span class="n">n_edges</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">negative_distance</span> <span class="o">=</span> <span class="n">manifold</span><span class="o">.</span><span class="n">metric</span><span class="o">.</span><span class="n">squared_dist</span><span class="p">(</span>
        <span class="n">reshaped_example_embedding</span><span class="p">,</span> <span class="n">negative_embedding</span>
    <span class="p">)</span>
    <span class="n">negative_loss</span> <span class="o">=</span> <span class="n">log_sigmoid</span><span class="p">(</span><span class="n">negative_distance</span><span class="p">)</span>

    <span class="n">total_loss</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">positive_loss</span> <span class="o">+</span> <span class="n">negative_loss</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>

    <span class="n">positive_log_sigmoid_grad</span> <span class="o">=</span> <span class="o">-</span><span class="n">grad_log_sigmoid</span><span class="p">(</span><span class="o">-</span><span class="n">positive_distance</span><span class="p">)</span>

    <span class="n">positive_distance_grad</span> <span class="o">=</span> <span class="n">grad_squared_distance</span><span class="p">(</span><span class="n">example_embedding</span><span class="p">,</span> <span class="n">context_embedding</span><span class="p">)</span>

    <span class="n">positive_grad</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">gs</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">positive_log_sigmoid_grad</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">positive_distance_grad</span>
    <span class="p">)</span>

    <span class="n">negative_distance_grad</span> <span class="o">=</span> <span class="n">grad_squared_distance</span><span class="p">(</span>
        <span class="n">reshaped_example_embedding</span><span class="p">,</span> <span class="n">negative_embedding</span>
    <span class="p">)</span>

    <span class="n">negative_distance</span> <span class="o">=</span> <span class="n">gs</span><span class="o">.</span><span class="n">to_ndarray</span><span class="p">(</span><span class="n">negative_distance</span><span class="p">,</span> <span class="n">to_ndim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">negative_log_sigmoid_grad</span> <span class="o">=</span> <span class="n">grad_log_sigmoid</span><span class="p">(</span><span class="n">negative_distance</span><span class="p">)</span>

    <span class="n">negative_grad</span> <span class="o">=</span> <span class="n">negative_log_sigmoid_grad</span> <span class="o">*</span> <span class="n">negative_distance_grad</span>
    <span class="n">example_grad</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">positive_grad</span> <span class="o">+</span> <span class="n">negative_grad</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">total_loss</span><span class="p">,</span> <span class="n">example_grad</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="Capturing-the-graph-structure">
<h2>Capturing the graph structure<a class="headerlink" href="#Capturing-the-graph-structure" title="Permalink to this headline"></a></h2>
<p>At this point we have the necessary bricks to compute the resulting gradient of <span class="math notranslate nohighlight">\(L\)</span>. We are ready to prepare the nodes <span class="math notranslate nohighlight">\(v_i\)</span>, <span class="math notranslate nohighlight">\(v_j\)</span> and <span class="math notranslate nohighlight">\(v_k\)</span> and initialise their embeddings <span class="math notranslate nohighlight">\(\phi_i\)</span>, <span class="math notranslate nohighlight">\(\phi^{'}_j\)</span> and <span class="math notranslate nohighlight">\(\phi^{'}_k\)</span>. First, initialize an array that will hold embeddings <span class="math notranslate nohighlight">\(\phi_i\)</span> of each node <span class="math notranslate nohighlight">\(v_i\in V\)</span> with random points belonging to the Poincaré disk.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span> In [9]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">embeddings</span> <span class="o">=</span> <span class="n">gs</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">karate_graph</span><span class="o">.</span><span class="n">n_nodes</span><span class="p">,</span> <span class="n">dim</span><span class="p">))</span>
<span class="n">embeddings</span> <span class="o">=</span> <span class="n">embeddings</span> <span class="o">*</span> <span class="mf">0.2</span>
</pre></div>
</div>
</div>
<p>Next, to prepare the context nodes <span class="math notranslate nohighlight">\(v_j\)</span> for each node <span class="math notranslate nohighlight">\(v_i\)</span>, we compute random walks initialised from each <span class="math notranslate nohighlight">\(v_i\)</span> up to some length (5 by default). The latter is done via a special function within the <code class="docutils literal notranslate"><span class="pre">Graph</span></code> class. The nodes <span class="math notranslate nohighlight">\(v_j\)</span> will be later picked from the random walk of <span class="math notranslate nohighlight">\(v_i\)</span>.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span> In [10]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">random_walks</span> <span class="o">=</span> <span class="n">karate_graph</span><span class="o">.</span><span class="n">random_walk</span><span class="p">()</span>
</pre></div>
</div>
</div>
<p>Negatively sampled nodes <span class="math notranslate nohighlight">\(v_k\)</span> are chosen according to the previously defined probability distribution function <span class="math notranslate nohighlight">\(\mathcal{P}_n(v_k)\)</span> implemented as</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span> In [11]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">negative_table_parameter</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">negative_sampling_table</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">nb_v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nb_vertices_by_edges</span><span class="p">):</span>
    <span class="n">negative_sampling_table</span> <span class="o">+=</span> <span class="p">(</span>
        <span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="nb">int</span><span class="p">((</span><span class="n">nb_v</span> <span class="o">**</span> <span class="p">(</span><span class="mf">3.0</span> <span class="o">/</span> <span class="mf">4.0</span><span class="p">)))</span> <span class="o">*</span> <span class="n">negative_table_parameter</span>
    <span class="p">)</span>

<span class="n">negative_sampling_table</span> <span class="o">=</span> <span class="n">gs</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">negative_sampling_table</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="Numerically-optimizing-the-loss-function">
<h2>Numerically optimizing the loss function<a class="headerlink" href="#Numerically-optimizing-the-loss-function" title="Permalink to this headline"></a></h2>
<p>Optimising the loss function is performed numerically over the number of epochs. At each iteration, we will compute the gradient of <span class="math notranslate nohighlight">\(L\)</span>. Then the graph nodes are moved in the direction pointed by the gradient. The movement of the nodes is performed by following geodesics in the gradient direction. The key to obtain an embedding representing accurately the dataset, is to move the nodes smoothly rather than brutal movements. This is done by tuning the learning rate, such as at each epoch all
the nodes made small movements.</p>
<p>A <em>first level</em> loop iterates over the epochs, the table <code class="docutils literal notranslate"><span class="pre">total_loss</span></code> will record the value of <span class="math notranslate nohighlight">\(L\)</span> at each iteration and help us track the minimization of <span class="math notranslate nohighlight">\(L\)</span>.</p>
<p>A <em>second level</em> nested loop iterates over each path in the previously computed random walks. Observing these walks, notice that nodes having many edges appear more often. Such nodes can be considered as important crossroads and will therefore be subject to a greater number of embedding updates. This is one of the main reasons why random walks have proven to be effective in capturing the structure of graphs. The context of each <span class="math notranslate nohighlight">\(v_i\)</span> will be the set of nodes <span class="math notranslate nohighlight">\(v_j\)</span> belonging to the
random walk from <span class="math notranslate nohighlight">\(v_i\)</span>. The <code class="docutils literal notranslate"><span class="pre">context_size</span></code> specified earlier will limit the length of the walk to be considered. Similarly, we use the same <code class="docutils literal notranslate"><span class="pre">context_size</span></code> to limit the number of negative samples. We find <span class="math notranslate nohighlight">\(\phi_i\)</span> from the <code class="docutils literal notranslate"><span class="pre">embeddings</span></code> array.</p>
<p>A <em>third level</em> nested loop will iterate on each <span class="math notranslate nohighlight">\(v_j\)</span> and <span class="math notranslate nohighlight">\(v_k\)</span>. From within, we find <span class="math notranslate nohighlight">\(\phi'_j\)</span> and <span class="math notranslate nohighlight">\(\phi'_k\)</span> then call the <code class="docutils literal notranslate"><span class="pre">loss</span></code> function to compute the gradient. Then the Riemannian exponential map is applied to find the new value of <span class="math notranslate nohighlight">\(\phi_i\)</span> as we mentioned before.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span> In [12]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_epochs</span><span class="p">):</span>
    <span class="n">total_loss</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">random_walks</span><span class="p">:</span>

        <span class="k">for</span> <span class="n">example_index</span><span class="p">,</span> <span class="n">one_path</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
            <span class="n">context_index</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span>
                <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">example_index</span> <span class="o">-</span> <span class="n">context_size</span><span class="p">)</span> <span class="p">:</span> <span class="nb">min</span><span class="p">(</span>
                    <span class="n">example_index</span> <span class="o">+</span> <span class="n">context_size</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">]</span>
            <span class="n">negative_index</span> <span class="o">=</span> <span class="n">gs</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span>
                <span class="n">negative_sampling_table</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">context_index</span><span class="p">),</span> <span class="n">n_negative</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">negative_index</span> <span class="o">=</span> <span class="n">negative_sampling_table</span><span class="p">[</span><span class="n">negative_index</span><span class="p">]</span>

            <span class="n">example_embedding</span> <span class="o">=</span> <span class="n">embeddings</span><span class="p">[</span><span class="n">one_path</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">one_context_i</span><span class="p">,</span> <span class="n">one_negative_i</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">context_index</span><span class="p">,</span> <span class="n">negative_index</span><span class="p">):</span>
                <span class="n">context_embedding</span> <span class="o">=</span> <span class="n">embeddings</span><span class="p">[</span><span class="n">one_context_i</span><span class="p">]</span>
                <span class="n">negative_embedding</span> <span class="o">=</span> <span class="n">embeddings</span><span class="p">[</span><span class="n">one_negative_i</span><span class="p">]</span>
                <span class="n">l</span><span class="p">,</span> <span class="n">g_ex</span> <span class="o">=</span> <span class="n">loss</span><span class="p">(</span>
                    <span class="n">example_embedding</span><span class="p">,</span>
                    <span class="n">context_embedding</span><span class="p">,</span>
                    <span class="n">negative_embedding</span><span class="p">,</span>
                    <span class="n">hyperbolic_manifold</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">total_loss</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>

                <span class="n">example_to_update</span> <span class="o">=</span> <span class="n">embeddings</span><span class="p">[</span><span class="n">one_path</span><span class="p">]</span>
                <span class="n">embeddings</span><span class="p">[</span><span class="n">one_path</span><span class="p">]</span> <span class="o">=</span> <span class="n">hyperbolic_manifold</span><span class="o">.</span><span class="n">metric</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span>
                    <span class="o">-</span><span class="n">lr</span> <span class="o">*</span> <span class="n">g_ex</span><span class="p">,</span> <span class="n">example_to_update</span>
                <span class="p">)</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
        <span class="s2">&quot;iteration </span><span class="si">%d</span><span class="s2"> loss_value </span><span class="si">%f</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">epoch</span><span class="p">,</span> <span class="nb">sum</span><span class="p">(</span><span class="n">total_loss</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">total_loss</span><span class="p">)</span>
    <span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area stderr docutils container">
<div class="highlight"><pre>
INFO: iteration 0 loss_value 1.826876
INFO: iteration 1 loss_value 1.774560
INFO: iteration 2 loss_value 1.725700
INFO: iteration 3 loss_value 1.663358
INFO: iteration 4 loss_value 1.655706
INFO: iteration 5 loss_value 1.615405
INFO: iteration 6 loss_value 1.581097
INFO: iteration 7 loss_value 1.526418
INFO: iteration 8 loss_value 1.507913
INFO: iteration 9 loss_value 1.505934
INFO: iteration 10 loss_value 1.466526
INFO: iteration 11 loss_value 1.453769
INFO: iteration 12 loss_value 1.443878
INFO: iteration 13 loss_value 1.451272
INFO: iteration 14 loss_value 1.397864
INFO: iteration 15 loss_value 1.396170
INFO: iteration 16 loss_value 1.373677
INFO: iteration 17 loss_value 1.390120
INFO: iteration 18 loss_value 1.382397
INFO: iteration 19 loss_value 1.404103
INFO: iteration 20 loss_value 1.395782
INFO: iteration 21 loss_value 1.389617
INFO: iteration 22 loss_value 1.410152
INFO: iteration 23 loss_value 1.390600
INFO: iteration 24 loss_value 1.374832
INFO: iteration 25 loss_value 1.367194
INFO: iteration 26 loss_value 1.323190
INFO: iteration 27 loss_value 1.389616
INFO: iteration 28 loss_value 1.361034
INFO: iteration 29 loss_value 1.384930
INFO: iteration 30 loss_value 1.340814
INFO: iteration 31 loss_value 1.349682
INFO: iteration 32 loss_value 1.317423
INFO: iteration 33 loss_value 1.346869
INFO: iteration 34 loss_value 1.327198
INFO: iteration 35 loss_value 1.363809
INFO: iteration 36 loss_value 1.352347
INFO: iteration 37 loss_value 1.317670
INFO: iteration 38 loss_value 1.320039
INFO: iteration 39 loss_value 1.323888
INFO: iteration 40 loss_value 1.341444
INFO: iteration 41 loss_value 1.312259
INFO: iteration 42 loss_value 1.315983
INFO: iteration 43 loss_value 1.305483
INFO: iteration 44 loss_value 1.325384
INFO: iteration 45 loss_value 1.328024
INFO: iteration 46 loss_value 1.306958
INFO: iteration 47 loss_value 1.303357
INFO: iteration 48 loss_value 1.303790
INFO: iteration 49 loss_value 1.324749
INFO: iteration 50 loss_value 1.328376
INFO: iteration 51 loss_value 1.313816
INFO: iteration 52 loss_value 1.325978
INFO: iteration 53 loss_value 1.317516
INFO: iteration 54 loss_value 1.353495
INFO: iteration 55 loss_value 1.331988
INFO: iteration 56 loss_value 1.346874
INFO: iteration 57 loss_value 1.348946
INFO: iteration 58 loss_value 1.324719
INFO: iteration 59 loss_value 1.330355
INFO: iteration 60 loss_value 1.331077
INFO: iteration 61 loss_value 1.305729
INFO: iteration 62 loss_value 1.311746
INFO: iteration 63 loss_value 1.347637
INFO: iteration 64 loss_value 1.326300
INFO: iteration 65 loss_value 1.309570
INFO: iteration 66 loss_value 1.313999
INFO: iteration 67 loss_value 1.346287
INFO: iteration 68 loss_value 1.300901
INFO: iteration 69 loss_value 1.323723
INFO: iteration 70 loss_value 1.320784
INFO: iteration 71 loss_value 1.313709
INFO: iteration 72 loss_value 1.312143
INFO: iteration 73 loss_value 1.309172
INFO: iteration 74 loss_value 1.320642
INFO: iteration 75 loss_value 1.308333
INFO: iteration 76 loss_value 1.325884
INFO: iteration 77 loss_value 1.316740
INFO: iteration 78 loss_value 1.325933
INFO: iteration 79 loss_value 1.316672
INFO: iteration 80 loss_value 1.312291
INFO: iteration 81 loss_value 1.332372
INFO: iteration 82 loss_value 1.317499
INFO: iteration 83 loss_value 1.329194
INFO: iteration 84 loss_value 1.305926
INFO: iteration 85 loss_value 1.304747
INFO: iteration 86 loss_value 1.342343
INFO: iteration 87 loss_value 1.331992
INFO: iteration 88 loss_value 1.295439
INFO: iteration 89 loss_value 1.332853
INFO: iteration 90 loss_value 1.332004
INFO: iteration 91 loss_value 1.357248
INFO: iteration 92 loss_value 1.342234
INFO: iteration 93 loss_value 1.329379
INFO: iteration 94 loss_value 1.313617
INFO: iteration 95 loss_value 1.310320
INFO: iteration 96 loss_value 1.320590
INFO: iteration 97 loss_value 1.315822
INFO: iteration 98 loss_value 1.328819
INFO: iteration 99 loss_value 1.339718
</pre></div></div>
</div>
</div>
<div class="section" id="Plotting-results">
<h2>Plotting results<a class="headerlink" href="#Plotting-results" title="Permalink to this headline"></a></h2>
<p>Once the <code class="docutils literal notranslate"><span class="pre">max_epochs</span></code> iterations of epochs is achieved, we can plot the resulting <code class="docutils literal notranslate"><span class="pre">embeddings</span></code> array and the true labels shown as two colors. At 100 epochs we can see that the two group of nodes with different labels are moving away from each other on the manifold. If one increases the <code class="docutils literal notranslate"><span class="pre">max_epochs</span></code>, then further separability is achieved.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span> In [13]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.patches</span> <span class="k">as</span> <span class="nn">mpatches</span>

<span class="n">colors</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="s2">&quot;r&quot;</span><span class="p">}</span>
<span class="n">group_1</span> <span class="o">=</span> <span class="n">mpatches</span><span class="o">.</span><span class="n">Patch</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Group 1&quot;</span><span class="p">)</span>
<span class="n">group_2</span> <span class="o">=</span> <span class="n">mpatches</span><span class="o">.</span><span class="n">Patch</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Group 2&quot;</span><span class="p">)</span>

<span class="n">circle</span> <span class="o">=</span> <span class="n">visualization</span><span class="o">.</span><span class="n">PoincareDisk</span><span class="p">(</span><span class="n">point_type</span><span class="o">=</span><span class="s2">&quot;ball&quot;</span><span class="p">)</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
<span class="n">ax</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
<span class="n">circle</span><span class="o">.</span><span class="n">set_ax</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
<span class="n">circle</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i_embedding</span><span class="p">,</span> <span class="n">embedding</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">embeddings</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">embedding</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">embedding</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">pt_id</span> <span class="o">=</span> <span class="n">i_embedding</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="n">karate_graph</span><span class="o">.</span><span class="n">labels</span><span class="p">[</span><span class="n">pt_id</span><span class="p">][</span><span class="mi">0</span><span class="p">]],</span> <span class="n">s</span><span class="o">=</span><span class="mi">150</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">pt_id</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>

<span class="n">plt</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">which</span><span class="o">=</span><span class="s2">&quot;both&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Poincare Ball Embedding of the Karate Club Network&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">handles</span><span class="o">=</span><span class="p">[</span><span class="n">group_1</span><span class="p">,</span> <span class="n">group_2</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/notebooks_13_real_world_applications__graph_embedding_and_clustering_in_hyperbolic_space_37_0.png" src="../_images/notebooks_13_real_world_applications__graph_embedding_and_clustering_in_hyperbolic_space_37_0.png" />
</div>
</div>
<p>In <code class="docutils literal notranslate"><span class="pre">geomstats</span></code>, several unsupervized clustering algorithms on manifolds are implemented such as <span class="math notranslate nohighlight">\(K\)</span>-means and Expectation-Maximization.</p>
<p>Let us apply <span class="math notranslate nohighlight">\(K\)</span>-means to learn the node belonging of the two groups and see how well we predicted the true labels. Lets first import <span class="math notranslate nohighlight">\(K\)</span>-means</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span> In [14]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">geomstats.learning.kmeans</span> <span class="kn">import</span> <span class="n">RiemannianKMeans</span>
</pre></div>
</div>
</div>
<p>Set the number of groups to 2.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span> In [15]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">n_clusters</span> <span class="o">=</span> <span class="mi">2</span>
</pre></div>
</div>
</div>
<p>Initialize an instance of <span class="math notranslate nohighlight">\(K\)</span>-means.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span> In [16]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">kmeans</span> <span class="o">=</span> <span class="n">RiemannianKMeans</span><span class="p">(</span>
    <span class="n">metric</span><span class="o">=</span><span class="n">hyperbolic_manifold</span><span class="o">.</span><span class="n">metric</span><span class="p">,</span>
    <span class="n">n_clusters</span><span class="o">=</span><span class="n">n_clusters</span><span class="p">,</span>
    <span class="n">init</span><span class="o">=</span><span class="s2">&quot;random&quot;</span><span class="p">,</span>
    <span class="n">mean_method</span><span class="o">=</span><span class="s2">&quot;batch&quot;</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<p>Fit the embedded nodes</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span> In [17]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">centroids</span> <span class="o">=</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="o">=</span><span class="n">embeddings</span><span class="p">)</span>
<span class="n">labels</span> <span class="o">=</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X</span><span class="o">=</span><span class="n">embeddings</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>And plot the resulting labels provided by <span class="math notranslate nohighlight">\(K\)</span>-means</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span> In [18]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;g&quot;</span><span class="p">,</span> <span class="s2">&quot;c&quot;</span><span class="p">,</span> <span class="s2">&quot;m&quot;</span><span class="p">]</span>
<span class="n">circle</span> <span class="o">=</span> <span class="n">visualization</span><span class="o">.</span><span class="n">PoincareDisk</span><span class="p">(</span><span class="n">point_type</span><span class="o">=</span><span class="s2">&quot;ball&quot;</span><span class="p">)</span>
<span class="n">fig2</span><span class="p">,</span> <span class="n">ax2</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
<span class="n">circle</span><span class="o">.</span><span class="n">set_ax</span><span class="p">(</span><span class="n">ax2</span><span class="p">)</span>
<span class="n">circle</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax2</span><span class="p">)</span>
<span class="n">ax2</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
<span class="n">ax2</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
<span class="n">group_1_predicted</span> <span class="o">=</span> <span class="n">mpatches</span><span class="o">.</span><span class="n">Patch</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Predicted Group 1&quot;</span><span class="p">)</span>
<span class="n">group_2_predicted</span> <span class="o">=</span> <span class="n">mpatches</span><span class="o">.</span><span class="n">Patch</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Predicted Group 2&quot;</span><span class="p">)</span>
<span class="n">group_centroids</span> <span class="o">=</span> <span class="n">mpatches</span><span class="o">.</span><span class="n">Patch</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Cluster centroids&quot;</span><span class="p">)</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_clusters</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i_embedding</span><span class="p">,</span> <span class="n">embedding</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">embeddings</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">embedding</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">embedding</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">pt_id</span> <span class="o">=</span> <span class="n">i_embedding</span>
        <span class="k">if</span> <span class="n">labels</span><span class="p">[</span><span class="n">i_embedding</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">color</span> <span class="o">=</span> <span class="n">colors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">color</span> <span class="o">=</span> <span class="n">colors</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">150</span><span class="p">)</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">pt_id</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>

<span class="k">for</span> <span class="n">i_centroid</span><span class="p">,</span> <span class="n">centroid</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">centroids</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">centroid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">centroid</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">y</span><span class="p">,</span>
        <span class="n">c</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
        <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;*&quot;</span><span class="p">,</span>
        <span class="n">s</span><span class="o">=</span><span class="mi">150</span><span class="p">,</span>
    <span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;K-means applied to Karate club embedding&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">handles</span><span class="o">=</span><span class="p">[</span><span class="n">group_1_predicted</span><span class="p">,</span> <span class="n">group_2_predicted</span><span class="p">,</span> <span class="n">group_centroids</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/notebooks_13_real_world_applications__graph_embedding_and_clustering_in_hyperbolic_space_47_0.png" src="../_images/notebooks_13_real_world_applications__graph_embedding_and_clustering_in_hyperbolic_space_47_0.png" />
</div>
</div>
<p>By comparing the <span class="math notranslate nohighlight">\(K\)</span>-means labels and the true labels, notice how <span class="math notranslate nohighlight">\(K\)</span>-means accurately finds the two groups of nodes (not perfectly, e.g., nodes 2 and 8). We therefore achieved good performances in predicting the belonging of each member of the Karate club to one of the two groups.</p>
</div>
<div class="section" id="References">
<h2>References<a class="headerlink" href="#References" title="Permalink to this headline"></a></h2>
<dl class="citation">
<dt class="label" id="aby2013"><span class="brackets">ABY2013</span></dt>
<dd><p>Arnaudon, Marc, Frédéric Barbaresco, and Le Yang. “Riemannian medians and means with applications to radar signal processing.” IEEE Journal of Selected Topics in Signal Processing 7.4 (2013): 595-604.</p>
</dd>
<dt class="label" id="gbh2018"><span class="brackets">GBH2018</span></dt>
<dd><p>Ganea, Octavian, Gary Bécigneul, and Thomas Hofmann. “Hyperbolic neural networks.” Advances in neural information processing systems. 2018.</p>
</dd>
<dt class="label" id="m2013"><span class="brackets">M2013</span></dt>
<dd><p>Mikolov, Tomas, et al. “Distributed representations of words and phrases and their compositionality.” Advances in neural information processing systems. 2013.</p>
</dd>
<dt class="label" id="nd2017"><span class="brackets">ND2017</span></dt>
<dd><p>Nickel, Maximillian, and Douwe Kiela. “Poincaré embeddings for learning hierarchical representations.” Advances in neural information processing systems. 2017.</p>
</dd>
</dl>
</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="12_real_world_applications__emg_sign_classification_in_spd_manifold.html" class="btn btn-neutral float-left" title="Tutorial: Hand gesture classification with EMG data using Riemannian metrics" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="14_real_world_applications__hand_poses_analysis_in_kendall_shape_space.html" class="btn btn-neutral float-right" title="Tutorial: Classifying hands poses with Kendall shape spaces" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022-2023, Geomstats, Inc..
      <span class="lastupdated">Last updated on Apr 11, 2022, 6:10:42 PM.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>
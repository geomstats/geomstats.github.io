
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>Backend &#8212; Geomstats latest documentation</title>
<script>
  document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
  document.documentElement.dataset.theme = localStorage.getItem("theme") || "light"
</script>

  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=92025949c220c2e29695" rel="stylesheet">
<link href="../_static/styles/pydata-sphinx-theme.css?digest=92025949c220c2e29695" rel="stylesheet">


  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery.css" />

  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=92025949c220c2e29695">

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="canonical" href="geomstats.github.io/api/backend.html" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Visualization" href="visualization.html" />
    <link rel="prev" title="Datasets" href="datasets.html" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="docsearch:language" content="en">
  </head>
  
  
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="180" data-default-mode="">
    <div class="bd-header-announcement container-fluid" id="banner">
      

    </div>

    
    <nav class="bd-header navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main"><div class="bd-header__inner container-xl">

  <div id="navbar-start">
    
    
  


<a class="navbar-brand logo" href="../index.html">
  
  
  
  
  
    <p class="title logo__title">Geomstats latest documentation</p>
  
</a>
    
  </div>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-collapsible" aria-controls="navbar-collapsible" aria-expanded="false" aria-label="Toggle navigation">
    <span class="fas fa-bars"></span>
  </button>

  
  <div id="navbar-collapsible" class="col-lg-9 collapse navbar-collapse">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        <ul id="navbar-main-elements" class="navbar-nav">
    <li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../getting_started/index.html">
  Getting Started
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../explanation/index.html">
  Explanation
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../tutorials/index.html">
  Tutorials
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../contributing/index.html">
  Contributing Guide
 </a>
</li>

<li class="toctree-l1 current active nav-item">
 <a class="reference internal nav-link" href="index.html">
  API Reference
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../roadmap.html">
  Roadmap
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../governance.html">
  Governance
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../gsod.html">
  Google Season of Docs
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../hackathons.html">
  Hackathons
 </a>
</li>

    
</ul>
      </div>
      
    </div>

    <div id="navbar-end">
      
      <div class="navbar-end-item">
        <span id="theme-switch" class="btn btn-sm btn-outline-primary navbar-btn rounded-circle">
    <a class="theme-switch" data-mode="light"><i class="fas fa-sun"></i></a>
    <a class="theme-switch" data-mode="dark"><i class="far fa-moon"></i></a>
    <a class="theme-switch" data-mode="auto"><i class="fas fa-adjust"></i></a>
</span>
      </div>
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
      </ul>
      </div>
      
    </div>
  </div>
</div>
    </nav>
    

    <div class="bd-container container-xl">
      <div class="bd-container__inner row">
          

<!-- Only show if we have sidebars configured, else just a small margin  -->
<div class="bd-sidebar-primary col-12 col-md-3 bd-sidebar">
  <div class="sidebar-start-items"><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <div class="bd-toc-item active">
    <p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Packages &amp; Modules
 </span>
</p>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="geometry.html">
   Geometry
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="learning.html">
   Learning
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="datasets.html">
   Datasets
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   Backend
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="visualization.html">
   Visualization
  </a>
 </li>
</ul>

  </div>
</nav>
  </div>
  <div class="sidebar-end-items">
  </div>
</div>


          


<div class="bd-sidebar-secondary d-none d-xl-block col-xl-2 bd-toc">
  
    
    <div class="toc-item">
      

<nav id="bd-toc-nav">
    
</nav>
    </div>
    
    <div class="toc-item">
      
    </div>
    
  
</div>


          
          
          <div class="bd-content col-12 col-md-9 col-xl-7">
              
              <article class="bd-article" role="main">
                
  <section id="module-geomstats._backend.numpy">
<span id="backend"></span><h1>Backend<a class="headerlink" href="#module-geomstats._backend.numpy" title="Permalink to this heading">#</a></h1>
<p>Numpy based computation backend.</p>
<dl class="py function">
<dt class="sig sig-object py" id="geomstats._backend.numpy.array_from_sparse">
<span class="sig-prename descclassname"><span class="pre">geomstats._backend.numpy.</span></span><span class="sig-name descname"><span class="pre">array_from_sparse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_shape</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/geomstats/_backend/numpy.html#array_from_sparse"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#geomstats._backend.numpy.array_from_sparse" title="Permalink to this definition">#</a></dt>
<dd><p>Create an array of given shape, with values at specific indices.</p>
<p>The rest of the array will be filled with zeros.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>indices</strong> (<em>iterable(tuple(int))</em>) – Index of each element which will be assigned a specific value.</p></li>
<li><p><strong>data</strong> (<em>iterable(scalar)</em>) – Value associated at each index.</p></li>
<li><p><strong>target_shape</strong> (<em>tuple(int)</em>) – Shape of the output array.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>a</strong> (<em>array, shape=target_shape</em>) – Array of zeros with specified values assigned to specified indices.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geomstats._backend.numpy.assignment">
<span class="sig-prename descclassname"><span class="pre">geomstats._backend.numpy.</span></span><span class="sig-name descname"><span class="pre">assignment</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/geomstats/_backend/numpy.html#assignment"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#geomstats._backend.numpy.assignment" title="Permalink to this definition">#</a></dt>
<dd><p>Assign values at given indices of an array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>array-like, shape=[dim]</em>) – Initial array.</p></li>
<li><p><strong>values</strong> (<em>{float, list(float)}</em>) – Value or list of values to be assigned.</p></li>
<li><p><strong>indices</strong> (<em>{int, tuple, list(int), list(tuple)}</em>) – Single int or tuple, or list of ints or tuples of indices where value
is assigned.
If the length of the tuples is shorter than ndim(x), values are
assigned to each copy along axis.</p></li>
<li><p><strong>axis</strong> (<em>int, optional</em>) – Axis along which values are assigned, if vectorized.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>x_new</strong> (<em>array-like, shape=[dim]</em>) – Copy of x with the values assigned at the given indices.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>If a single value is provided, it is assigned at all the indices.
If a list is given, it must have the same length as indices.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geomstats._backend.numpy.assignment_by_sum">
<span class="sig-prename descclassname"><span class="pre">geomstats._backend.numpy.</span></span><span class="sig-name descname"><span class="pre">assignment_by_sum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/geomstats/_backend/numpy.html#assignment_by_sum"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#geomstats._backend.numpy.assignment_by_sum" title="Permalink to this definition">#</a></dt>
<dd><p>Add values at given indices of an array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>array-like, shape=[dim]</em>) – Initial array.</p></li>
<li><p><strong>values</strong> (<em>{float, list(float)}</em>) – Value or list of values to be assigned.</p></li>
<li><p><strong>indices</strong> (<em>{int, tuple, list(int), list(tuple)}</em>) – Single int or tuple, or list of ints or tuples of indices where value
is assigned.
If the length of the tuples is shorter than ndim(x), values are
assigned to each copy along axis.</p></li>
<li><p><strong>axis</strong> (<em>int, optional</em>) – Axis along which values are assigned, if vectorized.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>x_new</strong> (<em>array-like, shape=[dim]</em>) – Copy of x with the values assigned at the given indices.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>If a single value is provided, it is assigned at all the indices.
If a list is given, it must have the same length as indices.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geomstats._backend.numpy.get_slice">
<span class="sig-prename descclassname"><span class="pre">geomstats._backend.numpy.</span></span><span class="sig-name descname"><span class="pre">get_slice</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/geomstats/_backend/numpy.html#get_slice"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#geomstats._backend.numpy.get_slice" title="Permalink to this definition">#</a></dt>
<dd><p>Return a slice of an array, following Numpy’s style.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>array-like, shape=[dim]</em>) – Initial array.</p></li>
<li><p><strong>indices</strong> (<em>iterable(iterable(int))</em>) – Indices which are kept along each axis, starting from 0.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>slice</strong> (<em>array-like</em>) – Slice of x given by indices.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This follows Numpy’s convention: indices are grouped by axis.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">30</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">get_slice</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">)))</span>
<span class="go">array([8, 29])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geomstats._backend.numpy.mat_from_diag_triu_tril">
<span class="sig-prename descclassname"><span class="pre">geomstats._backend.numpy.</span></span><span class="sig-name descname"><span class="pre">mat_from_diag_triu_tril</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">diag</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tri_upp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tri_low</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/geomstats/_backend/numpy.html#mat_from_diag_triu_tril"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#geomstats._backend.numpy.mat_from_diag_triu_tril" title="Permalink to this definition">#</a></dt>
<dd><p>Build matrix from given components.</p>
<p>Forms a matrix from diagonal, strictly upper triangular and
strictly lower traingular parts.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>diag</strong> (<em>array_like, shape=[…, n]</em>)</p></li>
<li><p><strong>tri_upp</strong> (<em>array_like, shape=[…, (n * (n - 1)) / 2]</em>)</p></li>
<li><p><strong>tri_low</strong> (<em>array_like, shape=[…, (n * (n - 1)) / 2]</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>mat</strong> (<em>array_like, shape=[…, n, n]</em>)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geomstats._backend.numpy.set_diag">
<span class="sig-prename descclassname"><span class="pre">geomstats._backend.numpy.</span></span><span class="sig-name descname"><span class="pre">set_diag</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">new_diag</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/geomstats/_backend/numpy.html#set_diag"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#geomstats._backend.numpy.set_diag" title="Permalink to this definition">#</a></dt>
<dd><p>Set the diagonal along the last two axis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>array-like, shape=[dim]</em>) – Initial array.</p></li>
<li><p><strong>new_diag</strong> (<em>array-like, shape=[dim[-2]]</em>) – Values to set on the diagonal.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><em>None</em></p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This mimics tensorflow.linalg.set_diag(x, new_diag), when new_diag is a
1-D array, but modifies x instead of creating a copy.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geomstats._backend.numpy.vec_to_diag">
<span class="sig-prename descclassname"><span class="pre">geomstats._backend.numpy.</span></span><span class="sig-name descname"><span class="pre">vec_to_diag</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vec</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/geomstats/_backend/numpy.html#vec_to_diag"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#geomstats._backend.numpy.vec_to_diag" title="Permalink to this definition">#</a></dt>
<dd><p>Convert vector to diagonal matrix.</p>
</dd></dl>

<span class="target" id="module-geomstats._backend.pytorch"></span><p>Pytorch based computation backend.</p>
<dl class="py function">
<dt class="sig sig-object py" id="geomstats._backend.pytorch.amax">
<span class="sig-prename descclassname"><span class="pre">geomstats._backend.pytorch.</span></span><span class="sig-name descname"><span class="pre">amax</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#geomstats._backend.pytorch.amax" title="Permalink to this definition">#</a></dt>
<dd><p>max(input) -&gt; Tensor</p>
<p>Returns the maximum value of all elements in the <code class="docutils literal notranslate"><span class="pre">input</span></code> tensor.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This function produces deterministic (sub)gradients unlike <code class="docutils literal notranslate"><span class="pre">max(dim=0)</span></code></p>
</div>
<dl class="simple">
<dt>Args:</dt><dd><p>input (Tensor): the input tensor.</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">tensor([[ 0.6763,  0.7445, -2.2369]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">tensor(0.7445)</span>
</pre></div>
</div>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">geomstats._backend.pytorch.</span></span><span class="sig-name descname"><span class="pre">max</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keepdim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<p>Returns a namedtuple <code class="docutils literal notranslate"><span class="pre">(values,</span> <span class="pre">indices)</span></code> where <code class="docutils literal notranslate"><span class="pre">values</span></code> is the maximum
value of each row of the <code class="xref py py-attr docutils literal notranslate"><span class="pre">input</span></code> tensor in the given dimension
<code class="xref py py-attr docutils literal notranslate"><span class="pre">dim</span></code>. And <code class="docutils literal notranslate"><span class="pre">indices</span></code> is the index location of each maximum value found
(argmax).</p>
<p>If <code class="docutils literal notranslate"><span class="pre">keepdim</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, the output tensors are of the same size
as <code class="docutils literal notranslate"><span class="pre">input</span></code> except in the dimension <code class="docutils literal notranslate"><span class="pre">dim</span></code> where they are of size 1.
Otherwise, <code class="docutils literal notranslate"><span class="pre">dim</span></code> is squeezed (see <code class="xref py py-func docutils literal notranslate"><span class="pre">torch.squeeze()</span></code>), resulting
in the output tensors having 1 fewer dimension than <code class="docutils literal notranslate"><span class="pre">input</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If there are multiple maximal values in a reduced row then
the indices of the first maximal value are returned.</p>
</div>
<dl class="simple">
<dt>Args:</dt><dd><p>input (Tensor): the input tensor.
dim (int): the dimension to reduce.
keepdim (bool): whether the output tensor has <code class="xref py py-attr docutils literal notranslate"><span class="pre">dim</span></code> retained or not. Default: <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</dd>
<dt>Keyword args:</dt><dd><p>out (tuple, optional): the result tuple of two output tensors (max, max_indices)</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">tensor([[-1.2360, -0.2942, -0.1222,  0.8475],</span>
<span class="go">        [ 1.1949, -1.1127, -2.2379, -0.6702],</span>
<span class="go">        [ 1.5717, -0.9207,  0.1297, -1.8768],</span>
<span class="go">        [-0.6172,  1.0036, -0.6060, -0.2432]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">torch.return_types.max(values=tensor([0.8475, 1.1949, 1.5717, 1.0036]), indices=tensor([3, 0, 0, 1]))</span>
</pre></div>
</div>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">geomstats._backend.pytorch.</span></span><span class="sig-name descname"><span class="pre">max</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tensor</span></span></span></dt>
<dd></dd></dl>

<p>See <code class="xref py py-func docutils literal notranslate"><span class="pre">torch.maximum()</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geomstats._backend.pytorch.angle">
<span class="sig-prename descclassname"><span class="pre">geomstats._backend.pytorch.</span></span><span class="sig-name descname"><span class="pre">angle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tensor</span></span></span><a class="headerlink" href="#geomstats._backend.pytorch.angle" title="Permalink to this definition">#</a></dt>
<dd><p>Computes the element-wise angle (in radians) of the given <code class="xref py py-attr docutils literal notranslate"><span class="pre">input</span></code> tensor.</p>
<div class="math notranslate nohighlight">
\[\text{out}_{i} = angle(\text{input}_{i})\]</div>
<dl class="simple">
<dt>Args:</dt><dd><p>input (Tensor): the input tensor.</p>
</dd>
<dt>Keyword args:</dt><dd><p>out (Tensor, optional): the output tensor.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Starting in PyTorch 1.8, angle returns pi for negative real numbers,
zero for non-negative real numbers, and propagates NaNs. Previously
the function would return zero for all real numbers and not propagate
floating-point NaNs.</p>
</div>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">torch</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="n">j</span><span class="p">,</span> <span class="mi">3</span> <span class="o">-</span> <span class="mi">3</span><span class="n">j</span><span class="p">]))</span><span class="o">*</span><span class="mi">180</span><span class="o">/</span><span class="mf">3.14159</span>
<span class="go">tensor([ 135.,  135,  -45])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geomstats._backend.pytorch.arange">
<span class="sig-prename descclassname"><span class="pre">geomstats._backend.pytorch.</span></span><span class="sig-name descname"><span class="pre">arange</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">start=0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step=1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">layout=torch.strided</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">requires_grad=False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tensor</span></span></span><a class="headerlink" href="#geomstats._backend.pytorch.arange" title="Permalink to this definition">#</a></dt>
<dd><p>Returns a 1-D tensor of size <span class="math notranslate nohighlight">\(\left\lceil \frac{\text{end} - \text{start}}{\text{step}} \right\rceil\)</span>
with values from the interval <code class="docutils literal notranslate"><span class="pre">[start,</span> <span class="pre">end)</span></code> taken with common difference
<code class="xref py py-attr docutils literal notranslate"><span class="pre">step</span></code> beginning from <cite>start</cite>.</p>
<p>Note that non-integer <code class="xref py py-attr docutils literal notranslate"><span class="pre">step</span></code> is subject to floating point rounding errors when
comparing against <code class="xref py py-attr docutils literal notranslate"><span class="pre">end</span></code>; to avoid inconsistency, we advise adding a small epsilon to <code class="xref py py-attr docutils literal notranslate"><span class="pre">end</span></code>
in such cases.</p>
<div class="math notranslate nohighlight">
\[\text{out}_{{i+1}} = \text{out}_{i} + \text{step}\]</div>
<dl>
<dt>Args:</dt><dd><p>start (Number): the starting value for the set of points. Default: <code class="docutils literal notranslate"><span class="pre">0</span></code>.
end (Number): the ending value for the set of points
step (Number): the gap between each pair of adjacent points. Default: <code class="docutils literal notranslate"><span class="pre">1</span></code>.</p>
</dd>
<dt>Keyword args:</dt><dd><p>out (Tensor, optional): the output tensor.
dtype (<code class="xref py py-class docutils literal notranslate"><span class="pre">torch.dtype</span></code>, optional): the desired data type of returned tensor.</p>
<blockquote>
<div><p>Default: if <code class="docutils literal notranslate"><span class="pre">None</span></code>, uses a global default (see <code class="xref py py-func docutils literal notranslate"><span class="pre">torch.set_default_tensor_type()</span></code>). If <cite>dtype</cite> is not given, infer the data type from the other input
arguments. If any of <cite>start</cite>, <cite>end</cite>, or <cite>stop</cite> are floating-point, the
<cite>dtype</cite> is inferred to be the default dtype, see
<code class="xref py py-meth docutils literal notranslate"><span class="pre">get_default_dtype()</span></code>. Otherwise, the <cite>dtype</cite> is inferred to
be <cite>torch.int64</cite>.</p>
</div></blockquote>
<dl class="simple">
<dt>layout (<code class="xref py py-class docutils literal notranslate"><span class="pre">torch.layout</span></code>, optional): the desired layout of returned Tensor.</dt><dd><p>Default: <code class="docutils literal notranslate"><span class="pre">torch.strided</span></code>.</p>
</dd>
<dt>device (<code class="xref py py-class docutils literal notranslate"><span class="pre">torch.device</span></code>, optional): the desired device of returned tensor.</dt><dd><p>Default: if <code class="docutils literal notranslate"><span class="pre">None</span></code>, uses the current device for the default tensor type
(see <code class="xref py py-func docutils literal notranslate"><span class="pre">torch.set_default_tensor_type()</span></code>). <code class="xref py py-attr docutils literal notranslate"><span class="pre">device</span></code> will be the CPU
for CPU tensor types and the current CUDA device for CUDA tensor types.</p>
</dd>
<dt>requires_grad (bool, optional): If autograd should record operations on the</dt><dd><p>returned tensor. Default: <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">tensor([ 0,  1,  2,  3,  4])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">tensor([ 1,  2,  3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="go">tensor([ 1.0000,  1.5000,  2.0000])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geomstats._backend.pytorch.arccos">
<span class="sig-prename descclassname"><span class="pre">geomstats._backend.pytorch.</span></span><span class="sig-name descname"><span class="pre">arccos</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tensor</span></span></span><a class="headerlink" href="#geomstats._backend.pytorch.arccos" title="Permalink to this definition">#</a></dt>
<dd><p>Alias for <code class="xref py py-func docutils literal notranslate"><span class="pre">torch.acos()</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geomstats._backend.pytorch.arccosh">
<span class="sig-prename descclassname"><span class="pre">geomstats._backend.pytorch.</span></span><span class="sig-name descname"><span class="pre">arccosh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tensor</span></span></span><a class="headerlink" href="#geomstats._backend.pytorch.arccosh" title="Permalink to this definition">#</a></dt>
<dd><p>Alias for <code class="xref py py-func docutils literal notranslate"><span class="pre">torch.acosh()</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geomstats._backend.pytorch.arcsin">
<span class="sig-prename descclassname"><span class="pre">geomstats._backend.pytorch.</span></span><span class="sig-name descname"><span class="pre">arcsin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tensor</span></span></span><a class="headerlink" href="#geomstats._backend.pytorch.arcsin" title="Permalink to this definition">#</a></dt>
<dd><p>Alias for <code class="xref py py-func docutils literal notranslate"><span class="pre">torch.asin()</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geomstats._backend.pytorch.arctan2">
<span class="sig-prename descclassname"><span class="pre">geomstats._backend.pytorch.</span></span><span class="sig-name descname"><span class="pre">arctan2</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#geomstats._backend.pytorch.arctan2" title="Permalink to this definition">#</a></dt>
<dd><p>atan2(input, other, <a href="#id1"><span class="problematic" id="id2">*</span></a>, out=None) -&gt; Tensor</p>
<p>Element-wise arctangent of <span class="math notranslate nohighlight">\(\text{input}_{i} / \text{other}_{i}\)</span>
with consideration of the quadrant. Returns a new tensor with the signed angles
in radians between vector <span class="math notranslate nohighlight">\((\text{other}_{i}, \text{input}_{i})\)</span>
and vector <span class="math notranslate nohighlight">\((1, 0)\)</span>. (Note that <span class="math notranslate nohighlight">\(\text{other}_{i}\)</span>, the second
parameter, is the x-coordinate, while <span class="math notranslate nohighlight">\(\text{input}_{i}\)</span>, the first
parameter, is the y-coordinate.)</p>
<p>The shapes of <code class="docutils literal notranslate"><span class="pre">input</span></code> and <code class="docutils literal notranslate"><span class="pre">other</span></code> must be
<span class="xref std std-ref">broadcastable</span>.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>input (Tensor): the first input tensor
other (Tensor): the second input tensor</p>
</dd>
<dt>Keyword args:</dt><dd><p>out (Tensor, optional): the output tensor.</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">tensor([ 0.9041,  0.0196, -0.3108, -2.4423])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">torch</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="go">tensor([ 0.9833,  0.0811, -1.9743, -1.4151])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geomstats._backend.pytorch.arctanh">
<span class="sig-prename descclassname"><span class="pre">geomstats._backend.pytorch.</span></span><span class="sig-name descname"><span class="pre">arctanh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tensor</span></span></span><a class="headerlink" href="#geomstats._backend.pytorch.arctanh" title="Permalink to this definition">#</a></dt>
<dd><p>Alias for <code class="xref py py-func docutils literal notranslate"><span class="pre">torch.atanh()</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geomstats._backend.pytorch.argmin">
<span class="sig-prename descclassname"><span class="pre">geomstats._backend.pytorch.</span></span><span class="sig-name descname"><span class="pre">argmin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keepdim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">LongTensor</span></span></span><a class="headerlink" href="#geomstats._backend.pytorch.argmin" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the indices of the minimum value(s) of the flattened tensor or along a dimension</p>
<p>This is the second value returned by <code class="xref py py-meth docutils literal notranslate"><span class="pre">torch.min()</span></code>. See its
documentation for the exact semantics of this method.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If there are multiple minimal values then the indices of the first minimal value are returned.</p>
</div>
<dl class="simple">
<dt>Args:</dt><dd><p>input (Tensor): the input tensor.
dim (int): the dimension to reduce. If <code class="docutils literal notranslate"><span class="pre">None</span></code>, the argmin of the flattened input is returned.
keepdim (bool): whether the output tensor has <code class="xref py py-attr docutils literal notranslate"><span class="pre">dim</span></code> retained or not. Ignored if <code class="docutils literal notranslate"><span class="pre">dim=None</span></code>.</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">tensor([[ 0.1139,  0.2254, -0.1381,  0.3687],</span>
<span class="go">        [ 1.0100, -1.1975, -0.0102, -0.4732],</span>
<span class="go">        [-0.9240,  0.1207, -0.7506, -1.0213],</span>
<span class="go">        [ 1.7809, -1.2960,  0.9384,  0.1438]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">torch</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">tensor(13)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">torch</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">tensor([ 2,  1,  3,  1])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">torch</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdim</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">tensor([[2],</span>
<span class="go">        [1],</span>
<span class="go">        [3],</span>
<span class="go">        [1]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geomstats._backend.pytorch.array_from_sparse">
<span class="sig-prename descclassname"><span class="pre">geomstats._backend.pytorch.</span></span><span class="sig-name descname"><span class="pre">array_from_sparse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_shape</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/geomstats/_backend/pytorch.html#array_from_sparse"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#geomstats._backend.pytorch.array_from_sparse" title="Permalink to this definition">#</a></dt>
<dd><p>Create an array of given shape, with values at specific indices.</p>
<p>The rest of the array will be filled with zeros.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>indices</strong> (<em>iterable(tuple(int))</em>) – Index of each element which will be assigned a specific value.</p></li>
<li><p><strong>data</strong> (<em>iterable(scalar)</em>) – Value associated at each index.</p></li>
<li><p><strong>target_shape</strong> (<em>tuple(int)</em>) – Shape of the output array.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>a</strong> (<em>array, shape=target_shape</em>) – Array of zeros with specified values assigned to specified indices.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geomstats._backend.pytorch.assignment">
<span class="sig-prename descclassname"><span class="pre">geomstats._backend.pytorch.</span></span><span class="sig-name descname"><span class="pre">assignment</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/geomstats/_backend/pytorch.html#assignment"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#geomstats._backend.pytorch.assignment" title="Permalink to this definition">#</a></dt>
<dd><p>Assign values at given indices of an array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>array-like, shape=[dim]</em>) – Initial array.</p></li>
<li><p><strong>values</strong> (<em>{float, list(float)}</em>) – Value or list of values to be assigned.</p></li>
<li><p><strong>indices</strong> (<em>{int, tuple, list(int), list(tuple)}</em>) – Single int or tuple, or list of ints or tuples of indices where value
is assigned.
If the length of the tuples is shorter than ndim(x), values are
assigned to each copy along axis.</p></li>
<li><p><strong>axis</strong> (<em>int, optional</em>) – Axis along which values are assigned, if vectorized.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>x_new</strong> (<em>array-like, shape=[dim]</em>) – Copy of x with the values assigned at the given indices.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>If a single value is provided, it is assigned at all the indices.
If a list is given, it must have the same length as indices.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geomstats._backend.pytorch.assignment_by_sum">
<span class="sig-prename descclassname"><span class="pre">geomstats._backend.pytorch.</span></span><span class="sig-name descname"><span class="pre">assignment_by_sum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/geomstats/_backend/pytorch.html#assignment_by_sum"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#geomstats._backend.pytorch.assignment_by_sum" title="Permalink to this definition">#</a></dt>
<dd><p>Add values at given indices of an array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>array-like, shape=[dim]</em>) – Initial array.</p></li>
<li><p><strong>values</strong> (<em>{float, list(float)}</em>) – Value or list of values to be assigned.</p></li>
<li><p><strong>indices</strong> (<em>{int, tuple, list(int), list(tuple)}</em>) – Single int or tuple, or list of ints or tuples of indices where value
is assigned.
If the length of the tuples is shorter than ndim(x), values are
assigned to each copy along axis.</p></li>
<li><p><strong>axis</strong> (<em>int, optional</em>) – Axis along which values are assigned, if vectorized.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>x_new</strong> (<em>array-like, shape=[dim]</em>) – Copy of x with the values assigned at the given indices.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>If a single value is provided, it is assigned at all the indices.
If a list is given, it must have the same length as indices.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geomstats._backend.pytorch.ceil">
<span class="sig-prename descclassname"><span class="pre">geomstats._backend.pytorch.</span></span><span class="sig-name descname"><span class="pre">ceil</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tensor</span></span></span><a class="headerlink" href="#geomstats._backend.pytorch.ceil" title="Permalink to this definition">#</a></dt>
<dd><p>Returns a new tensor with the ceil of the elements of <code class="xref py py-attr docutils literal notranslate"><span class="pre">input</span></code>,
the smallest integer greater than or equal to each element.</p>
<div class="math notranslate nohighlight">
\[\text{out}_{i} = \left\lceil \text{input}_{i} \right\rceil\]</div>
<dl class="simple">
<dt>Args:</dt><dd><p>input (Tensor): the input tensor.</p>
</dd>
<dt>Keyword args:</dt><dd><p>out (Tensor, optional): the output tensor.</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">tensor([-0.6341, -1.4208, -1.0900,  0.5826])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">torch</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">tensor([-0., -1., -1.,  1.])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geomstats._backend.pytorch.clip">
<span class="sig-prename descclassname"><span class="pre">geomstats._backend.pytorch.</span></span><span class="sig-name descname"><span class="pre">clip</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tensor</span></span></span><a class="headerlink" href="#geomstats._backend.pytorch.clip" title="Permalink to this definition">#</a></dt>
<dd><p>Alias for <code class="xref py py-func docutils literal notranslate"><span class="pre">torch.clamp()</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geomstats._backend.pytorch.conj">
<span class="sig-prename descclassname"><span class="pre">geomstats._backend.pytorch.</span></span><span class="sig-name descname"><span class="pre">conj</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tensor</span></span></span><a class="headerlink" href="#geomstats._backend.pytorch.conj" title="Permalink to this definition">#</a></dt>
<dd><p>Returns a view of <code class="xref py py-attr docutils literal notranslate"><span class="pre">input</span></code> with a flipped conjugate bit. If <code class="xref py py-attr docutils literal notranslate"><span class="pre">input</span></code> has a non-complex dtype,
this function just returns <code class="xref py py-attr docutils literal notranslate"><span class="pre">input</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">torch.conj()</span></code> performs a lazy conjugation, but the actual conjugated tensor can be materialized
at any time using <code class="xref py py-func docutils literal notranslate"><span class="pre">torch.resolve_conj()</span></code>.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>In the future, <code class="xref py py-func docutils literal notranslate"><span class="pre">torch.conj()</span></code> may return a non-writeable view for an <code class="xref py py-attr docutils literal notranslate"><span class="pre">input</span></code> of
non-complex dtype. It’s recommended that programs not modify the tensor returned by <code class="xref py py-func docutils literal notranslate"><span class="pre">torch.conj_physical()</span></code>
when <code class="xref py py-attr docutils literal notranslate"><span class="pre">input</span></code> is of non-complex dtype to be compatible with this change.</p>
</div>
<dl class="simple">
<dt>Args:</dt><dd><p>input (Tensor): the input tensor.</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="n">j</span><span class="p">,</span> <span class="mi">3</span> <span class="o">-</span> <span class="mi">3</span><span class="n">j</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">is_conj</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">is_conj</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geomstats._backend.pytorch.cos">
<span class="sig-prename descclassname"><span class="pre">geomstats._backend.pytorch.</span></span><span class="sig-name descname"><span class="pre">cos</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tensor</span></span></span><a class="headerlink" href="#geomstats._backend.pytorch.cos" title="Permalink to this definition">#</a></dt>
<dd><p>Returns a new tensor with the cosine  of the elements of <code class="xref py py-attr docutils literal notranslate"><span class="pre">input</span></code>.</p>
<div class="math notranslate nohighlight">
\[\text{out}_{i} = \cos(\text{input}_{i})\]</div>
<dl class="simple">
<dt>Args:</dt><dd><p>input (Tensor): the input tensor.</p>
</dd>
<dt>Keyword args:</dt><dd><p>out (Tensor, optional): the output tensor.</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">tensor([ 1.4309,  1.2706, -0.8562,  0.9796])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">torch</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">tensor([ 0.1395,  0.2957,  0.6553,  0.5574])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geomstats._backend.pytorch.cosh">
<span class="sig-prename descclassname"><span class="pre">geomstats._backend.pytorch.</span></span><span class="sig-name descname"><span class="pre">cosh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tensor</span></span></span><a class="headerlink" href="#geomstats._backend.pytorch.cosh" title="Permalink to this definition">#</a></dt>
<dd><p>Returns a new tensor with the hyperbolic cosine  of the elements of
<code class="xref py py-attr docutils literal notranslate"><span class="pre">input</span></code>.</p>
<div class="math notranslate nohighlight">
\[\text{out}_{i} = \cosh(\text{input}_{i})\]</div>
<dl class="simple">
<dt>Args:</dt><dd><p>input (Tensor): the input tensor.</p>
</dd>
<dt>Keyword args:</dt><dd><p>out (Tensor, optional): the output tensor.</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">tensor([ 0.1632,  1.1835, -0.6979, -0.7325])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">torch</span><span class="o">.</span><span class="n">cosh</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">tensor([ 1.0133,  1.7860,  1.2536,  1.2805])</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When <code class="xref py py-attr docutils literal notranslate"><span class="pre">input</span></code> is on the CPU, the implementation of torch.cosh may use
the Sleef library, which rounds very large results to infinity or negative
infinity. See <a class="reference external" href="https://sleef.org/purec.xhtml">here</a> for details.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geomstats._backend.pytorch.empty_like">
<span class="sig-prename descclassname"><span class="pre">geomstats._backend.pytorch.</span></span><span class="sig-name descname"><span class="pre">empty_like</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">layout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">requires_grad</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">memory_format</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">torch.preserve_format</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tensor</span></span></span><a class="headerlink" href="#geomstats._backend.pytorch.empty_like" title="Permalink to this definition">#</a></dt>
<dd><p>Returns an uninitialized tensor with the same size as <code class="xref py py-attr docutils literal notranslate"><span class="pre">input</span></code>.
<code class="docutils literal notranslate"><span class="pre">torch.empty_like(input)</span></code> is equivalent to
<code class="docutils literal notranslate"><span class="pre">torch.empty(input.size(),</span> <span class="pre">dtype=input.dtype,</span> <span class="pre">layout=input.layout,</span> <span class="pre">device=input.device)</span></code>.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>input (Tensor): the size of <code class="xref py py-attr docutils literal notranslate"><span class="pre">input</span></code> will determine size of the output tensor.</p>
</dd>
<dt>Keyword args:</dt><dd><dl class="simple">
<dt>dtype (<code class="xref py py-class docutils literal notranslate"><span class="pre">torch.dtype</span></code>, optional): the desired data type of returned Tensor.</dt><dd><p>Default: if <code class="docutils literal notranslate"><span class="pre">None</span></code>, defaults to the dtype of <code class="xref py py-attr docutils literal notranslate"><span class="pre">input</span></code>.</p>
</dd>
<dt>layout (<code class="xref py py-class docutils literal notranslate"><span class="pre">torch.layout</span></code>, optional): the desired layout of returned tensor.</dt><dd><p>Default: if <code class="docutils literal notranslate"><span class="pre">None</span></code>, defaults to the layout of <code class="xref py py-attr docutils literal notranslate"><span class="pre">input</span></code>.</p>
</dd>
<dt>device (<code class="xref py py-class docutils literal notranslate"><span class="pre">torch.device</span></code>, optional): the desired device of returned tensor.</dt><dd><p>Default: if <code class="docutils literal notranslate"><span class="pre">None</span></code>, defaults to the device of <code class="xref py py-attr docutils literal notranslate"><span class="pre">input</span></code>.</p>
</dd>
<dt>requires_grad (bool, optional): If autograd should record operations on the</dt><dd><p>returned tensor. Default: <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</dd>
<dt>memory_format (<code class="xref py py-class docutils literal notranslate"><span class="pre">torch.memory_format</span></code>, optional): the desired memory format of</dt><dd><p>returned Tensor. Default: <code class="docutils literal notranslate"><span class="pre">torch.preserve_format</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">device</span> <span class="o">=</span> <span class="s1">&#39;cuda&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">torch</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">tensor([[0, 0, 0],</span>
<span class="go">        [0, 0, 0]], device=&#39;cuda:0&#39;, dtype=torch.int32)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geomstats._backend.pytorch.erf">
<span class="sig-prename descclassname"><span class="pre">geomstats._backend.pytorch.</span></span><span class="sig-name descname"><span class="pre">erf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tensor</span></span></span><a class="headerlink" href="#geomstats._backend.pytorch.erf" title="Permalink to this definition">#</a></dt>
<dd><p>Alias for <code class="xref py py-func docutils literal notranslate"><span class="pre">torch.special.erf()</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geomstats._backend.pytorch.exp">
<span class="sig-prename descclassname"><span class="pre">geomstats._backend.pytorch.</span></span><span class="sig-name descname"><span class="pre">exp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tensor</span></span></span><a class="headerlink" href="#geomstats._backend.pytorch.exp" title="Permalink to this definition">#</a></dt>
<dd><p>Returns a new tensor with the exponential of the elements
of the input tensor <code class="xref py py-attr docutils literal notranslate"><span class="pre">input</span></code>.</p>
<div class="math notranslate nohighlight">
\[y_{i} = e^{x_{i}}\]</div>
<dl class="simple">
<dt>Args:</dt><dd><p>input (Tensor): the input tensor.</p>
</dd>
<dt>Keyword args:</dt><dd><p>out (Tensor, optional): the output tensor.</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">torch</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">2.</span><span class="p">)]))</span>
<span class="go">tensor([ 1.,  2.])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geomstats._backend.pytorch.eye">
<span class="sig-prename descclassname"><span class="pre">geomstats._backend.pytorch.</span></span><span class="sig-name descname"><span class="pre">eye</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">layout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">torch.strided</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">requires_grad</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tensor</span></span></span><a class="headerlink" href="#geomstats._backend.pytorch.eye" title="Permalink to this definition">#</a></dt>
<dd><p>Returns a 2-D tensor with ones on the diagonal and zeros elsewhere.</p>
<dl>
<dt>Args:</dt><dd><p>n (int): the number of rows
m (int, optional): the number of columns with default being <code class="xref py py-attr docutils literal notranslate"><span class="pre">n</span></code></p>
</dd>
<dt>Keyword arguments:</dt><dd><p>out (Tensor, optional): the output tensor.
dtype (<code class="xref py py-class docutils literal notranslate"><span class="pre">torch.dtype</span></code>, optional): the desired data type of returned tensor.</p>
<blockquote>
<div><p>Default: if <code class="docutils literal notranslate"><span class="pre">None</span></code>, uses a global default (see <code class="xref py py-func docutils literal notranslate"><span class="pre">torch.set_default_tensor_type()</span></code>).</p>
</div></blockquote>
<dl class="simple">
<dt>layout (<code class="xref py py-class docutils literal notranslate"><span class="pre">torch.layout</span></code>, optional): the desired layout of returned Tensor.</dt><dd><p>Default: <code class="docutils literal notranslate"><span class="pre">torch.strided</span></code>.</p>
</dd>
<dt>device (<code class="xref py py-class docutils literal notranslate"><span class="pre">torch.device</span></code>, optional): the desired device of returned tensor.</dt><dd><p>Default: if <code class="docutils literal notranslate"><span class="pre">None</span></code>, uses the current device for the default tensor type
(see <code class="xref py py-func docutils literal notranslate"><span class="pre">torch.set_default_tensor_type()</span></code>). <code class="xref py py-attr docutils literal notranslate"><span class="pre">device</span></code> will be the CPU
for CPU tensor types and the current CUDA device for CUDA tensor types.</p>
</dd>
<dt>requires_grad (bool, optional): If autograd should record operations on the</dt><dd><p>returned tensor. Default: <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>Tensor: A 2-D tensor with ones on the diagonal and zeros elsewhere</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">torch</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">tensor([[ 1.,  0.,  0.],</span>
<span class="go">        [ 0.,  1.,  0.],</span>
<span class="go">        [ 0.,  0.,  1.]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geomstats._backend.pytorch.flatten">
<span class="sig-prename descclassname"><span class="pre">geomstats._backend.pytorch.</span></span><span class="sig-name descname"><span class="pre">flatten</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end_dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tensor</span></span></span><a class="headerlink" href="#geomstats._backend.pytorch.flatten" title="Permalink to this definition">#</a></dt>
<dd><p>Flattens <code class="xref py py-attr docutils literal notranslate"><span class="pre">input</span></code> by reshaping it into a one-dimensional tensor. If <code class="xref py py-attr docutils literal notranslate"><span class="pre">start_dim</span></code> or <code class="xref py py-attr docutils literal notranslate"><span class="pre">end_dim</span></code>
are passed, only dimensions starting with <code class="xref py py-attr docutils literal notranslate"><span class="pre">start_dim</span></code> and ending with <code class="xref py py-attr docutils literal notranslate"><span class="pre">end_dim</span></code> are flattened.
The order of elements in <code class="xref py py-attr docutils literal notranslate"><span class="pre">input</span></code> is unchanged.</p>
<p>Unlike NumPy’s flatten, which always copies input’s data, this function may return the original object, a view,
or copy. If no dimensions are flattened, then the original object <code class="xref py py-attr docutils literal notranslate"><span class="pre">input</span></code> is returned. Otherwise, if input can
be viewed as the flattened shape, then that view is returned. Finally, only if the input cannot be viewed as the
flattened shape is input’s data copied. See <code class="xref py py-meth docutils literal notranslate"><span class="pre">torch.Tensor.view()</span></code> for details on when a view will be returned.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Flattening a zero-dimensional tensor will return a one-dimensional view.</p>
</div>
<dl class="simple">
<dt>Args:</dt><dd><p>input (Tensor): the input tensor.
start_dim (int): the first dim to flatten
end_dim (int): the last dim to flatten</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]],</span>
<span class="gp">... </span>                  <span class="p">[[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">torch</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="go">tensor([1, 2, 3, 4, 5, 6, 7, 8])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">torch</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">start_dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">tensor([[1, 2, 3, 4],</span>
<span class="go">        [5, 6, 7, 8]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geomstats._backend.pytorch.floor">
<span class="sig-prename descclassname"><span class="pre">geomstats._backend.pytorch.</span></span><span class="sig-name descname"><span class="pre">floor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tensor</span></span></span><a class="headerlink" href="#geomstats._backend.pytorch.floor" title="Permalink to this definition">#</a></dt>
<dd><p>Returns a new tensor with the floor of the elements of <code class="xref py py-attr docutils literal notranslate"><span class="pre">input</span></code>,
the largest integer less than or equal to each element.</p>
<div class="math notranslate nohighlight">
\[\text{out}_{i} = \left\lfloor \text{input}_{i} \right\rfloor\]</div>
<dl class="simple">
<dt>Args:</dt><dd><p>input (Tensor): the input tensor.</p>
</dd>
<dt>Keyword args:</dt><dd><p>out (Tensor, optional): the output tensor.</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">tensor([-0.8166,  1.5308, -0.2530, -0.2091])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">torch</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">tensor([-1.,  1., -1., -1.])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geomstats._backend.pytorch.get_slice">
<span class="sig-prename descclassname"><span class="pre">geomstats._backend.pytorch.</span></span><span class="sig-name descname"><span class="pre">get_slice</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/geomstats/_backend/pytorch.html#get_slice"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#geomstats._backend.pytorch.get_slice" title="Permalink to this definition">#</a></dt>
<dd><p>Return a slice of an array, following Numpy’s style.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>array-like, shape=[dim]</em>) – Initial array.</p></li>
<li><p><strong>indices</strong> (<em>iterable(iterable(int))</em>) – Indices which are kept along each axis, starting from 0.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>slice</strong> (<em>array-like</em>) – Slice of x given by indices.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This follows Numpy’s convention: indices are grouped by axis.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">30</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">get_slice</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">)))</span>
<span class="go">tensor([8, 29])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geomstats._backend.pytorch.greater">
<span class="sig-prename descclassname"><span class="pre">geomstats._backend.pytorch.</span></span><span class="sig-name descname"><span class="pre">greater</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tensor</span></span></span><a class="headerlink" href="#geomstats._backend.pytorch.greater" title="Permalink to this definition">#</a></dt>
<dd><p>Alias for <code class="xref py py-func docutils literal notranslate"><span class="pre">torch.gt()</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geomstats._backend.pytorch.hstack">
<span class="sig-prename descclassname"><span class="pre">geomstats._backend.pytorch.</span></span><span class="sig-name descname"><span class="pre">hstack</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tensors</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tensor</span></span></span><a class="headerlink" href="#geomstats._backend.pytorch.hstack" title="Permalink to this definition">#</a></dt>
<dd><p>Stack tensors in sequence horizontally (column wise).</p>
<p>This is equivalent to concatenation along the first axis for 1-D tensors, and along the second axis for all other tensors.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>tensors (sequence of Tensors): sequence of tensors to concatenate</p>
</dd>
<dt>Keyword args:</dt><dd><p>out (Tensor, optional): the output tensor.</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">torch</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">))</span>
<span class="go">tensor([1, 2, 3, 4, 5, 6])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[</span><span class="mi">1</span><span class="p">],[</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[</span><span class="mi">4</span><span class="p">],[</span><span class="mi">5</span><span class="p">],[</span><span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">torch</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">))</span>
<span class="go">tensor([[1, 4],</span>
<span class="go">        [2, 5],</span>
<span class="go">        [3, 6]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geomstats._backend.pytorch.imag">
<span class="sig-prename descclassname"><span class="pre">geomstats._backend.pytorch.</span></span><span class="sig-name descname"><span class="pre">imag</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tensor</span></span></span><a class="headerlink" href="#geomstats._backend.pytorch.imag" title="Permalink to this definition">#</a></dt>
<dd><p>Returns a new tensor containing imaginary values of the <code class="xref py py-attr docutils literal notranslate"><span class="pre">self</span></code> tensor.
The returned tensor and <code class="xref py py-attr docutils literal notranslate"><span class="pre">self</span></code> share the same underlying storage.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p><a class="reference internal" href="#geomstats._backend.pytorch.imag" title="geomstats._backend.pytorch.imag"><code class="xref py py-func docutils literal notranslate"><span class="pre">imag()</span></code></a> is only supported for tensors with complex dtypes.</p>
</div>
<dl class="simple">
<dt>Args:</dt><dd><p>input (Tensor): the input tensor.</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">cfloat</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">tensor([(0.3100+0.3553j), (-0.5445-0.7896j), (-1.6492-0.0633j), (-0.0638-0.8119j)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">imag</span>
<span class="go">tensor([ 0.3553, -0.7896, -0.0633, -0.8119])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geomstats._backend.pytorch.isnan">
<span class="sig-prename descclassname"><span class="pre">geomstats._backend.pytorch.</span></span><span class="sig-name descname"><span class="pre">isnan</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tensor</span></span></span><a class="headerlink" href="#geomstats._backend.pytorch.isnan" title="Permalink to this definition">#</a></dt>
<dd><p>Returns a new tensor with boolean elements representing if each element of <code class="xref py py-attr docutils literal notranslate"><span class="pre">input</span></code>
is NaN or not. Complex values are considered NaN when either their real
and/or imaginary part is NaN.</p>
<dl class="simple">
<dt>Arguments:</dt><dd><p>input (Tensor): the input tensor.</p>
</dd>
<dt>Returns:</dt><dd><p>A boolean tensor that is True where <code class="xref py py-attr docutils literal notranslate"><span class="pre">input</span></code> is NaN and False elsewhere</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">torch</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;nan&#39;</span><span class="p">),</span> <span class="mi">2</span><span class="p">]))</span>
<span class="go">tensor([False, True, False])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geomstats._backend.pytorch.kron">
<span class="sig-prename descclassname"><span class="pre">geomstats._backend.pytorch.</span></span><span class="sig-name descname"><span class="pre">kron</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tensor</span></span></span><a class="headerlink" href="#geomstats._backend.pytorch.kron" title="Permalink to this definition">#</a></dt>
<dd><p>Computes the Kronecker product, denoted by <span class="math notranslate nohighlight">\(\otimes\)</span>, of <code class="xref py py-attr docutils literal notranslate"><span class="pre">input</span></code> and <code class="xref py py-attr docutils literal notranslate"><span class="pre">other</span></code>.</p>
<p>If <code class="xref py py-attr docutils literal notranslate"><span class="pre">input</span></code> is a <span class="math notranslate nohighlight">\((a_0 \times a_1 \times \dots \times a_n)\)</span> tensor and <code class="xref py py-attr docutils literal notranslate"><span class="pre">other</span></code> is a
<span class="math notranslate nohighlight">\((b_0 \times b_1 \times \dots \times b_n)\)</span> tensor, the result will be a
<span class="math notranslate nohighlight">\((a_0*b_0 \times a_1*b_1 \times \dots \times a_n*b_n)\)</span> tensor with the following entries:</p>
<div class="math notranslate nohighlight">
\[(\text{input} \otimes \text{other})_{k_0, k_1, \dots, k_n} =
    \text{input}_{i_0, i_1, \dots, i_n} * \text{other}_{j_0, j_1, \dots, j_n},\]</div>
<p>where <span class="math notranslate nohighlight">\(k_t = i_t * b_t + j_t\)</span> for <span class="math notranslate nohighlight">\(0 \leq t \leq n\)</span>.
If one tensor has fewer dimensions than the other it is unsqueezed until it has the same number of dimensions.</p>
<p>Supports real-valued and complex-valued inputs.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function generalizes the typical definition of the Kronecker product for two matrices to two tensors,
as described above. When <code class="xref py py-attr docutils literal notranslate"><span class="pre">input</span></code> is a <span class="math notranslate nohighlight">\((m \times n)\)</span> matrix and <code class="xref py py-attr docutils literal notranslate"><span class="pre">other</span></code> is a
<span class="math notranslate nohighlight">\((p \times q)\)</span> matrix, the result will be a <span class="math notranslate nohighlight">\((p*m \times q*n)\)</span> block matrix:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathbf{A} \otimes \mathbf{B}=\begin{bmatrix}
a_{11} \mathbf{B} &amp; \cdots &amp; a_{1 n} \mathbf{B} \\
\vdots &amp; \ddots &amp; \vdots \\
a_{m 1} \mathbf{B} &amp; \cdots &amp; a_{m n} \mathbf{B} \end{bmatrix}\end{split}\]</div>
<p>where <code class="xref py py-attr docutils literal notranslate"><span class="pre">input</span></code> is <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> and <code class="xref py py-attr docutils literal notranslate"><span class="pre">other</span></code> is <span class="math notranslate nohighlight">\(\mathbf{B}\)</span>.</p>
</div>
<dl class="simple">
<dt>Arguments:</dt><dd><p>input (Tensor)
other (Tensor)</p>
</dd>
<dt>Keyword args:</dt><dd><p>out (Tensor, optional): The output tensor. Ignored if <code class="docutils literal notranslate"><span class="pre">None</span></code>. Default: <code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mat1</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mat2</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">torch</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">mat1</span><span class="p">,</span> <span class="n">mat2</span><span class="p">)</span>
<span class="go">tensor([[1., 1., 0., 0.],</span>
<span class="go">        [1., 1., 0., 0.],</span>
<span class="go">        [0., 0., 1., 1.],</span>
<span class="go">        [0., 0., 1., 1.]])</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">mat1</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mat2</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">torch</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">mat1</span><span class="p">,</span> <span class="n">mat2</span><span class="p">)</span>
<span class="go">tensor([[1., 2., 0., 0.],</span>
<span class="go">        [3., 4., 0., 0.],</span>
<span class="go">        [0., 0., 1., 2.],</span>
<span class="go">        [0., 0., 3., 4.]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geomstats._backend.pytorch.less">
<span class="sig-prename descclassname"><span class="pre">geomstats._backend.pytorch.</span></span><span class="sig-name descname"><span class="pre">less</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tensor</span></span></span><a class="headerlink" href="#geomstats._backend.pytorch.less" title="Permalink to this definition">#</a></dt>
<dd><p>Alias for <code class="xref py py-func docutils literal notranslate"><span class="pre">torch.lt()</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geomstats._backend.pytorch.log">
<span class="sig-prename descclassname"><span class="pre">geomstats._backend.pytorch.</span></span><span class="sig-name descname"><span class="pre">log</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tensor</span></span></span><a class="headerlink" href="#geomstats._backend.pytorch.log" title="Permalink to this definition">#</a></dt>
<dd><p>Returns a new tensor with the natural logarithm of the elements
of <code class="xref py py-attr docutils literal notranslate"><span class="pre">input</span></code>.</p>
<div class="math notranslate nohighlight">
\[y_{i} = \log_{e} (x_{i})\]</div>
<dl class="simple">
<dt>Args:</dt><dd><p>input (Tensor): the input tensor.</p>
</dd>
<dt>Keyword args:</dt><dd><p>out (Tensor, optional): the output tensor.</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">tensor([-0.7168, -0.5471, -0.8933, -1.4428, -0.1190])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">torch</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">tensor([ nan,  nan,  nan,  nan,  nan])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geomstats._backend.pytorch.logical_or">
<span class="sig-prename descclassname"><span class="pre">geomstats._backend.pytorch.</span></span><span class="sig-name descname"><span class="pre">logical_or</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tensor</span></span></span><a class="headerlink" href="#geomstats._backend.pytorch.logical_or" title="Permalink to this definition">#</a></dt>
<dd><p>Computes the element-wise logical OR of the given input tensors. Zeros are treated as <code class="docutils literal notranslate"><span class="pre">False</span></code> and nonzeros are
treated as <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>input (Tensor): the input tensor.
other (Tensor): the tensor to compute OR with</p>
</dd>
<dt>Keyword args:</dt><dd><p>out (Tensor, optional): the output tensor.</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">torch</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">]),</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">]))</span>
<span class="go">tensor([ True, False,  True])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">torch</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">tensor([ True,  True,  True, False])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">torch</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">double</span><span class="p">(),</span> <span class="n">b</span><span class="o">.</span><span class="n">double</span><span class="p">())</span>
<span class="go">tensor([ True,  True,  True, False])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">torch</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">double</span><span class="p">(),</span> <span class="n">b</span><span class="p">)</span>
<span class="go">tensor([ True,  True,  True, False])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">torch</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">bool</span><span class="p">))</span>
<span class="go">tensor([ True,  True,  True, False])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geomstats._backend.pytorch.mat_from_diag_triu_tril">
<span class="sig-prename descclassname"><span class="pre">geomstats._backend.pytorch.</span></span><span class="sig-name descname"><span class="pre">mat_from_diag_triu_tril</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">diag</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tri_upp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tri_low</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/geomstats/_backend/pytorch.html#mat_from_diag_triu_tril"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#geomstats._backend.pytorch.mat_from_diag_triu_tril" title="Permalink to this definition">#</a></dt>
<dd><p>Build matrix from given components.</p>
<p>Forms a matrix from diagonal, strictly upper triangular and
strictly lower traingular parts.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>diag</strong> (<em>array_like, shape=[…, n]</em>)</p></li>
<li><p><strong>tri_upp</strong> (<em>array_like, shape=[…, (n * (n - 1)) / 2]</em>)</p></li>
<li><p><strong>tri_low</strong> (<em>array_like, shape=[…, (n * (n - 1)) / 2]</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>mat</strong> (<em>array_like, shape=[…, n, n]</em>)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geomstats._backend.pytorch.mean">
<span class="sig-prename descclassname"><span class="pre">geomstats._backend.pytorch.</span></span><span class="sig-name descname"><span class="pre">mean</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tensor</span></span></span><a class="headerlink" href="#geomstats._backend.pytorch.mean" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the mean value of all elements in the <code class="xref py py-attr docutils literal notranslate"><span class="pre">input</span></code> tensor.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>input (Tensor): the input tensor.</p>
</dd>
<dt>Keyword args:</dt><dd><dl class="simple">
<dt>dtype (<code class="xref py py-class docutils literal notranslate"><span class="pre">torch.dtype</span></code>, optional): the desired data type of returned tensor.</dt><dd><p>If specified, the input tensor is casted to <code class="xref py py-attr docutils literal notranslate"><span class="pre">dtype</span></code> before the operation
is performed. This is useful for preventing data type overflows. Default: None.</p>
</dd>
</dl>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">tensor([[ 0.2294, -0.5481,  1.3288]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">torch</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">tensor(0.3367)</span>
</pre></div>
</div>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">geomstats._backend.pytorch.</span></span><span class="sig-name descname"><span class="pre">mean</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keepdim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tensor</span></span></span></dt>
<dd></dd></dl>

<p>Returns the mean value of each row of the <code class="xref py py-attr docutils literal notranslate"><span class="pre">input</span></code> tensor in the given
dimension <code class="xref py py-attr docutils literal notranslate"><span class="pre">dim</span></code>. If <code class="xref py py-attr docutils literal notranslate"><span class="pre">dim</span></code> is a list of dimensions,
reduce over all of them.</p>
<p>If <code class="xref py py-attr docutils literal notranslate"><span class="pre">keepdim</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, the output tensor is of the same size
as <code class="xref py py-attr docutils literal notranslate"><span class="pre">input</span></code> except in the dimension(s) <code class="xref py py-attr docutils literal notranslate"><span class="pre">dim</span></code> where it is of size 1.
Otherwise, <code class="xref py py-attr docutils literal notranslate"><span class="pre">dim</span></code> is squeezed (see <code class="xref py py-func docutils literal notranslate"><span class="pre">torch.squeeze()</span></code>), resulting in the
output tensor having 1 (or <code class="docutils literal notranslate"><span class="pre">len(dim)</span></code>) fewer dimension(s).</p>
<dl>
<dt>Args:</dt><dd><p>input (Tensor): the input tensor.
dim (int or tuple of ints): the dimension or dimensions to reduce.
keepdim (bool): whether the output tensor has <code class="xref py py-attr docutils literal notranslate"><span class="pre">dim</span></code> retained or not.</p>
</dd>
<dt>Keyword args:</dt><dd><dl class="simple">
<dt>dtype (<code class="xref py py-class docutils literal notranslate"><span class="pre">torch.dtype</span></code>, optional): the desired data type of returned tensor.</dt><dd><p>If specified, the input tensor is casted to <code class="xref py py-attr docutils literal notranslate"><span class="pre">dtype</span></code> before the operation
is performed. This is useful for preventing data type overflows. Default: None.</p>
</dd>
</dl>
<p>out (Tensor, optional): the output tensor.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">torch.nanmean()</span></code> computes the mean value of <cite>non-NaN</cite> elements.</p>
</div>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">tensor([[-0.3841,  0.6320,  0.4254, -0.7384],</span>
<span class="go">        [-0.9644,  1.0131, -0.6549, -1.4279],</span>
<span class="go">        [-0.2951, -1.3350, -0.7694,  0.5600],</span>
<span class="go">        [ 1.0842, -0.9580,  0.3623,  0.2343]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">torch</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">tensor([-0.0163, -0.5085, -0.4599,  0.1807])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">torch</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="go">tensor([[-0.0163],</span>
<span class="go">        [-0.5085],</span>
<span class="go">        [-0.4599],</span>
<span class="go">        [ 0.1807]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geomstats._backend.pytorch.mod">
<span class="sig-prename descclassname"><span class="pre">geomstats._backend.pytorch.</span></span><span class="sig-name descname"><span class="pre">mod</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#geomstats._backend.pytorch.mod" title="Permalink to this definition">#</a></dt>
<dd><p>fmod(input, other, <a href="#id3"><span class="problematic" id="id4">*</span></a>, out=None) -&gt; Tensor</p>
<p>Applies C++’s <a class="reference external" href="https://en.cppreference.com/w/cpp/numeric/math/fmod">std::fmod</a> entrywise.
The result has the same sign as the dividend <code class="xref py py-attr docutils literal notranslate"><span class="pre">input</span></code> and its absolute value
is less than that of <code class="xref py py-attr docutils literal notranslate"><span class="pre">other</span></code>.</p>
<p>This function may be defined in terms of <code class="xref py py-func docutils literal notranslate"><span class="pre">torch.div()</span></code> as</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">torch</span><span class="o">.</span><span class="n">fmod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">==</span> <span class="n">a</span> <span class="o">-</span> <span class="n">a</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">rounding_mode</span><span class="o">=</span><span class="s2">&quot;trunc&quot;</span><span class="p">)</span> <span class="o">*</span> <span class="n">b</span>
</pre></div>
</div>
<p>Supports <span class="xref std std-ref">broadcasting to a common shape</span>,
<span class="xref std std-ref">type promotion</span>, and integer and float inputs.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When the divisor is zero, returns <code class="docutils literal notranslate"><span class="pre">NaN</span></code> for floating point dtypes
on both CPU and GPU; raises <code class="docutils literal notranslate"><span class="pre">RuntimeError</span></code> for integer division by
zero on CPU; Integer division by zero on GPU may return any value.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Complex inputs are not supported. In some cases, it is not mathematically
possible to satisfy the definition of a modulo operation with complex numbers.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">torch.remainder()</span></code> which implements Python’s modulus operator.
This one is defined using division rounding down the result.</p>
</div>
<dl class="simple">
<dt>Args:</dt><dd><p>input (Tensor): the dividend
other (Tensor or Scalar): the divisor</p>
</dd>
<dt>Keyword args:</dt><dd><p>out (Tensor, optional): the output tensor.</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">torch</span><span class="o">.</span><span class="n">fmod</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="o">-</span><span class="mf">3.</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]),</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">tensor([-1., -0., -1.,  1.,  0.,  1.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">torch</span><span class="o">.</span><span class="n">fmod</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]),</span> <span class="o">-</span><span class="mf">1.5</span><span class="p">)</span>
<span class="go">tensor([1.0000, 0.5000, 0.0000, 1.0000, 0.5000])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geomstats._backend.pytorch.moveaxis">
<span class="sig-prename descclassname"><span class="pre">geomstats._backend.pytorch.</span></span><span class="sig-name descname"><span class="pre">moveaxis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">destination</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tensor</span></span></span><a class="headerlink" href="#geomstats._backend.pytorch.moveaxis" title="Permalink to this definition">#</a></dt>
<dd><p>Alias for <code class="xref py py-func docutils literal notranslate"><span class="pre">torch.movedim()</span></code>.</p>
<p>This function is equivalent to NumPy’s moveaxis function.</p>
<p>Examples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span>
<span class="go">tensor([[[-0.3362],</span>
<span class="go">        [-0.8437]],</span>

<span class="go">        [[-0.9627],</span>
<span class="go">        [ 0.1727]],</span>

<span class="go">        [[ 0.5173],</span>
<span class="go">        [-0.1398]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">torch</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([2, 3, 1])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">torch</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">tensor([[[-0.3362],</span>
<span class="go">        [-0.9627],</span>
<span class="go">        [ 0.5173]],</span>

<span class="go">        [[-0.8437],</span>
<span class="go">        [ 0.1727],</span>
<span class="go">        [-0.1398]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">torch</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([2, 1, 3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">torch</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="go">tensor([[[-0.3362, -0.9627,  0.5173]],</span>

<span class="go">        [[-0.8437,  0.1727, -0.1398]]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geomstats._backend.pytorch.ones">
<span class="sig-prename descclassname"><span class="pre">geomstats._backend.pytorch.</span></span><span class="sig-name descname"><span class="pre">ones</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">*size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">layout=torch.strided</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">requires_grad=False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tensor</span></span></span><a class="headerlink" href="#geomstats._backend.pytorch.ones" title="Permalink to this definition">#</a></dt>
<dd><p>Returns a tensor filled with the scalar value <cite>1</cite>, with the shape defined
by the variable argument <code class="xref py py-attr docutils literal notranslate"><span class="pre">size</span></code>.</p>
<dl>
<dt>Args:</dt><dd><dl class="simple">
<dt>size (int…): a sequence of integers defining the shape of the output tensor.</dt><dd><p>Can be a variable number of arguments or a collection like a list or tuple.</p>
</dd>
</dl>
</dd>
<dt>Keyword arguments:</dt><dd><p>out (Tensor, optional): the output tensor.
dtype (<code class="xref py py-class docutils literal notranslate"><span class="pre">torch.dtype</span></code>, optional): the desired data type of returned tensor.</p>
<blockquote>
<div><p>Default: if <code class="docutils literal notranslate"><span class="pre">None</span></code>, uses a global default (see <code class="xref py py-func docutils literal notranslate"><span class="pre">torch.set_default_tensor_type()</span></code>).</p>
</div></blockquote>
<dl class="simple">
<dt>layout (<code class="xref py py-class docutils literal notranslate"><span class="pre">torch.layout</span></code>, optional): the desired layout of returned Tensor.</dt><dd><p>Default: <code class="docutils literal notranslate"><span class="pre">torch.strided</span></code>.</p>
</dd>
<dt>device (<code class="xref py py-class docutils literal notranslate"><span class="pre">torch.device</span></code>, optional): the desired device of returned tensor.</dt><dd><p>Default: if <code class="docutils literal notranslate"><span class="pre">None</span></code>, uses the current device for the default tensor type
(see <code class="xref py py-func docutils literal notranslate"><span class="pre">torch.set_default_tensor_type()</span></code>). <code class="xref py py-attr docutils literal notranslate"><span class="pre">device</span></code> will be the CPU
for CPU tensor types and the current CUDA device for CUDA tensor types.</p>
</dd>
<dt>requires_grad (bool, optional): If autograd should record operations on the</dt><dd><p>returned tensor. Default: <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">tensor([[ 1.,  1.,  1.],</span>
<span class="go">        [ 1.,  1.,  1.]])</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">tensor([ 1.,  1.,  1.,  1.,  1.])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geomstats._backend.pytorch.ones_like">
<span class="sig-prename descclassname"><span class="pre">geomstats._backend.pytorch.</span></span><span class="sig-name descname"><span class="pre">ones_like</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">layout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">requires_grad</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">memory_format</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">torch.preserve_format</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tensor</span></span></span><a class="headerlink" href="#geomstats._backend.pytorch.ones_like" title="Permalink to this definition">#</a></dt>
<dd><p>Returns a tensor filled with the scalar value <cite>1</cite>, with the same size as
<code class="xref py py-attr docutils literal notranslate"><span class="pre">input</span></code>. <code class="docutils literal notranslate"><span class="pre">torch.ones_like(input)</span></code> is equivalent to
<code class="docutils literal notranslate"><span class="pre">torch.ones(input.size(),</span> <span class="pre">dtype=input.dtype,</span> <span class="pre">layout=input.layout,</span> <span class="pre">device=input.device)</span></code>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>As of 0.4, this function does not support an <code class="xref py py-attr docutils literal notranslate"><span class="pre">out</span></code> keyword. As an alternative,
the old <code class="docutils literal notranslate"><span class="pre">torch.ones_like(input,</span> <span class="pre">out=output)</span></code> is equivalent to
<code class="docutils literal notranslate"><span class="pre">torch.ones(input.size(),</span> <span class="pre">out=output)</span></code>.</p>
</div>
<dl class="simple">
<dt>Args:</dt><dd><p>input (Tensor): the size of <code class="xref py py-attr docutils literal notranslate"><span class="pre">input</span></code> will determine size of the output tensor.</p>
</dd>
<dt>Keyword arguments:</dt><dd><dl class="simple">
<dt>dtype (<code class="xref py py-class docutils literal notranslate"><span class="pre">torch.dtype</span></code>, optional): the desired data type of returned Tensor.</dt><dd><p>Default: if <code class="docutils literal notranslate"><span class="pre">None</span></code>, defaults to the dtype of <code class="xref py py-attr docutils literal notranslate"><span class="pre">input</span></code>.</p>
</dd>
<dt>layout (<code class="xref py py-class docutils literal notranslate"><span class="pre">torch.layout</span></code>, optional): the desired layout of returned tensor.</dt><dd><p>Default: if <code class="docutils literal notranslate"><span class="pre">None</span></code>, defaults to the layout of <code class="xref py py-attr docutils literal notranslate"><span class="pre">input</span></code>.</p>
</dd>
<dt>device (<code class="xref py py-class docutils literal notranslate"><span class="pre">torch.device</span></code>, optional): the desired device of returned tensor.</dt><dd><p>Default: if <code class="docutils literal notranslate"><span class="pre">None</span></code>, defaults to the device of <code class="xref py py-attr docutils literal notranslate"><span class="pre">input</span></code>.</p>
</dd>
<dt>requires_grad (bool, optional): If autograd should record operations on the</dt><dd><p>returned tensor. Default: <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</dd>
<dt>memory_format (<code class="xref py py-class docutils literal notranslate"><span class="pre">torch.memory_format</span></code>, optional): the desired memory format of</dt><dd><p>returned Tensor. Default: <code class="docutils literal notranslate"><span class="pre">torch.preserve_format</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">input</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">torch</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span>
<span class="go">tensor([[ 1.,  1.,  1.],</span>
<span class="go">        [ 1.,  1.,  1.]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geomstats._backend.pytorch.polygamma">
<span class="sig-prename descclassname"><span class="pre">geomstats._backend.pytorch.</span></span><span class="sig-name descname"><span class="pre">polygamma</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">input</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tensor</span></span></span><a class="headerlink" href="#geomstats._backend.pytorch.polygamma" title="Permalink to this definition">#</a></dt>
<dd><p>Alias for <code class="xref py py-func docutils literal notranslate"><span class="pre">torch.special.polygamma()</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geomstats._backend.pytorch.power">
<span class="sig-prename descclassname"><span class="pre">geomstats._backend.pytorch.</span></span><span class="sig-name descname"><span class="pre">power</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#geomstats._backend.pytorch.power" title="Permalink to this definition">#</a></dt>
<dd><p>pow(input, exponent, <a href="#id5"><span class="problematic" id="id6">*</span></a>, out=None) -&gt; Tensor</p>
<p>Takes the power of each element in <code class="xref py py-attr docutils literal notranslate"><span class="pre">input</span></code> with <code class="xref py py-attr docutils literal notranslate"><span class="pre">exponent</span></code> and
returns a tensor with the result.</p>
<p><code class="xref py py-attr docutils literal notranslate"><span class="pre">exponent</span></code> can be either a single <code class="docutils literal notranslate"><span class="pre">float</span></code> number or a <cite>Tensor</cite>
with the same number of elements as <code class="xref py py-attr docutils literal notranslate"><span class="pre">input</span></code>.</p>
<p>When <code class="xref py py-attr docutils literal notranslate"><span class="pre">exponent</span></code> is a scalar value, the operation applied is:</p>
<div class="math notranslate nohighlight">
\[\text{out}_i = x_i ^ \text{exponent}\]</div>
<p>When <code class="xref py py-attr docutils literal notranslate"><span class="pre">exponent</span></code> is a tensor, the operation applied is:</p>
<div class="math notranslate nohighlight">
\[\text{out}_i = x_i ^ {\text{exponent}_i}\]</div>
<p>When <code class="xref py py-attr docutils literal notranslate"><span class="pre">exponent</span></code> is a tensor, the shapes of <code class="xref py py-attr docutils literal notranslate"><span class="pre">input</span></code>
and <code class="xref py py-attr docutils literal notranslate"><span class="pre">exponent</span></code> must be <span class="xref std std-ref">broadcastable</span>.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>input (Tensor): the input tensor.
exponent (float or tensor): the exponent value</p>
</dd>
<dt>Keyword args:</dt><dd><p>out (Tensor, optional): the output tensor.</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">tensor([ 0.4331,  1.2475,  0.6834, -0.2791])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">torch</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">tensor([ 0.1875,  1.5561,  0.4670,  0.0779])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">exp</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">5.</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">5.</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">tensor([ 1.,  2.,  3.,  4.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">exp</span>
<span class="go">tensor([ 1.,  2.,  3.,  4.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">torch</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">exp</span><span class="p">)</span>
<span class="go">tensor([   1.,    4.,   27.,  256.])</span>
</pre></div>
</div>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">geomstats._backend.pytorch.</span></span><span class="sig-name descname"><span class="pre">pow</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exponent</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tensor</span></span></span></dt>
<dd></dd></dl>

<p><code class="xref py py-attr docutils literal notranslate"><span class="pre">self</span></code> is a scalar <code class="docutils literal notranslate"><span class="pre">float</span></code> value, and <code class="xref py py-attr docutils literal notranslate"><span class="pre">exponent</span></code> is a tensor.
The returned tensor <code class="xref py py-attr docutils literal notranslate"><span class="pre">out</span></code> is of the same shape as <code class="xref py py-attr docutils literal notranslate"><span class="pre">exponent</span></code></p>
<p>The operation applied is:</p>
<div class="math notranslate nohighlight">
\[\text{out}_i = \text{self} ^ {\text{exponent}_i}\]</div>
<dl class="simple">
<dt>Args:</dt><dd><p>self (float): the scalar base value for the power operation
exponent (Tensor): the exponent tensor</p>
</dd>
<dt>Keyword args:</dt><dd><p>out (Tensor, optional): the output tensor.</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">exp</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">5.</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">base</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">torch</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">exp</span><span class="p">)</span>
<span class="go">tensor([  2.,   4.,   8.,  16.])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geomstats._backend.pytorch.quantile">
<span class="sig-prename descclassname"><span class="pre">geomstats._backend.pytorch.</span></span><span class="sig-name descname"><span class="pre">quantile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keepdim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interpolation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'linear'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tensor</span></span></span><a class="headerlink" href="#geomstats._backend.pytorch.quantile" title="Permalink to this definition">#</a></dt>
<dd><p>Computes the q-th quantiles of each row of the <code class="xref py py-attr docutils literal notranslate"><span class="pre">input</span></code> tensor along the dimension <code class="xref py py-attr docutils literal notranslate"><span class="pre">dim</span></code>.</p>
<p>To compute the quantile, we map q in [0, 1] to the range of indices [0, n] to find the location
of the quantile in the sorted input. If the quantile lies between two data points <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&lt;</span> <span class="pre">b</span></code> with
indices <code class="docutils literal notranslate"><span class="pre">i</span></code> and <code class="docutils literal notranslate"><span class="pre">j</span></code> in the sorted order, result is computed according to the given
<code class="xref py py-attr docutils literal notranslate"><span class="pre">interpolation</span></code> method as follows:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">linear</span></code>: <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">+</span> <span class="pre">(b</span> <span class="pre">-</span> <span class="pre">a)</span> <span class="pre">*</span> <span class="pre">fraction</span></code>, where <code class="docutils literal notranslate"><span class="pre">fraction</span></code> is the fractional part of the computed quantile index.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">lower</span></code>: <code class="docutils literal notranslate"><span class="pre">a</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">higher</span></code>: <code class="docutils literal notranslate"><span class="pre">b</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nearest</span></code>: <code class="docutils literal notranslate"><span class="pre">a</span></code> or <code class="docutils literal notranslate"><span class="pre">b</span></code>, whichever’s index is closer to the computed quantile index (rounding down for .5 fractions).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">midpoint</span></code>: <code class="docutils literal notranslate"><span class="pre">(a</span> <span class="pre">+</span> <span class="pre">b)</span> <span class="pre">/</span> <span class="pre">2</span></code>.</p></li>
</ul>
<p>If <code class="xref py py-attr docutils literal notranslate"><span class="pre">q</span></code> is a 1D tensor, the first dimension of the output represents the quantiles and has size
equal to the size of <code class="xref py py-attr docutils literal notranslate"><span class="pre">q</span></code>, the remaining dimensions are what remains from the reduction.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>By default <code class="xref py py-attr docutils literal notranslate"><span class="pre">dim</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code> resulting in the <code class="xref py py-attr docutils literal notranslate"><span class="pre">input</span></code> tensor being flattened before computation.</p>
</div>
<dl>
<dt>Args:</dt><dd><p>input (Tensor): the input tensor.
q (float or Tensor): a scalar or 1D tensor of values in the range [0, 1].
dim (int): the dimension to reduce.
keepdim (bool): whether the output tensor has <code class="xref py py-attr docutils literal notranslate"><span class="pre">dim</span></code> retained or not.</p>
</dd>
<dt>Keyword arguments:</dt><dd><dl class="simple">
<dt>interpolation (string): interpolation method to use when the desired quantile lies between two data points.</dt><dd><p>Can be <code class="docutils literal notranslate"><span class="pre">linear</span></code>, <code class="docutils literal notranslate"><span class="pre">lower</span></code>, <code class="docutils literal notranslate"><span class="pre">higher</span></code>, <code class="docutils literal notranslate"><span class="pre">midpoint</span></code> and <code class="docutils literal notranslate"><span class="pre">nearest</span></code>.
Default is <code class="docutils literal notranslate"><span class="pre">linear</span></code>.</p>
</dd>
</dl>
<p>out (Tensor, optional): the output tensor.</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">tensor([[ 0.0795, -1.2117,  0.9765],</span>
<span class="go">        [ 1.1707,  0.6706,  0.4884]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">torch</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdim</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">tensor([[[-0.5661],</span>
<span class="go">        [ 0.5795]],</span>

<span class="go">        [[ 0.0795],</span>
<span class="go">        [ 0.6706]],</span>

<span class="go">        [[ 0.5280],</span>
<span class="go">        [ 0.9206]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">torch</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdim</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([3, 2, 1])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">4.</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">tensor([0., 1., 2., 3.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">torch</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">)</span>
<span class="go">tensor(1.8000)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">torch</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;lower&#39;</span><span class="p">)</span>
<span class="go">tensor(1.)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">torch</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;higher&#39;</span><span class="p">)</span>
<span class="go">tensor(2.)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">torch</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;midpoint&#39;</span><span class="p">)</span>
<span class="go">tensor(1.5000)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">torch</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">)</span>
<span class="go">tensor(2.)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">torch</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">)</span>
<span class="go">tensor(1.)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geomstats._backend.pytorch.real">
<span class="sig-prename descclassname"><span class="pre">geomstats._backend.pytorch.</span></span><span class="sig-name descname"><span class="pre">real</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tensor</span></span></span><a class="headerlink" href="#geomstats._backend.pytorch.real" title="Permalink to this definition">#</a></dt>
<dd><p>Returns a new tensor containing real values of the <code class="xref py py-attr docutils literal notranslate"><span class="pre">self</span></code> tensor.
The returned tensor and <code class="xref py py-attr docutils literal notranslate"><span class="pre">self</span></code> share the same underlying storage.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p><a class="reference internal" href="#geomstats._backend.pytorch.real" title="geomstats._backend.pytorch.real"><code class="xref py py-func docutils literal notranslate"><span class="pre">real()</span></code></a> is only supported for tensors with complex dtypes.</p>
</div>
<dl class="simple">
<dt>Args:</dt><dd><p>input (Tensor): the input tensor.</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">cfloat</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">tensor([(0.3100+0.3553j), (-0.5445-0.7896j), (-1.6492-0.0633j), (-0.0638-0.8119j)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">real</span>
<span class="go">tensor([ 0.3100, -0.5445, -1.6492, -0.0638])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geomstats._backend.pytorch.repeat">
<span class="sig-prename descclassname"><span class="pre">geomstats._backend.pytorch.</span></span><span class="sig-name descname"><span class="pre">repeat</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#geomstats._backend.pytorch.repeat" title="Permalink to this definition">#</a></dt>
<dd><p>repeat_interleave(input, repeats, dim=None, <a href="#id7"><span class="problematic" id="id8">*</span></a>, output_size=None) -&gt; Tensor</p>
<p>Repeat elements of a tensor.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This is different from <code class="xref py py-meth docutils literal notranslate"><span class="pre">torch.Tensor.repeat()</span></code> but similar to <code class="docutils literal notranslate"><span class="pre">numpy.repeat</span></code>.</p>
</div>
<dl>
<dt>Args:</dt><dd><p>input (Tensor): the input tensor.
repeats (Tensor or int): The number of repetitions for each element.</p>
<blockquote>
<div><p>repeats is broadcasted to fit the shape of the given axis.</p>
</div></blockquote>
<dl class="simple">
<dt>dim (int, optional): The dimension along which to repeat values.</dt><dd><p>By default, use the flattened input array, and return a flat output
array.</p>
</dd>
</dl>
</dd>
<dt>Keyword args:</dt><dd><dl class="simple">
<dt>output_size (int, optional): Total output size for the given axis</dt><dd><p>( e.g. sum of repeats). If given, it will avoid stream syncronization
needed to calculate output shape of the tensor.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>Tensor: Repeated tensor which has the same shape as input, except along the given axis.</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">repeat_interleave</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">tensor([1, 1, 2, 2, 3, 3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">torch</span><span class="o">.</span><span class="n">repeat_interleave</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">tensor([1, 1, 2, 2, 3, 3, 4, 4])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">torch</span><span class="o">.</span><span class="n">repeat_interleave</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">tensor([[1, 1, 1, 2, 2, 2],</span>
<span class="go">        [3, 3, 3, 4, 4, 4]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">torch</span><span class="o">.</span><span class="n">repeat_interleave</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]),</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">tensor([[1, 2],</span>
<span class="go">        [3, 4],</span>
<span class="go">        [3, 4]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">torch</span><span class="o">.</span><span class="n">repeat_interleave</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]),</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">output_size</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="go">tensor([[1, 2],</span>
<span class="go">        [3, 4],</span>
<span class="go">        [3, 4]])</span>
</pre></div>
</div>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">geomstats._backend.pytorch.</span></span><span class="sig-name descname"><span class="pre">repeat_interleave</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">repeats</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tensor</span></span></span></dt>
<dd></dd></dl>

<p>If the <cite>repeats</cite> is <cite>tensor([n1, n2, n3, …])</cite>, then the output will be
<cite>tensor([0, 0, …, 1, 1, …, 2, 2, …, …])</cite> where <cite>0</cite> appears <cite>n1</cite> times,
<cite>1</cite> appears <cite>n2</cite> times, <cite>2</cite> appears <cite>n3</cite> times, etc.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geomstats._backend.pytorch.reshape">
<span class="sig-prename descclassname"><span class="pre">geomstats._backend.pytorch.</span></span><span class="sig-name descname"><span class="pre">reshape</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tensor</span></span></span><a class="headerlink" href="#geomstats._backend.pytorch.reshape" title="Permalink to this definition">#</a></dt>
<dd><p>Returns a tensor with the same data and number of elements as <code class="xref py py-attr docutils literal notranslate"><span class="pre">input</span></code>,
but with the specified shape. When possible, the returned tensor will be a view
of <code class="xref py py-attr docutils literal notranslate"><span class="pre">input</span></code>. Otherwise, it will be a copy. Contiguous inputs and inputs
with compatible strides can be reshaped without copying, but you should not
depend on the copying vs. viewing behavior.</p>
<p>See <code class="xref py py-meth docutils literal notranslate"><span class="pre">torch.Tensor.view()</span></code> on when it is possible to return a view.</p>
<p>A single dimension may be -1, in which case it’s inferred from the remaining
dimensions and the number of elements in <code class="xref py py-attr docutils literal notranslate"><span class="pre">input</span></code>.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>input (Tensor): the tensor to be reshaped
shape (tuple of ints): the new shape</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">4.</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">torch</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="go">tensor([[ 0.,  1.],</span>
<span class="go">        [ 2.,  3.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">torch</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,))</span>
<span class="go">tensor([ 0,  1,  2,  3])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geomstats._backend.pytorch.set_diag">
<span class="sig-prename descclassname"><span class="pre">geomstats._backend.pytorch.</span></span><span class="sig-name descname"><span class="pre">set_diag</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">new_diag</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/geomstats/_backend/pytorch.html#set_diag"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#geomstats._backend.pytorch.set_diag" title="Permalink to this definition">#</a></dt>
<dd><p>Set the diagonal along the last two axis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>array-like, shape=[dim]</em>) – Initial array.</p></li>
<li><p><strong>new_diag</strong> (<em>array-like, shape=[dim[-2]]</em>) – Values to set on the diagonal.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><em>None</em></p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This mimics tensorflow.linalg.set_diag(x, new_diag), when new_diag is a
1-D array, but modifies x instead of creating a copy.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geomstats._backend.pytorch.sign">
<span class="sig-prename descclassname"><span class="pre">geomstats._backend.pytorch.</span></span><span class="sig-name descname"><span class="pre">sign</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tensor</span></span></span><a class="headerlink" href="#geomstats._backend.pytorch.sign" title="Permalink to this definition">#</a></dt>
<dd><p>Returns a new tensor with the signs of the elements of <code class="xref py py-attr docutils literal notranslate"><span class="pre">input</span></code>.</p>
<div class="math notranslate nohighlight">
\[\text{out}_{i} = \operatorname{sgn}(\text{input}_{i})\]</div>
<dl class="simple">
<dt>Args:</dt><dd><p>input (Tensor): the input tensor.</p>
</dd>
<dt>Keyword args:</dt><dd><p>out (Tensor, optional): the output tensor.</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mf">0.7</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">2.3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">tensor([ 0.7000, -1.2000,  0.0000,  2.3000])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">torch</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">tensor([ 1., -1.,  0.,  1.])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geomstats._backend.pytorch.sin">
<span class="sig-prename descclassname"><span class="pre">geomstats._backend.pytorch.</span></span><span class="sig-name descname"><span class="pre">sin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tensor</span></span></span><a class="headerlink" href="#geomstats._backend.pytorch.sin" title="Permalink to this definition">#</a></dt>
<dd><p>Returns a new tensor with the sine of the elements of <code class="xref py py-attr docutils literal notranslate"><span class="pre">input</span></code>.</p>
<div class="math notranslate nohighlight">
\[\text{out}_{i} = \sin(\text{input}_{i})\]</div>
<dl class="simple">
<dt>Args:</dt><dd><p>input (Tensor): the input tensor.</p>
</dd>
<dt>Keyword args:</dt><dd><p>out (Tensor, optional): the output tensor.</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">tensor([-0.5461,  0.1347, -2.7266, -0.2746])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">torch</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">tensor([-0.5194,  0.1343, -0.4032, -0.2711])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geomstats._backend.pytorch.sinh">
<span class="sig-prename descclassname"><span class="pre">geomstats._backend.pytorch.</span></span><span class="sig-name descname"><span class="pre">sinh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tensor</span></span></span><a class="headerlink" href="#geomstats._backend.pytorch.sinh" title="Permalink to this definition">#</a></dt>
<dd><p>Returns a new tensor with the hyperbolic sine of the elements of
<code class="xref py py-attr docutils literal notranslate"><span class="pre">input</span></code>.</p>
<div class="math notranslate nohighlight">
\[\text{out}_{i} = \sinh(\text{input}_{i})\]</div>
<dl class="simple">
<dt>Args:</dt><dd><p>input (Tensor): the input tensor.</p>
</dd>
<dt>Keyword args:</dt><dd><p>out (Tensor, optional): the output tensor.</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">tensor([ 0.5380, -0.8632, -0.1265,  0.9399])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">torch</span><span class="o">.</span><span class="n">sinh</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">tensor([ 0.5644, -0.9744, -0.1268,  1.0845])</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When <code class="xref py py-attr docutils literal notranslate"><span class="pre">input</span></code> is on the CPU, the implementation of torch.sinh may use
the Sleef library, which rounds very large results to infinity or negative
infinity. See <a class="reference external" href="https://sleef.org/purec.xhtml">here</a> for details.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geomstats._backend.pytorch.stack">
<span class="sig-prename descclassname"><span class="pre">geomstats._backend.pytorch.</span></span><span class="sig-name descname"><span class="pre">stack</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tensors</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tensor</span></span></span><a class="headerlink" href="#geomstats._backend.pytorch.stack" title="Permalink to this definition">#</a></dt>
<dd><p>Concatenates a sequence of tensors along a new dimension.</p>
<p>All tensors need to be of the same size.</p>
<dl>
<dt>Arguments:</dt><dd><p>tensors (sequence of Tensors): sequence of tensors to concatenate
dim (int): dimension to insert. Has to be between 0 and the number</p>
<blockquote>
<div><p>of dimensions of concatenated tensors (inclusive)</p>
</div></blockquote>
</dd>
<dt>Keyword args:</dt><dd><p>out (Tensor, optional): the output tensor.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geomstats._backend.pytorch.std">
<span class="sig-prename descclassname"><span class="pre">geomstats._backend.pytorch.</span></span><span class="sig-name descname"><span class="pre">std</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unbiased</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keepdim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tensor</span></span></span><a class="headerlink" href="#geomstats._backend.pytorch.std" title="Permalink to this definition">#</a></dt>
<dd><p>If <code class="xref py py-attr docutils literal notranslate"><span class="pre">unbiased</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, Bessel’s correction will be used.
Otherwise, the sample deviation is calculated, without any correction.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>input (Tensor): the input tensor.
dim (int or tuple of ints): the dimension or dimensions to reduce.</p>
</dd>
<dt>Keyword args:</dt><dd><p>unbiased (bool): whether to use Bessel’s correction (<span class="math notranslate nohighlight">\(\delta N = 1\)</span>).
keepdim (bool): whether the output tensor has <code class="xref py py-attr docutils literal notranslate"><span class="pre">dim</span></code> retained or not.
out (Tensor, optional): the output tensor.</p>
</dd>
</dl>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">geomstats._backend.pytorch.</span></span><span class="sig-name descname"><span class="pre">std</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unbiased</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tensor</span></span></span></dt>
<dd></dd></dl>

<p>Calculates the standard deviation of all elements in the <code class="xref py py-attr docutils literal notranslate"><span class="pre">input</span></code> tensor.</p>
<p>If <code class="xref py py-attr docutils literal notranslate"><span class="pre">unbiased</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, Bessel’s correction will be used.
Otherwise, the sample deviation is calculated, without any correction.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>input (Tensor): the input tensor.
unbiased (bool): whether to use Bessel’s correction (<span class="math notranslate nohighlight">\(\delta N = 1\)</span>).</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[</span><span class="o">-</span><span class="mf">0.8166</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.3802</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.3560</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">torch</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">unbiased</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">tensor(0.4188)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geomstats._backend.pytorch.tan">
<span class="sig-prename descclassname"><span class="pre">geomstats._backend.pytorch.</span></span><span class="sig-name descname"><span class="pre">tan</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tensor</span></span></span><a class="headerlink" href="#geomstats._backend.pytorch.tan" title="Permalink to this definition">#</a></dt>
<dd><p>Returns a new tensor with the tangent of the elements of <code class="xref py py-attr docutils literal notranslate"><span class="pre">input</span></code>.</p>
<div class="math notranslate nohighlight">
\[\text{out}_{i} = \tan(\text{input}_{i})\]</div>
<dl class="simple">
<dt>Args:</dt><dd><p>input (Tensor): the input tensor.</p>
</dd>
<dt>Keyword args:</dt><dd><p>out (Tensor, optional): the output tensor.</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">tensor([-1.2027, -1.7687,  0.4412, -1.3856])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">torch</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">tensor([-2.5930,  4.9859,  0.4722, -5.3366])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geomstats._backend.pytorch.tanh">
<span class="sig-prename descclassname"><span class="pre">geomstats._backend.pytorch.</span></span><span class="sig-name descname"><span class="pre">tanh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tensor</span></span></span><a class="headerlink" href="#geomstats._backend.pytorch.tanh" title="Permalink to this definition">#</a></dt>
<dd><p>Returns a new tensor with the hyperbolic tangent of the elements
of <code class="xref py py-attr docutils literal notranslate"><span class="pre">input</span></code>.</p>
<div class="math notranslate nohighlight">
\[\text{out}_{i} = \tanh(\text{input}_{i})\]</div>
<dl class="simple">
<dt>Args:</dt><dd><p>input (Tensor): the input tensor.</p>
</dd>
<dt>Keyword args:</dt><dd><p>out (Tensor, optional): the output tensor.</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">tensor([ 0.8986, -0.7279,  1.1745,  0.2611])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">torch</span><span class="o">.</span><span class="n">tanh</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">tensor([ 0.7156, -0.6218,  0.8257,  0.2553])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geomstats._backend.pytorch.trapz">
<span class="sig-prename descclassname"><span class="pre">geomstats._backend.pytorch.</span></span><span class="sig-name descname"><span class="pre">trapz</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tensor</span></span></span><a class="headerlink" href="#geomstats._backend.pytorch.trapz" title="Permalink to this definition">#</a></dt>
<dd><p>Alias for <code class="xref py py-func docutils literal notranslate"><span class="pre">torch.trapezoid()</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geomstats._backend.pytorch.vstack">
<span class="sig-prename descclassname"><span class="pre">geomstats._backend.pytorch.</span></span><span class="sig-name descname"><span class="pre">vstack</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tensors</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tensor</span></span></span><a class="headerlink" href="#geomstats._backend.pytorch.vstack" title="Permalink to this definition">#</a></dt>
<dd><p>Stack tensors in sequence vertically (row wise).</p>
<p>This is equivalent to concatenation along the first axis after all 1-D tensors have been reshaped by <code class="xref py py-func docutils literal notranslate"><span class="pre">torch.atleast_2d()</span></code>.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>tensors (sequence of Tensors): sequence of tensors to concatenate</p>
</dd>
<dt>Keyword args:</dt><dd><p>out (Tensor, optional): the output tensor.</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">torch</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">))</span>
<span class="go">tensor([[1, 2, 3],</span>
<span class="go">        [4, 5, 6]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[</span><span class="mi">1</span><span class="p">],[</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[</span><span class="mi">4</span><span class="p">],[</span><span class="mi">5</span><span class="p">],[</span><span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">torch</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">))</span>
<span class="go">tensor([[1],</span>
<span class="go">        [2],</span>
<span class="go">        [3],</span>
<span class="go">        [4],</span>
<span class="go">        [5],</span>
<span class="go">        [6]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geomstats._backend.pytorch.zeros">
<span class="sig-prename descclassname"><span class="pre">geomstats._backend.pytorch.</span></span><span class="sig-name descname"><span class="pre">zeros</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">*size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">layout=torch.strided</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">requires_grad=False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tensor</span></span></span><a class="headerlink" href="#geomstats._backend.pytorch.zeros" title="Permalink to this definition">#</a></dt>
<dd><p>Returns a tensor filled with the scalar value <cite>0</cite>, with the shape defined
by the variable argument <code class="xref py py-attr docutils literal notranslate"><span class="pre">size</span></code>.</p>
<dl>
<dt>Args:</dt><dd><dl class="simple">
<dt>size (int…): a sequence of integers defining the shape of the output tensor.</dt><dd><p>Can be a variable number of arguments or a collection like a list or tuple.</p>
</dd>
</dl>
</dd>
<dt>Keyword args:</dt><dd><p>out (Tensor, optional): the output tensor.
dtype (<code class="xref py py-class docutils literal notranslate"><span class="pre">torch.dtype</span></code>, optional): the desired data type of returned tensor.</p>
<blockquote>
<div><p>Default: if <code class="docutils literal notranslate"><span class="pre">None</span></code>, uses a global default (see <code class="xref py py-func docutils literal notranslate"><span class="pre">torch.set_default_tensor_type()</span></code>).</p>
</div></blockquote>
<dl class="simple">
<dt>layout (<code class="xref py py-class docutils literal notranslate"><span class="pre">torch.layout</span></code>, optional): the desired layout of returned Tensor.</dt><dd><p>Default: <code class="docutils literal notranslate"><span class="pre">torch.strided</span></code>.</p>
</dd>
<dt>device (<code class="xref py py-class docutils literal notranslate"><span class="pre">torch.device</span></code>, optional): the desired device of returned tensor.</dt><dd><p>Default: if <code class="docutils literal notranslate"><span class="pre">None</span></code>, uses the current device for the default tensor type
(see <code class="xref py py-func docutils literal notranslate"><span class="pre">torch.set_default_tensor_type()</span></code>). <code class="xref py py-attr docutils literal notranslate"><span class="pre">device</span></code> will be the CPU
for CPU tensor types and the current CUDA device for CUDA tensor types.</p>
</dd>
<dt>requires_grad (bool, optional): If autograd should record operations on the</dt><dd><p>returned tensor. Default: <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">tensor([[ 0.,  0.,  0.],</span>
<span class="go">        [ 0.,  0.,  0.]])</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">tensor([ 0.,  0.,  0.,  0.,  0.])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geomstats._backend.pytorch.zeros_like">
<span class="sig-prename descclassname"><span class="pre">geomstats._backend.pytorch.</span></span><span class="sig-name descname"><span class="pre">zeros_like</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">layout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">requires_grad</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">memory_format</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">torch.preserve_format</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tensor</span></span></span><a class="headerlink" href="#geomstats._backend.pytorch.zeros_like" title="Permalink to this definition">#</a></dt>
<dd><p>Returns a tensor filled with the scalar value <cite>0</cite>, with the same size as
<code class="xref py py-attr docutils literal notranslate"><span class="pre">input</span></code>. <code class="docutils literal notranslate"><span class="pre">torch.zeros_like(input)</span></code> is equivalent to
<code class="docutils literal notranslate"><span class="pre">torch.zeros(input.size(),</span> <span class="pre">dtype=input.dtype,</span> <span class="pre">layout=input.layout,</span> <span class="pre">device=input.device)</span></code>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>As of 0.4, this function does not support an <code class="xref py py-attr docutils literal notranslate"><span class="pre">out</span></code> keyword. As an alternative,
the old <code class="docutils literal notranslate"><span class="pre">torch.zeros_like(input,</span> <span class="pre">out=output)</span></code> is equivalent to
<code class="docutils literal notranslate"><span class="pre">torch.zeros(input.size(),</span> <span class="pre">out=output)</span></code>.</p>
</div>
<dl class="simple">
<dt>Args:</dt><dd><p>input (Tensor): the size of <code class="xref py py-attr docutils literal notranslate"><span class="pre">input</span></code> will determine size of the output tensor.</p>
</dd>
<dt>Keyword args:</dt><dd><dl class="simple">
<dt>dtype (<code class="xref py py-class docutils literal notranslate"><span class="pre">torch.dtype</span></code>, optional): the desired data type of returned Tensor.</dt><dd><p>Default: if <code class="docutils literal notranslate"><span class="pre">None</span></code>, defaults to the dtype of <code class="xref py py-attr docutils literal notranslate"><span class="pre">input</span></code>.</p>
</dd>
<dt>layout (<code class="xref py py-class docutils literal notranslate"><span class="pre">torch.layout</span></code>, optional): the desired layout of returned tensor.</dt><dd><p>Default: if <code class="docutils literal notranslate"><span class="pre">None</span></code>, defaults to the layout of <code class="xref py py-attr docutils literal notranslate"><span class="pre">input</span></code>.</p>
</dd>
<dt>device (<code class="xref py py-class docutils literal notranslate"><span class="pre">torch.device</span></code>, optional): the desired device of returned tensor.</dt><dd><p>Default: if <code class="docutils literal notranslate"><span class="pre">None</span></code>, defaults to the device of <code class="xref py py-attr docutils literal notranslate"><span class="pre">input</span></code>.</p>
</dd>
<dt>requires_grad (bool, optional): If autograd should record operations on the</dt><dd><p>returned tensor. Default: <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</dd>
<dt>memory_format (<code class="xref py py-class docutils literal notranslate"><span class="pre">torch.memory_format</span></code>, optional): the desired memory format of</dt><dd><p>returned Tensor. Default: <code class="docutils literal notranslate"><span class="pre">torch.preserve_format</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">input</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">torch</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span>
<span class="go">tensor([[ 0.,  0.,  0.],</span>
<span class="go">        [ 0.,  0.,  0.]])</span>
</pre></div>
</div>
</dd></dl>

<span class="target" id="module-geomstats._backend.tensorflow"></span><p>Tensorflow based computation backend.</p>
<dl class="py function">
<dt class="sig sig-object py" id="geomstats._backend.tensorflow.array_from_sparse">
<span class="sig-prename descclassname"><span class="pre">geomstats._backend.tensorflow.</span></span><span class="sig-name descname"><span class="pre">array_from_sparse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_shape</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/geomstats/_backend/tensorflow.html#array_from_sparse"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#geomstats._backend.tensorflow.array_from_sparse" title="Permalink to this definition">#</a></dt>
<dd><p>Create an array of given shape, with values at specific indices.</p>
<p>The rest of the array will be filled with zeros.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>indices</strong> (<em>iterable(tuple(int))</em>) – Index of each element which will be assigned a specific value.</p></li>
<li><p><strong>data</strong> (<em>iterable(scalar)</em>) – Value associated at each index.</p></li>
<li><p><strong>target_shape</strong> (<em>tuple(int)</em>) – Shape of the output array.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>a</strong> (<em>array, shape=target_shape</em>) – Array of zeros with specified values assigned to specified indices.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geomstats._backend.tensorflow.assignment">
<span class="sig-prename descclassname"><span class="pre">geomstats._backend.tensorflow.</span></span><span class="sig-name descname"><span class="pre">assignment</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/geomstats/_backend/tensorflow.html#assignment"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#geomstats._backend.tensorflow.assignment" title="Permalink to this definition">#</a></dt>
<dd><p>Add values at given indices of an array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>array-like, shape=[dim]</em>) – Initial array.</p></li>
<li><p><strong>values</strong> (<em>{float, list(float)}</em>) – Value or list of values to be assigned.</p></li>
<li><p><strong>indices</strong> (<em>{</em>)</p></li>
<li><p><strong>int, tuple(int), array-like({int, tuple, boolean})</strong> – Single index or array of indices where values are assigned.
If the length of the tuples is shorter than ndim(x) by one, values are
assigned to each copy along axis.
If indices is a list of booleans and ndim(x) &gt; 1, values are assigned
across all dimensions.</p></li>
<li><p><strong>axis</strong> (<em>int, optional</em>) – Axis along which values are assigned, if vectorized.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>x_new</strong> (<em>array-like, shape=[dim]</em>) – Copy of x as the sum of x and the values at the given indices.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>If a single value is provided, it is assigned at all the indices.
If a single index is provided, and len(indices) == ndim(x) - 1, then values
are assigned along axis.</p>
<p class="rubric">Examples</p>
<p>Most examples translate as
assignment(x, indices, values) &lt;=&gt; x[indices] = values
Some special cases are given by vectorisation.
(Beware that copies are always returned).
if ndim(x) == 3, assignment(x, 1, (1, 0), 1) &lt;=&gt; x[1, :, 0] = 1
if ndim(x) == 2, assignment(x, [1, 2], [(0, 1), (2, 3)]) &lt;=&gt;</p>
<blockquote>
<div><p>x[((0, 2), (1, 3))] = [1, 2]</p>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geomstats._backend.tensorflow.assignment_by_sum">
<span class="sig-prename descclassname"><span class="pre">geomstats._backend.tensorflow.</span></span><span class="sig-name descname"><span class="pre">assignment_by_sum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/geomstats/_backend/tensorflow.html#assignment_by_sum"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#geomstats._backend.tensorflow.assignment_by_sum" title="Permalink to this definition">#</a></dt>
<dd><p>Add values at given indices of an array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>array-like, shape=[dim]</em>) – Initial array.</p></li>
<li><p><strong>values</strong> (<em>{float, list(float)}</em>) – Value or list of values to be assigned.</p></li>
<li><p><strong>indices</strong> (<em>{</em>)</p></li>
<li><p><strong>int, tuple(int), array-like({int, tuple, boolean})</strong> – Single index or array of indices where values are assigned.
If the length of the tuples is shorter than ndim(x) by one, values are
assigned to each copy along axis.
If indices is a list of booleans and ndim(x) &gt; 1, values are assigned
across all dimensions.</p></li>
<li><p><strong>axis</strong> (<em>int, optional</em>) – Axis along which values are assigned, if vectorized.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>x_new</strong> (<em>array-like, shape=[dim]</em>) – Copy of x as the sum of x and the values at the given indices.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>If a single value is provided, it is assigned at all the indices.
If a single index is provided, and len(indices) == ndim(x) - 1, then values
are assigned along axis.</p>
<p class="rubric">Examples</p>
<p>Most examples translate as
assignment_by_sum(x, indices, values) &lt;=&gt; x[indices] = x[indices] + values
Some special cases are given by vectorisation.
(Beware that copies are always returned).
if ndim(x) == 3, assignment_by_sum(x, 1, (1, 0), 1) &lt;=&gt; x[1, :, 0] += 1
if ndim(x) == 2, assignment_by_sum(x, [1, 2], [(0, 1), (2, 3)]) &lt;=&gt;</p>
<blockquote>
<div><p>x[((0, 2), (1, 3))] += [1, 2]</p>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geomstats._backend.tensorflow.flatten">
<span class="sig-prename descclassname"><span class="pre">geomstats._backend.tensorflow.</span></span><span class="sig-name descname"><span class="pre">flatten</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/geomstats/_backend/tensorflow.html#flatten"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#geomstats._backend.tensorflow.flatten" title="Permalink to this definition">#</a></dt>
<dd><p>Collapse the tensor into 1-D.</p>
<p>Following <a class="reference external" href="https://www.tensorflow.org/api_docs/python/_tf/reshape">https://www.tensorflow.org/api_docs/python/_tf/reshape</a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geomstats._backend.tensorflow.get_slice">
<span class="sig-prename descclassname"><span class="pre">geomstats._backend.tensorflow.</span></span><span class="sig-name descname"><span class="pre">get_slice</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/geomstats/_backend/tensorflow.html#get_slice"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#geomstats._backend.tensorflow.get_slice" title="Permalink to this definition">#</a></dt>
<dd><p>Return a slice of an array, following Numpy’s style.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>array-like, shape=[dim]</em>) – Initial array.</p></li>
<li><p><strong>indices</strong> (<em>iterable(iterable(int))</em>) – Indices which are kept along each axis, starting from 0.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>slice</strong> (<em>array-like</em>) – Slice of x given by indices.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This follows Numpy’s convention: indices are grouped by axis.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">_tf</span><span class="o">.</span><span class="n">convert_to_tensor</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">30</span><span class="p">)),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">get_slice</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">)))</span>
<span class="go">&lt;tf.Tensor: id=41, shape=(2,), dtype=int32, numpy=array([ 8, 29])&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geomstats._backend.tensorflow.mat_from_diag_triu_tril">
<span class="sig-prename descclassname"><span class="pre">geomstats._backend.tensorflow.</span></span><span class="sig-name descname"><span class="pre">mat_from_diag_triu_tril</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">diag</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tri_upp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tri_low</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/geomstats/_backend/tensorflow.html#mat_from_diag_triu_tril"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#geomstats._backend.tensorflow.mat_from_diag_triu_tril" title="Permalink to this definition">#</a></dt>
<dd><p>Build matrix from given components.</p>
<p>Forms a matrix from diagonal, strictly upper triangular and
strictly lower traingular parts.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>diag</strong> (<em>array_like, shape=[…, n]</em>)</p></li>
<li><p><strong>tri_upp</strong> (<em>array_like, shape=[…, (n * (n - 1)) / 2]</em>)</p></li>
<li><p><strong>tri_low</strong> (<em>array_like, shape=[…, (n * (n - 1)) / 2]</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>mat</strong> (<em>array_like, shape=[…, n, n]</em>)</p>
</dd>
</dl>
</dd></dl>

</section>


              </article>
              

              
              <footer class="bd-footer-article">
                  <!-- Previous / next buttons -->
<div class='prev-next-area'>
  <a class='left-prev' id="prev-link" href="datasets.html" title="previous page">
      <i class="fas fa-angle-left"></i>
      <div class="prev-next-info">
          <p class="prev-next-subtitle">previous</p>
          <p class="prev-next-title">Datasets</p>
      </div>
  </a>
  <a class='right-next' id="next-link" href="visualization.html" title="next page">
  <div class="prev-next-info">
      <p class="prev-next-subtitle">next</p>
      <p class="prev-next-title">Visualization</p>
  </div>
  <i class="fas fa-angle-right"></i>
  </a>
</div>
              </footer>
              
          </div>
          
      </div>
    </div>

  
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/pydata-sphinx-theme.js?digest=92025949c220c2e29695"></script>

<footer class="bd-footer"><div class="bd-footer__inner container">
  
  <div class="footer-item">
    <p class="copyright">
    &copy; Copyright 2022-2023, Geomstats, Inc..<br>
</p>
  </div>
  
  <div class="footer-item">
    <p class="sphinx-version">
Created using <a href="http://sphinx-doc.org/">Sphinx</a> 5.1.1.<br>
</p>
  </div>
  
</div>
</footer>
  </body>
</html>